---
title: "USDA Inflammation Metabolomics Data analysis"
subtitle: "Urine, HILIC (-) LCMS"
author: "Maria Sholola"
date: '2023-06-05'
output: 
  html_document:
    highlight: kate
    theme: yeti
    toc: true
    toc_float: true
    toc_depth: 5
    code_download: true
    fig_width: 7
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo=TRUE) 
```

# Load libraries
```{r, warning = FALSE, message = FALSE}
library(tidyverse) # for everything
library(readxl) # for reading in excel files
library(janitor) # data checks and cleaning
library(glue) # for easy pasting
library(FactoMineR) # for PCA
library(factoextra) # for PCA
library(rstatix) # for stats
library(pheatmap) # for heatmaps
library(plotly) # for interactive plots
library(htmlwidgets) # for saving interactive plots
library(devtools)
library(notame) # used for feature clustering
library(doParallel)
library(igraph) # feature clustering
library(ggpubr) # visualizations
library(knitr) # clean table printing
library(rmarkdown)
library(mixOmics) # for multilevel PCAs
library(corrr) # correlations
library(ggthemes)
library(ggtext)
library(PCAtools)
library(pathview) # for functional analysis and KEGG annotation
```

# Read in data
```{r}
# raw filtered metabolomics data in HILIC (-)
omicsdata <- read_csv("Feature lists/HILIC-NEG-Filtered-Data-05Jun23_2414features.csv")

# metadata
metadata <- read_excel("Metadata-urine-HILIC-NEG.xlsx")
```

# Wrangle data

```{r}
metadata <- metadata %>%
  rename("sample_ID" = Sample_ID)
```


```{r}
# rename "row ID"
omicsdata <- omicsdata %>%
  rename("row_ID" = `row ID`)

# how many features
nrow(omicsdata)

# are there any duplicates?
omicsdata %>% get_dupes(mz_rt)

```

```{r}
# remove dupes
omicsdata <- omicsdata %>% 
  distinct(mz_rt, .keep_all = TRUE)

# check again for dupes
omicsdata %>% get_dupes(mz_rt)

# how many features
nrow(omicsdata)
```

Sometimes a weird logical column (lgl) comes up in my data. Let's check if it's there

```{r}
colnames(omicsdata)
```


```{r}
# remove weird lgl column
omicsdata <- omicsdata %>%
  dplyr::select(!where(is.logical))

colnames(omicsdata)
```



```{r}
# create long df for omics df
omicsdata_tidy <- omicsdata %>%
  pivot_longer(cols = 3:ncol(.),
               names_to = "sample_ID",
               values_to = "peak_height")

# combine meta and omics dfs
df_combined <- full_join(omicsdata_tidy,
                         metadata,
                         by = c("sample_ID" = "sample_ID"))

# separate mz and rt
df_combined_sep <- df_combined %>%
  separate(col = mz_rt,
           into = c("mz", "rt"),
           sep = "_") 

# convert columns to correct type
df_combined_sep$mz <- as.numeric(df_combined_sep$mz)
df_combined_sep$rt <- as.numeric(df_combined_sep$rt)
df_combined_sep$Subject <- as.character(df_combined_sep$Subject)
df_combined_sep$Intervention <- as.character(df_combined_sep$Intervention)

# rearrange column order
df_combined_sep <- df_combined_sep %>%
 dplyr::select(sample_ID, pre_post, Intervention, everything())

str(df_combined_sep)

# replace NA's in subject and intervention columns with QC
df_combined_sep$Subject <- df_combined_sep$Subject %>%
  replace_na("QC")

df_combined_sep$Intervention <- df_combined_sep$Intervention %>%
  replace_na("QC")


```

# Data summaries

## Number of masses detected
```{r}
nrow(omicsdata)
```


## Mass range for metabolites detected?

```{r}
range(df_combined_sep$mz)
```

## RT range for metabolites detected?

```{r}
range(df_combined_sep$rt)
```

## mass vs RT scatterplot
```{r}
# plot
(plot_mzvsrt <- df_combined_sep %>%
  ggplot(aes(x = rt, y = mz)) +
  geom_point() +
  theme_minimal() +
  labs(x = "Retention time, min",
       y = "m/z, neutral",
       title = "mz across RT for all features"))
```

## Histogram for mass range
```{r}
df_combined_sep %>%
  ggplot(aes(x = mz)) +
  geom_histogram(binwidth = 25) +
  theme_minimal() +
  labs(x = "Monoisotopic mass (amu)",
       y = "Number of features",
       title = "Distribution of features by mass")
```

## Histogram for RT

```{r}
df_combined_sep %>%
  ggplot(aes(x = rt)) +
  geom_histogram(binwidth = 0.1) + # 6 second bins
  theme_minimal() +
  labs(x = "Retention time",
       y = "Number of features",
       title = "Distribution of features by retention time")
```


# NAs and imputing

## NAs
```{r}
# NAs in all data including QCs
NAbyRow <- rowSums(is.na(omicsdata[,-1]))

hist(NAbyRow,
     breaks = 56, # because there are 56 samples, 48 samples + 8 QCs
     xlab = "Number of missing values",
     ylab = "Number of metabolites",
     main = "How many missing values are there?")
```

```{r}
# samples only (no QCs)
omicsdata_noQC <- omicsdata %>%
 dplyr::select(-contains("QC"))

#NAs in samples only?
NAbyRow_noQC <- rowSums(is.na(omicsdata_noQC[,-1]))

hist(NAbyRow_noQC,
     breaks = 48, # because there are 48 samples 
     xlab = "Number of missing values",
     ylab = "Number of metabolites",
     main = "How many missing values are there?")
```

Are there any missing values in QCs? There shouldn't be after data preprocessing/filtering
```{r}
omicsdata_QC <- omicsdata %>%
 dplyr::select(starts_with("P")) 

NAbyRow_QC <- colSums(is.na(omicsdata_QC))
# lets confirm that there are no missing values from my QCs
sum(NAbyRow_QC) # no
```


```{r}
# calculate how many NAs there are per feature in whole data set
contains_NAs <- df_combined %>%
  group_by(mz_rt) %>%
  count(is.na(peak_height)) %>%
  filter(`is.na(peak_height)` == TRUE)
head(contains_NAs)
```




## Remove NAs

To try and handle outliers, I came up with filtering out metabolites that are only present in one person. i.e. remove metabolites that are missing from at least 44 samples. I am taking this bit out for now as it did not change anything

```{r, eval=FALSE}
# remove features that have 44 or more NAs
omit_features <- contains_NAs %>%
  filter(n >= 44)
#preview
nrow(omit_features) # 109 features to remove

# how many features to remove?
nrow(omicsdata) - nrow(omit_features)

# now remove these features from the omics dataset
omicsdata <- omicsdata %>%
  anti_join(omit_features,
            by = "mz_rt")

 # how many features are there now?
nrow(omicsdata)
```


## Data imputation
```{r}
# impute any missing values by replacing them with 1/2 of the lowest peak height value of a feature (i.e. in a row).
imputed_omicsdata <- omicsdata

imputed_omicsdata[] <- lapply(imputed_omicsdata, 
                              function(x) ifelse(is.na(x),
                                                 min(x, na.rm = TRUE)/2, x))

dim(imputed_omicsdata)
```

Are there any NAs?
```{r}
imputed_omicsdata %>%
  is.na() %>%
  sum()

# imputations worked
```


# Create new imputed tidy datasets
```{r}
# create long df for imputed omics df
imputed_omicsdata_tidy <- imputed_omicsdata %>%
  pivot_longer(cols = 3:ncol(.),
               names_to = "sample_ID",
               values_to = "peak_height")

# combine meta and imputed omics dfs
imputed_fulldata <- full_join(imputed_omicsdata_tidy,
                         metadata,
                         by = c("sample_ID" = "sample_ID"))

# separate mz and rt
imputed_fulldata_sep <- imputed_fulldata %>%
  separate(col = mz_rt,
           into = c("mz", "rt"),
           sep = "_") 

# convert columns to correct type
imputed_fulldata_sep$mz <- as.numeric(imputed_fulldata_sep$mz)
imputed_fulldata_sep$rt <- as.numeric(imputed_fulldata_sep$rt)
imputed_fulldata_sep$Subject <- as.character(imputed_fulldata_sep$Subject)
imputed_fulldata_sep$Intervention <- as.character(imputed_fulldata_sep$Intervention)
```


# Notame feature reduction

vignette for reference
```{r}
#browseVignettes("notame")
```

## Plot features. RT vs mz before notame
```{r}
# rt vs mz plot
imputed_fulldata_sep %>%
  ggplot(aes(x = rt, y = mz)) +
  geom_point() +
  theme_minimal() +
  labs(x = "RT (min)",
       y = "mz")
```


## Data restructuring for notame
```{r}
# create features list from imputed data set to only include unique feature ID's (mz_rt), mz and RT
features <- imputed_fulldata_sep %>%
  cbind(imputed_fulldata$mz_rt) %>%
  rename("mz_rt" = "imputed_fulldata$mz_rt") %>%
 dplyr::select(c(mz_rt, mz, rt)) %>%
  distinct() # remove the duplicate rows

# create a second data frame which is just imputed_fulldata restructured to another wide format
data_notame <- data.frame(imputed_omicsdata %>%
                           dplyr::select(-row_ID) %>%
                            t())

data_notame <- data_notame %>%
  tibble::rownames_to_column() %>% # change samples from rownames to its own column
  row_to_names(row_number = 1) # change the feature IDs (mz_rt) from first row obs into column name
```

Check structures
```{r}
# check if mz and rt are numeric
str(features)
tibble(features)
```

```{r}
# check if results are numeric
tibble(data_notame)

# change to results to numeric
data_notame <- data_notame %>%
  mutate_at(-1, as.numeric)

tibble(data_notame)
```


## Find connections
```{r}
connection <- find_connections(data = data_notame,
                               features = features,
                               corr_thresh = 0.9,
                               rt_window = 1/60,
                               name_col = "mz_rt",
                               mz_col = "mz",
                               rt_col = "rt")

head(connection)
```

## Clustering
```{r}
clusters <- find_clusters(connections = connection, d_thresh = 0.8)
```

```{r}
# assign a cluster ID to all features. Clusters are named after feature with highest median peak height
features_clustered <- assign_cluster_id(data_notame, clusters, features, name_col = "mz_rt")

# visualize clusters
#visualize_clusters(data_notame, features, clusters, min_size = 3, rt_window = 2,name_col = "mz_rt", mz_col = "mz", rt_col = "rt", file_path = "~/path/to/project/")

# lets see how many features are removed when we only keep one feature per cluster
pulled <- pull_clusters(data_notame, features_clustered, name_col = "mz_rt")
cluster_data <- pulled$cdata

# export clustered feature list
write_csv(cluster_data,
          "cluster-data_hilic-neg.csv")


cluster_features <- pulled$cfeatures

nrow(omicsdata) - nrow(cluster_features)
```

 ## Reduce dataset based on clustering
```{r}
# transpose the full dataset back to wide so that it is more similar to the notame dataset
imputed_fulldata_wide <- imputed_fulldata %>%
 dplyr::select(-"row_ID") %>%
  pivot_wider(names_from = mz_rt,
              values_from = peak_height)

# list of reduced features
clusternames <- cluster_features$mz_rt

#dplyr::select only the features are in the reduced list
imp_clust <- imputed_fulldata_wide[,c(names(imputed_fulldata_wide) %in% clusternames)]

# bind back sample names
imp_clust <- cbind(imputed_fulldata_wide[1], imp_clust)

tibble(imp_clust)

```

## Mz vs RT scatterplot 

```{r}
# plot new rt vs mz scatterplot post-clustering
(plot_mzvsrt_postcluster <- cluster_features %>%
  ggplot(aes(x = rt,
             y = mz)) +
  geom_point() +
  theme_minimal() +
  labs(x = "Retention time, min",
       y = "m/z, neutral",
       title = "mz across RT for all features after clustering"))


```


```{r}
# plot both scatterplots to compare with and without notame clustering
(scatterplots <- ggarrange(plot_mzvsrt, 
                           plot_mzvsrt_postcluster, 
                           nrow = 2))
```

# Bind meta data
```{r}
imp_metabind_clust <- right_join(metadata, 
                                 imp_clust,
                                 by = "sample_ID")
```

# Visualize untransformed data

## Data wrangling
```{r}
# change meta data columns to character so that I can change NAs from QCs to "QC"
imp_metabind_clust <- imp_metabind_clust %>%
  mutate_at(c("Subject",
              "Period",
              "Intervention",
              "pre_post",
              "sequence",
              "Intervention_week",
              "Sex",
              "Age",
              "BMI"),
            as.character) 

# replace NAs in metadata columns for QCs
imp_metabind_clust[is.na(imp_metabind_clust)] <- "QC"

# unite pre_post column with intervention column to create pre_intervention column
imp_metabind_clust <- imp_metabind_clust %>%
  unite(col = "pre_post_intervention",
        c("pre_post","Intervention"),
        sep = "_",
        remove = FALSE)

# long df
imp_metabind_clust_tidy <- imp_metabind_clust %>%
  pivot_longer(cols = 12:ncol(.),
               names_to = "mz_rt",
               values_to = "rel_abund")

# structure check
str(imp_metabind_clust_tidy)
```



## Boxplot
```{r}
imp_metabind_clust_tidy %>%
  ggplot(aes(x = sample_ID, y = rel_abund, color = Intervention)) +
  geom_boxplot(alpha = 0.6) +
  scale_color_manual(values = c("light grey", "tomato1", "gold")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "LC-MS (-) Feature Abundances by Sample",
       subtitle = "Unscaled data",
       y = "Relative abundance")
```
Will need to log transform in order to normalize and actually see the data

# Log2 transform
```{r}
imp_metabind_clust_tidy_log2 <- imp_metabind_clust_tidy %>%
  mutate(rel_abund_log2 = if_else(rel_abund > 0, log2(rel_abund), 0)) %>%
  replace(is.na(.), 0)
```

## Boxplot
```{r}
(bp_data_quality <- imp_metabind_clust_tidy_log2 %>%
  ggplot(aes(x = sample_ID, y = rel_abund_log2, fill = Intervention)) +
  geom_boxplot(alpha = 0.6) +
  scale_fill_manual(values = c("light grey", "tomato1", "gold")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "LC-MS (-) Feature Abundances by Sample",
       subtitle = "Log2 transformed data",
       y = "Relative abundance"))
```

Much better! QCs look great.

# PCAs

## With QCS

### Wrangle

```{r}
# go back to wide data
imp_metabind_clust_log2 <- imp_metabind_clust_tidy_log2 %>%
 dplyr::select(!rel_abund) %>%
  pivot_wider(names_from = mz_rt,
              values_from = rel_abund_log2)

PCA.imp_metabind_clust_log2 <- PCA(imp_metabind_clust_log2,  # wide data
                                   quali.sup = 1:11, # remove qualitative variables
                                   graph = FALSE, # don't graph
                                   scale.unit = FALSE) # don't scale, already transformed data

# PCA summary
kable(summary(PCA.imp_metabind_clust_log2))
```

```{r}
# pull PC coordinates into df
PC_coord_QC_log2 <- as.data.frame(PCA.imp_metabind_clust_log2$ind$coord)

# bind back metadata from cols 1-10
PC_coord_QC_log2 <- bind_cols(imp_metabind_clust_log2[,1:11], PC_coord_QC_log2)

# grab some variance explained
importance_QC <- PCA.imp_metabind_clust_log2$eig

# set variance explained with PC1, round to 2 digits
PC1_withQC <- round(importance_QC[1,2], 2)

# set variance explained with PC2, round to 2 digits
PC2_withQC <- round(importance_QC[2,2], 2)
```

### Plots
Using FactoExtra package
```{r}
# scree plot
fviz_eig(PCA.imp_metabind_clust_log2)

# get eigenvalues
kable(get_eig(PCA.imp_metabind_clust_log2))
```

```{r}
# scores plot
fviz_pca_ind(PCA.imp_metabind_clust_log2)
```

```{r}
# loadings
fviz_pca_var(PCA.imp_metabind_clust_log2)
```

### Manual scores plots
```{r}
# manual scores plot
(PCA_withQCs <- PC_coord_QC_log2 %>%
  ggplot(aes(x = Dim.1, y = Dim.2,
             fill = factor(Intervention, levels = c("Yellow", "Red", "QC")))) +
  geom_point(shape = 21, alpha = 0.8) +
  scale_fill_manual(values = c("gold", "tomato1", "light grey")) +
  scale_color_manual(values = "black") +  
  theme_minimal() +
  coord_fixed(PC2_withQC/PC1_withQC) +
  labs(x = glue::glue("PC1: {PC1_withQC}%"),
       y = glue::glue("PC2: {PC2_withQC}%"),
       fill = "Group",
       title = "Principal Components Analysis Scores Plot",
       subtitle = "Log2 transformed data"))
```

## Without QCs

### Wrangle 

```{r}
imp_metabind_clust_log2_noQCs <- imp_metabind_clust_log2 %>%
  filter(Intervention != "QC")

PCA.imp_metabind_clust_log2_noQCs <- PCA(imp_metabind_clust_log2_noQCs, # wide data
                               quali.sup=1:11, # remove qualitative variables
                               graph=FALSE, # don't graph
                               scale.unit=FALSE) # don't scale, we already did this

# look at summary
kable(summary(PCA.imp_metabind_clust_log2_noQCs))
```

```{r}
# pull PC coordinates into df
PC_coord_noQCs_log2 <- as.data.frame(PCA.imp_metabind_clust_log2_noQCs$ind$coord)

# bind back metadata from cols 1-10
PC_coord_noQCs_log2 <- bind_cols(imp_metabind_clust_log2_noQCs[,1:11], PC_coord_noQCs_log2)

# grab some variance explained
importance_noQC <- PCA.imp_metabind_clust_log2_noQCs$eig

# set variance explained with PC1, round to 2 digits
PC1_noQC <- round(importance_noQC[1,2], 2)

# set variance explained with PC2, round to 2 digits
PC2_noQC <- round(importance_noQC[2,2], 2)
```

### Plots
Using FactoExtra

```{r}
# scree plot
fviz_eig(PCA.imp_metabind_clust_log2_noQCs)
```

```{r}
# scores plot
fviz_pca_ind(PCA.imp_metabind_clust_log2_noQCs)
```


```{r}
# plot of contributions from features to PC1
(var_contrib_noQCs_PC1 <- fviz_contrib(PCA.imp_metabind_clust_log2_noQCs,
             choice = "var",
             axes = 1,
             top = 25,
             title = "Var contribution to PC1: no QCs"))

# plot of contributions from features to PC2
(var_contrib_noQCs_PC2 <- fviz_contrib(PCA.imp_metabind_clust_log2_noQCs,
             choice = "var",
             axes = 2,
             top = 25,
             title = "Var contribution to PC2: no QCs"))
```


```{r}
# loadings
fviz_pca_var(PCA.imp_metabind_clust_log2_noQCs) # nightmare
```
### Manual scores plots

#### Yellow vs red
```{r}
(PCA_withoutQCs <- PC_coord_noQCs_log2 %>%
  ggplot(aes(x = Dim.1, 
             y = Dim.2,
             fill = Intervention)) +
    geom_point(shape = 21, alpha = 0.8) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha=0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha=0.5) +
    scale_fill_manual(values = c("gold", "tomato1")) +
    scale_color_manual(values = "black") +  
    theme_minimal() +
    coord_fixed(PC2_noQC/PC1_noQC) +
    labs(x = glue::glue("PC1: {PC1_noQC}%"),
         y = glue::glue("PC2: {PC2_noQC}%"),
         fill = "Intervention",
         title = "Principal Components Analysis Scores Plot",
         subtitle = "Log2 transformed data, without QCs"))
ggplotly(PCA_withoutQCs)
```

#### pre vs post
```{r}
(PCA_withoutQCs.pre_post <- PC_coord_noQCs_log2 %>%
  ggplot(aes(x = Dim.1, 
             y = Dim.2,
             fill = factor(pre_post_intervention, levels = c("pre_Yellow",
                                                             "post_Yellow",
                                                             "pre_Red",
                                                             "post_Red")),
             text = sample_ID)) +
    geom_point(shape = 21, alpha = 0.8) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha=0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha=0.5) +
    scale_fill_manual(values = c("gray", "yellow1", "pink1", "red2")) +
    scale_color_manual(values = "black") +  
    theme_minimal() +
    coord_fixed(PC2_noQC/PC1_noQC) +
    labs(x = glue::glue("PC1: {PC1_noQC}%"),
         y = glue::glue("PC2: {PC2_noQC}%"),
         fill = "pre_post",
         title = "Principal Components Analysis Scores Plot",
         subtitle = "Log2 transformed, without QCs"))
ggplotly(PCA_withoutQCs.pre_post,
         tooltip = "text") 
```

## Notes 

Looks like subject 6106 is an outlier. Let's take a look at what the data looks like without the outlier.


## Removal of outlier

### With QCs

#### Wrangle

```{r}
# go back to wide data
imp_no6106_log2 <- imp_metabind_clust_tidy_log2 %>%
 dplyr::select(!rel_abund) %>%
  filter(Subject != 6106) %>%
  pivot_wider(names_from = mz_rt,
              values_from = rel_abund_log2)

PCA.imp_no6106_log2 <- PCA(imp_no6106_log2,  # wide data
                                   quali.sup = 1:11, # remove qualitative variables
                                   graph = FALSE, # don't graph
                                   scale.unit = FALSE) # don't scale, already transformed data

# PCA summary
summary(PCA.imp_no6106_log2)
```


```{r}
# pull PC coordinates into df
PC_no6106_QC_log2 <- as.data.frame(PCA.imp_no6106_log2$ind$coord)

# bind back metadata from cols 1-11
PC_no6106_QC_log2 <- bind_cols(imp_no6106_log2[,1:11], PC_no6106_QC_log2)

# grab some variance explained
importance_no6106_QC <- PCA.imp_no6106_log2$eig

# set variance explained with PC1, round to 2 digits
PC1_no6106_withQC <- round(importance_no6106_QC[1,2], 2)

# set variance explained with PC2, round to 2 digits
PC2_no6106_withQC <- round(importance_no6106_QC[2,2], 2)
```

#### Plots
Using FactoExtra package
```{r}
# scree plot
fviz_eig(PCA.imp_no6106_log2)
```

```{r}
# scores plot
fviz_pca_ind(PCA.imp_no6106_log2)
```

#### Manual scores plots

##### Pre vs post
```{r}
(PCA_no6106_withQCs_prepost <- PC_no6106_QC_log2 %>%
  ggplot(aes(x = Dim.1, 
             y = Dim.2,
             fill = factor(pre_post_intervention, levels = c("pre_Yellow",
                                                             "post_Yellow",
                                                             "pre_Red",
                                                             "post_Red")),
             text = sample_ID)) +
    geom_point(shape = 21, alpha = 0.8) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha=0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha=0.5) +
    scale_fill_manual(values = c("gray", "yellow1", "pink1", "red2")) +
    scale_color_manual(values = "black") +  
    theme_minimal() +
    coord_fixed(PC2_no6106_withQC/PC1_no6106_withQC) +
    labs(x = glue::glue("PC1: {PC1_no6106_withQC}%"),
         y = glue::glue("PC2: {PC2_no6106_withQC}%"),
         fill = "pre_post",
         title = "Principal Components Analysis Scores Plot"))
ggplotly(PCA_no6106_withQCs_prepost,
         tooltip = "text") 
```


### Without QCs

#### Wrangle
```{r}
imp_no6106_log2_noQCs <- imp_metabind_clust_log2 %>%
  filter(Intervention != "QC") %>%
  filter(Subject != "6106")

PCA.imp_no6106_log2_noQCs <- PCA(imp_no6106_log2_noQCs, # wide data
                               quali.sup=1:11, # remove qualitative variables
                               graph=FALSE, # don't graph
                               scale.unit=FALSE) # don't scale, we already did this

# look at summary
kable(summary(PCA.imp_no6106_log2_noQCs))
```

```{r}
# pull PC coordinates into df
PC_coord_no6106_noQC_log2 <- as.data.frame(PCA.imp_no6106_log2_noQCs$ind$coord)

# bind back metadata from cols 1-11
PC_coord_no6106_noQC_log2 <- bind_cols(imp_no6106_log2_noQCs[,1:11], PC_coord_no6106_noQC_log2)

# grab some variance explained
importance_no6106_noQC <- PCA.imp_no6106_log2_noQCs$eig

# set variance explained with PC1, round to 2 digits
PC1_no6106_noQC <- round(importance_no6106_noQC[1,2], 2)

# set variance explained with PC2, round to 2 digits
PC2_no6106_noQC <- round(importance_no6106_noQC[2,2], 2)
```


#### Plots
Using FactoExtra
```{r}
# scree plot
fviz_eig(PCA.imp_no6106_log2_noQCs)
```

```{r}
# scores plot
fviz_pca_ind(PCA.imp_no6106_log2_noQCs)
```


#### Manual scores plots

##### Pre vs post
```{r}
(PCA_no6106_withoutQCs.prepost_intervention <- PC_coord_no6106_noQC_log2 %>%
  ggplot(aes(x = Dim.1, 
             y = Dim.2,
             fill = factor(pre_post_intervention, levels = c("pre_Yellow",
                                                             "post_Yellow",
                                                             "pre_Red",
                                                             "post_Red")),
             text = sample_ID)) +
    geom_point(shape = 21, alpha = 0.8) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha=0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha=0.5) +
    scale_fill_manual(values = c("gray", "yellow1", "pink1", "red2")) +
    scale_color_manual(values = "black") +  
    theme_minimal() +
    coord_fixed(PC2_no6106_noQC/PC1_no6106_noQC) +
    labs(x = glue::glue("PC1: {PC1_no6106_noQC}%"),
         y = glue::glue("PC2: {PC2_no6106_noQC}%"),
         fill = "pre_post",
         title = "Principal Components Analysis Scores Plot",
         subtitle = "Log2 transformed data, no 6106"))
ggplotly(PCA_no6106_withoutQCs.prepost_intervention,
         tooltip = "text") 
```



# PCAtools pckg

Here, we will further investigate the data using PCA plots from PCAtools package. 

```{r,eval=FALSE}
  if (!requireNamespace('BiocManager', quietly = TRUE))
    install.packages('BiocManager')

  BiocManager::install('PCAtools')
```


```{r}
library(PCAtools)
```

## W/ visual outliers

### Data wrangling
```{r}
# create rel abund df suitable for PCAtools package

imp_clust_omicsdata_outliers_forPCAtools <- as.data.frame(t(imp_clust)) # transpose df 

names(imp_clust_omicsdata_outliers_forPCAtools) <- imp_clust_omicsdata_outliers_forPCAtools[1,] # make sample IDs column names

imp_clust_omicsdata_outliers_forPCAtools <- imp_clust_omicsdata_outliers_forPCAtools[-1,] # remove sample ID row

# create metadata df suitable for PCAtools pckg

metadata_outliers_forPCAtools <- metadata %>%
  column_to_rownames(var = "sample_ID") # change sample ID column to rownames

# create a vector so that col names in abundance df matches metadata df
order_outliers_forPCAtools <- match(rownames(metadata_outliers_forPCAtools), colnames(imp_clust_omicsdata_outliers_forPCAtools))

# reorder col names in abundance df so that it matches metadata
abundata_outliers_reordered_forPCAtools <- imp_clust_omicsdata_outliers_forPCAtools[ ,order_outliers_forPCAtools] 

# change abundance df to numeric
abundata_outliers_reordered_forPCAtools <- abundata_outliers_reordered_forPCAtools %>%
  mutate_all(as.numeric)

# Log transform
log2_abundata_outliers_forPCAtools <- log2(abundata_outliers_reordered_forPCAtools)


# unite pre_post column with intervention column to create pre_intervention column
metadata_outliers_forPCAtools <- metadata_outliers_forPCAtools %>%
  unite(col = "pre_post_intervention",
        c("pre_post","Intervention"),
        sep = "_",
        remove = FALSE)
```


### PCA
```{r, fig.width=7, fig.height=7.5}
# pca
p_outliers <- PCAtools::pca(log2_abundata_outliers_forPCAtools, 
         metadata = metadata_outliers_forPCAtools, 
         scale = FALSE # using scaled data already (log2 transformed)
         
)

# plot

PCAtools::biplot(p_outliers,
                 showLoadings = TRUE, # show variables that contribute the most to PCs
                 lab = NULL,
                 title = )
```


### More PCAs

#### Pre vs post both

##### PC1vPC2

Confirm outliers outside of ellipses (technique: hotelling's t^2)
```{r, fig.width=8.5, fig.height=6.5}
  biplot(p_outliers,
          lab = paste0(metadata_outliers_forPCAtools$Subject),
          colby = 'pre_post_intervention',
          colkey = c("pre_Yellow" = "yellow",
                     "post_Yellow" = "yellow4",
                     "pre_Red" = "red",
                     "post_Red" = "red4"),
         # ellipse config
         ellipse = TRUE,
         ellipseType = 't',
         ellipseLevel = 0.95,
         ellipseFill = TRUE,
         ellipseAlpha = 0.2,
         ellipseLineSize = 1.0,
         xlim = c(-100,150), ylim = c(-80, 80),
         hline = 0, vline = 0,
         legendPosition = 'right',
         title = "PCA Scores Plot with 95% Confidence Interval",
         subtitle = "Log2 transformed data, HILIC (-), with outliers, no QCs")
```



```{r, fig.width=8.5, fig.height=6.5}
(PCA.colby.prevspost_outliers <- biplot(p_outliers,
                               lab = NULL,
                           # or lab = paste0(metadata_forPCAtools$Subject),
                           colby = 'pre_post_intervention',
                           colkey = c("pre_Yellow" = "yellow",
                                      "post_Yellow" = "yellow4",
                                      "pre_Red" = "red",
                                      "post_Red" = "red4"),
                           hline = 0, vline = 0,
                           legendPosition = 'right',
                           title = "PCA Scores Plot with Loadings",
                           subtitle = "Log2 transformed data, HILIC (-), without QCs but with outliers",
                           showLoadings = TRUE))



```


## No outliers

### Data wrangling
```{r}
# create rel abund df suitable for PCAtools package

imp_clust_omicsdata_forPCAtools <- as.data.frame(t(imp_clust)) # transpose df 

names(imp_clust_omicsdata_forPCAtools) <- imp_clust_omicsdata_forPCAtools[1,] # make sample IDs column names

imp_clust_omicsdata_forPCAtools <- imp_clust_omicsdata_forPCAtools[-1,] # remove sample ID row

imp_clust_omicsdata_forPCAtools <- imp_clust_omicsdata_forPCAtools %>%
 dplyr::select(!contains("QC")) # remove QC observations


# create metadata df suitable for PCAtools pckg

metadata_forPCAtools <- metadata %>%
  column_to_rownames(var = "sample_ID") # change sample ID column to rownames

# create a vector so that col names in abundance df matches metadata df
order_forPCAtools <- match(rownames(metadata_forPCAtools), colnames(imp_clust_omicsdata_forPCAtools))

# reorder col names in abundance df so that it matches metadata
abundata_reordered_forPCAtools <- imp_clust_omicsdata_forPCAtools[ ,order_forPCAtools] 

# change abundance df to numeric
abundata_reordered_forPCAtools <- abundata_reordered_forPCAtools %>%
  mutate_all(as.numeric)

# Log transform
log2_abundata_forPCAtools <- log2(abundata_reordered_forPCAtools)

# remove 6106 subj from both df
log2_abundata_forPCAtools <- log2_abundata_forPCAtools %>%
 dplyr::select(!contains("6106"))

metadata_forPCAtools <- metadata_forPCAtools %>%
  filter(Subject != 6106)

# unite pre_post column with intervention column to create pre_intervention column
metadata_forPCAtools <- metadata_forPCAtools %>%
  unite(col = "pre_post_intervention",
        c("pre_post","Intervention"),
        sep = "_",
        remove = FALSE)

```

### PCA
```{r, fig.width=7, fig.height=7.5}
# pca
p <- pca(log2_abundata_forPCAtools, 
         metadata = metadata_forPCAtools, 
         scale = FALSE # using scaled data already (log2 transformed)
         
)

# plot

PCAtools::biplot(p,
                 showLoadings = TRUE, # show variables that contribute the most to PCs
                 lab = NULL,
                 title = )
```

### Screeplot analysis

Horn's parallel analysis
```{r, warning=FALSE}
horn <- parallelPCA(log2_abundata_forPCAtools)

horn$n
```

Elbow method
```{r}
elbow <- findElbowPoint(p$variance)

elbow
```

```{r, fig.width=7, fig.height=7.5}

  screeplot(p,
    components = getComponents(p, 1:20),
    vline = c(horn$n, elbow)) +
  geom_label(aes(x = horn$n + 1, y = 50,
      label = 'Horn\'s', vjust = -1, size = 8)) +
    geom_label(aes(x = elbow + 1, y = 50,
      label = 'Elbow method', vjust = -3, size = 8))
```

How many PCs do we need to capture at least 80% variance?
```{r}
which(cumsum(p$variance) > 80)[1]
```

### More PCAs

#### Pre vs post both

##### PC1vPC2


```{r, fig.width=10, fig.height=10}
biplot(p,
       lab = paste0(metadata_forPCAtools$Subject),
       colby = 'pre_post_intervention',
       colkey = c("pre_Yellow" = "yellow",
                  "post_Yellow" = "yellow4",
                  "pre_Red" = "red",
                  "post_Red" = "red4"),
       hline = 0, vline = 0,
       # ellipse config
       ellipse = TRUE,
       ellipseType = 't', # assumes multivariate t-distribution
       ellipseLevel = 0.95,
       ellipseFill = TRUE,
       ellipseAlpha = 0.2,
       ellipseLineSize = 0,
       xlim = c(-80,80), ylim = c(-40,40),
       legendPosition = 'right',
       title = "PCA Scores Plot",
       subtitle = "Log2 transformed data, HILIC (-), outliers removed, no QCs \n95% confidence level ellipses")

```


```{r, fig.width=10, fig.height=8.5}
(PCA.colby.prevspost <- biplot(p,
                               lab = NULL,
                           colby = 'pre_post_intervention',
                           colkey = c("pre_Yellow" = "yellow",
                                      "post_Yellow" = "yellow4",
                                      "pre_Red" = "red",
                                      "post_Red" = "red4"),
                           hline = 0, vline = 0,
         legendPosition = 'right',
         title = "PCA Scores Plot",
         subtitle = "Log2 transformed data, HILIC (-), outliers removed, no QCs \n95% confidence level ellipses",
         showLoadings = TRUE))
```


##### Pairs plot
```{r, fig.width=10, fig.height=10}
(PCA_pairsplot.colby.prevspost <-
  pairsplot(p,
    components = getComponents(p, c(1:10)),
    triangle = TRUE, trianglelabSize = 12,
    hline = 0, vline = 0,
    pointSize = 0.4,
    gridlines.major = FALSE, gridlines.minor = FALSE,
    colby = 'pre_post_intervention', 
    colkey = c("pre_Yellow" = "yellow",
               "post_Yellow" = "yellow4",
               "pre_Red" = "pink",
               "post_Red" = "red4"),
    title = 'Pairs plot', plotaxes = FALSE,
    margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm')))

```

### Sex

#### PC1vPC2
```{r, fig.width=7, fig.height=7.5}
(PCA.colby.Sex <- biplot(p,
                           lab = paste0(metadata_forPCAtools$Subject),
                          colby = 'Sex',
                          colkey = c("M" = "red",
                                     "F" = "purple"),
                          hline = 0, vline = 0,
                          legendPosition = 'right' +
                            geom_point(aes(text = metadata_forPCAtools$Subject))))

ggplotly(PCA.colby.Sex,
         tooltip = "text") 

```

#### Pairsplot
```{r, fig.width=10, fig.height=10}
  pairsplot(p,
    components = getComponents(p, c(1:10)),
    triangle = TRUE, trianglelabSize = 12,
    hline = 0, vline = 0,
    pointSize = 0.4,
    gridlines.major = FALSE, gridlines.minor = FALSE,
    colby = 'Sex', 
    colkey = c("M" = "red",
               "F" = "purple"),
    title = 'Pairs plot', plotaxes = FALSE,
    margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm'))
```


### Overall pre v post

#### PC1vPC2
```{r, fig.width=7, fig.height=7.5}
(PCA.colby.overall.prevspost <- biplot(p,
                                       lab = paste0(metadata_forPCAtools$Subject),
                                       colby = 'pre_post',
                                       colkey = c("pre" = "orange",
                                                  "post" = "green3"),
                                       hline = 0, vline = 0,
                                       legendPosition = 'right' +
                                         geom_point(aes(text = metadata_forPCAtools$Subject))))

ggplotly(PCA.colby.overall.prevspost,
         tooltip = "text") 

```


```{r, fig.width=10, fig.height=10}
  pairsplot(p,
    components = getComponents(p, c(1:10)),
    triangle = TRUE, trianglelabSize = 12,
    hline = 0, vline = 0,
    pointSize = 0.4,
    gridlines.major = FALSE, gridlines.minor = FALSE,
    colby = 'pre_post', 
    colkey = c("pre" = "orange",
               "post" = "green3"),
    title = 'Pairs plot', plotaxes = FALSE,
    margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm'))
```


### Period

#### PC1vPC2
```{r, fig.width=7, fig.height=7.5}
(PCA.colby.period <- biplot(p,
                            lab = paste0(metadata_forPCAtools$Subject),
                            colby = 'Period',
                            hline = 0, vline = 0,
                            legendPosition = 'right' +
                              geom_point(aes(text = metadata_forPCAtools$Subject))))

ggplotly(PCA.colby.period,
         tooltip = "text") 

```

#### Pairsplot
```{r, fig.width=10, fig.height=10}
  pairsplot(p,
    components = getComponents(p, c(1:10)),
    triangle = TRUE, trianglelabSize = 12,
    hline = 0, vline = 0,
    pointSize = 0.4,
    gridlines.major = FALSE, gridlines.minor = FALSE,
    colby = 'Period',
    title = 'Pairs plot', plotaxes = FALSE,
    margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm'))
```



### Sequence

#### PC1vPC2
```{r, fig.width=7, fig.height=7.5}
(PCA.colby.sequence <- biplot(p,
                            lab = paste0(metadata_forPCAtools$Subject),
                            colby = 'sequence',
                            hline = 0, vline = 0,
                            legendPosition = 'right' +
                              geom_point(aes(text = metadata_forPCAtools$Subject))))

ggplotly(PCA.colby.sequence,
         tooltip = "text") 

```

#### Pairsplot
```{r, fig.width=10, fig.height=10}
  pairsplot(p,
    components = getComponents(p, c(1:10)),
    triangle = TRUE, trianglelabSize = 12,
    hline = 0, vline = 0,
    pointSize = 0.4,
    gridlines.major = FALSE, gridlines.minor = FALSE,
    colby = 'sequence',
    title = 'Pairs plot', plotaxes = FALSE,
    margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm'))
```





## Eigen corplots
This is a cool way to explore the correlations between the metadata and the PCs! I want to look at how the metavariables correlate with PCs that account for 80% variation in the dataset. 

Again: How many PCs do we need to capture at least 80% variance?
```{r}
which(cumsum(p$variance) > 80)[1]
```

```{r, fig.width=12, fig.height=7.5}

  eigencorplot(p,
    components = getComponents(p, 1:18), # get components that account for 80% variance
    metavars = colnames(metadata_forPCAtools),
    col = c('darkblue', 'blue2', 'gray', 'red2', 'darkred'),
    cexCorval = 0.7,
    colCorval = 'white',
    fontCorval = 2,
    posLab = 'bottomleft',
    rotLabX = 45,
    posColKey = 'top',
    cexLabColKey = 1.5,
    scale = TRUE,
    main = 'PC1-18 metadata correlations',
    colFrame = 'white',
    plotRsquared = FALSE)


```


```{r, fig.width=14, fig.height=7.5}
  eigencorplot(p,
    components = getComponents(p, 1:18),
    metavars = colnames(metadata_forPCAtools),
    col = c('white', 'cornsilk1', 'gold', 'forestgreen', 'darkgreen'),
    cexCorval = 1.2,
    fontCorval = 2,
    posLab = 'all',
    rotLabX = 45,
    scale = TRUE,
    main = bquote(Principal ~ component ~ Pearson ~ r^2 ~ metadata ~ correlates),
    plotRsquared = TRUE,
    corFUN = 'pearson',
    corUSE = 'pairwise.complete.obs',
    corMultipleTestCorrection = 'BH',
    signifSymbols = c('****', '***', '**', '*', ''),
    signifCutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 1))
```


I am most interested in PCs affected by pre_post_intervention, so I think it would be good to investigate the metabolites that contribute the most to these PCs.


# Multilevel PCA

This type of PCA accounts for the structure of paired data, allowing for a more accurate assessment of biological differences between treatment groups, not differences attributed to the natural variation between individuals.

See http://mixomics.org/methods/multilevel/ for more info.


```{r}
library(mixOmics)
```


```{r}

Data_forMPCA <- imp_metabind_clust_log2_noQCs %>%
  mutate_at("Subject", as.factor)
 

summary(as.factor(Data_forMPCA$Subject))

# make a vector for meta variables
(metavar <- Data_forMPCA[,c(1:11)] %>%
    colnames())
```

## Regular PCA
```{r}
mixOmicsPCA.result <- mixOmics::pca(Data_forMPCA[,!names(Data_forMPCA) %in% metavar],
                            scale = FALSE,
                            center = FALSE)

plotIndiv(mixOmicsPCA.result, 
          ind.names = Data_forMPCA$Subject, 
          group = Data_forMPCA$pre_post_intervention, 
          legend = TRUE, 
          legend.title = "Treatment", 
          title = 'Regular PCA, HILIC (-), Log2 transformed')

```


## Multilevel PCA

With all data
```{r}
multilevelPCA.result <- mixOmics::pca(Data_forMPCA[,-(c(1:11))], 
                            multilevel = Data_forMPCA$Subject,
                            scale = FALSE,
                            center = FALSE)

plotIndiv(multilevelPCA.result, 
          ind.names = Data_forMPCA$Subject, 
          group = Data_forMPCA$pre_post_intervention, 
          legend = TRUE, 
          legend.title = "Treatment", 
          title = 'Multilevel PCA, HILIC (-), Log2 transformed')

```

The subject that was an outlier is no longer an outlier in this multilevel PCA result showing that multilevel PCA accounts for interindividual variation.

### Loadings 
```{r, fig.width=12, fig.height=12}
plotLoadings(multilevelPCA.result, ndisplay = 50)
```

# Univariate analysis

## Wrangle data

```{r}
# use tidy data 
head(imp_metabind_clust_tidy_log2)

# remove QCs
df_for_stats <- imp_metabind_clust_tidy_log2 %>%
  filter(Intervention != "QC")

# check if QCs were removed
unique(df_for_stats$Intervention)
```

```{r}
# df without outlier 6106
df_for_stats_noOutlier <- df_for_stats %>%
  filter(Subject != "6106")

# check if outlier was removed
unique(df_for_stats_noOutlier$Subject)
```

```{r}
# turn off sci notation outputs
options(scipen = 999)
```


## Parametric tests

### Paired t tests

Here, I am comparing pre- to post-intervention for both yellow and tomato soy (Red) juice interventions. I also compare post-yellow to post-red intervention. I am using the log transformed values of rel abundance since parametric tests assume normality.

#### Ctrl
```{r}
# run paired t-tests for control intervention
ctrl_t.test_paired <- df_for_stats %>%
  filter(Intervention == "Yellow") %>%
 dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
ctrl_t.test_paired_sig <- ctrl_t.test_paired %>%
  filter(p <= 0.05)
tibble(ctrl_t.test_paired_sig)

# how many are significant?
nrow(ctrl_t.test_paired_sig)
```


#### Ctrl Without outlier
```{r}
# run paired t-tests for control intervention
ctrl_noOutlier_t.test_paired <- df_for_stats_noOutlier %>%
  filter(Intervention == "Yellow") %>%
 dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
ctrl_noOutlier_t.test_paired_sig <- ctrl_noOutlier_t.test_paired %>%
  filter(p <= 0.05)
tibble(ctrl_noOutlier_t.test_paired_sig)

# how many are significant?
nrow(ctrl_noOutlier_t.test_paired_sig)
```

##### Mummichog list
```{r}
yel_for_mummichog <- ctrl_noOutlier_t.test_paired %>%
  dplyr::select(mz_rt,
         p,
         statistic) %>%
  separate(col = mz_rt,
           into = c("m/z", "rt"),
           sep = "_") %>%
  rename("p-value" = "p") %>%
  rename("t-score" = "statistic")

write_csv(yel_for_mummichog,
          "yelcomp-mummichog-list-hilicneg.csv")

write_delim(yel_for_mummichog,
          "yelcomp-mummichog-list-hilicneg.txt")
```

#### Red
```{r}
# run paired t-tests for control intervention
red_t.test_paired <- df_for_stats %>%
  filter(Intervention == "Red") %>%
 dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
red_t.test_paired_sig <- red_t.test_paired %>%
  filter(p <= 0.05)
tibble(red_t.test_paired_sig)

# how many are significant?
nrow(red_t.test_paired_sig)
```


#### Red Without outlier
```{r}
# run paired t-tests for control intervention
red_noOutlier_t.test_paired <- df_for_stats_noOutlier %>%
  filter(Intervention == "Red") %>%
 dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
red_noOutlier_t.test_paired_sig <- red_noOutlier_t.test_paired %>%
  filter(p <= 0.05)
tibble(red_noOutlier_t.test_paired_sig)

# how many are significant?
nrow(red_noOutlier_t.test_paired_sig)
```


##### Mummichog export
```{r}
red_for_mummichog <- red_noOutlier_t.test_paired %>%
  dplyr::select(mz_rt,
         p,
         statistic) %>%
  separate(col = mz_rt,
           into = c("m/z", "rt"),
           sep = "_") %>%
  rename("p-value" = "p") %>%
  rename("t-score" = "statistic")

write_csv(red_for_mummichog,
          "redcomp-mummichog-list-hilicneg.csv")

write_delim(red_for_mummichog,
          "redcomp-mummichog-list-hilicneg.txt")

write_tsv(red_for_mummichog,
          "redcomp-mummichog-list-hilicneg.tsv")
```

#### Post-red vs post-yellow

```{r}
# run paired t-tests for post interventions
post_t.test_paired <- df_for_stats %>%
  filter(pre_post == "post") %>%
 dplyr::select(Subject, Intervention, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ Intervention, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
post_t.test_paired_sig <- post_t.test_paired %>%
  filter(p <= 0.05)
tibble(post_t.test_paired_sig)

# how many are significant?
nrow(post_t.test_paired_sig)
```

#### Post-red vs post-yellow Without Outlier

```{r}
# run paired t-tests for post interventions
post_noOutlier_t.test_paired <- df_for_stats %>%
  filter(pre_post == "post",
         Subject != "6106") %>%
 dplyr::select(Subject, Intervention, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ Intervention, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
post_noOutlier_t.test_paired_sig <- post_noOutlier_t.test_paired %>%
  filter(p <= 0.05)
tibble(post_noOutlier_t.test_paired_sig)

# how many are significant?
nrow(post_noOutlier_t.test_paired_sig)
```

##### Mummichog export

```{r}
postcomp_for_mummichog <- post_noOutlier_t.test_paired %>%
  dplyr::select(mz_rt,
         p,
         statistic) %>%
  separate(col = mz_rt,
           into = c("m.z", "r.t"),
           sep = "_") %>%
  rename("p.value" = "p") %>%
  rename("t.score" = "statistic")

write_csv(postcomp_for_mummichog,
          "post-comp-mummichog-list-hilicneg.csv")

write_tsv(postcomp_for_mummichog,
          "post-comp-mummichog-list-hilicneg.tsv")

```


```{r}
mz_intensities_for_mummichog_trt <- df_for_stats_noOutlier %>%
  filter(pre_post == "post") %>%
  dplyr::select(sample_ID,
                Intervention,
                mz_rt,
                rel_abund_log2) %>%
  mutate(mz_rt = str_replace(mz_rt, "_", "__")) %>%
  pivot_wider(names_from = mz_rt,
              values_from = rel_abund_log2)


write_csv(mz_intensities_for_mummichog_trt,
          "mz-intensities-mummichog-trt-list-hilicpos.csv")

```

#### Outlier comparison
Are there any significant features shared between tests with and without outlier?

```{r}
post_sig_outlier_comp <- list(post_noOutlier_t.test_paired_sig,
                              post_t.test_paired_sig) %>%
  reduce(inner_join, by = "mz_rt")

tibble(post_sig_outlier_comp)
nrow(post_sig_outlier_comp)

# return sig features present only in df with outlier, and not in df without outlier
tibble(anti_join(post_noOutlier_t.test_paired_sig,
          post_t.test_paired_sig,
          by = "mz_rt"))

# return sig features from df without outlier that are also present in df with outlier
kable(semi_join(post_noOutlier_t.test_paired_sig,
          post_t.test_paired_sig,
          by = "mz_rt"))
```

### Standard comparisons

Here, I want to only focus on the metabolites that I hypothesized to change. This way I can avoid multiple correction adjustments and see if I can capture any significant differences at different timepoints

#### Wrangle

```{r}
stds_df_for_stats_wide <- df_for_stats %>%
  dplyr::select(!rel_abund) %>%
  pivot_wider(names_from = mz_rt,
              values_from = rel_abund_log2) %>%
  dplyr::select(c(1:11),
                "145.0619_6.606", #glutamine
                "145.0982_8.275", #lysine
                "154.0623_7.684", #histidine
                "158.082_0.514", #isovaleroylglycine
                "164.0715_4.437", #phenylalanine
                "179.0559_5.977", #glucose
                "191.0196_0.526", #citric acid?
                "212.0031_3.829" #indoxyl sulfate? isomer? 
                )

# make tidy df
stds_df_forstats_tidy <- stds_df_for_stats_wide %>%
  pivot_longer(cols = 12:ncol(.),
               names_to = "mz_rt",
               values_to = "rel_abund_log2")
```


```{r}
# changing factor levels for pre_post_intervention
stds_df_forstats_tidy$pre_post_intervention <- factor(stds_df_forstats_tidy$pre_post_intervention,
                              levels = c("pre_Yellow", "post_Yellow", "pre_Red", "post_Red"))

levels(stds_df_forstats_tidy$pre_post_intervention)  
```


#### Boxplots
```{r}
stds_df_forstats_tidy %>% 
  ggplot(aes(x = pre_post_intervention, y = rel_abund_log2, fill = Intervention)) +
  geom_boxplot(outlier.shape = NA) +
  scale_fill_manual(values = c("Yellow" = "gold",
                                           "Red" = "tomato1")) +
  geom_line(aes(group = Subject), colour = "purple", linewidth = 0.2) +
  facet_wrap(vars(mz_rt), scales = "free_y") + 
  theme_bw() 
```

#### Control t-test
```{r}
# run paired t-tests for before vs. after control intervention
stds_ctrl_t.test_paired <- stds_df_forstats_tidy %>%
  filter(Intervention == "Yellow") %>%
  dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  filter(Subject != 6106) %>% # remove outliers
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE) %>% 
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
stds_ctrl_t.test_paired_sig <- stds_ctrl_t.test_paired %>%
  filter(p <= 0.05)
tibble(stds_ctrl_t.test_paired_sig)

# how many are significant?
nrow(stds_ctrl_t.test_paired_sig)
```

#### Red t-tests
```{r}
# run paired t-tests for before vs. after red intervention
stds_red_t.test_paired <- stds_df_forstats_tidy %>%
  filter(Intervention == "Red") %>%
  dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  filter(Subject != 6106) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE) %>% 
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
stds_red_t.test_paired_sig <- stds_red_t.test_paired %>%
  filter(p <= 0.05)
tibble(stds_red_t.test_paired_sig)

# how many are significant?
nrow(stds_red_t.test_paired_sig)
```

#### Intervention t-tests

```{r}
# run paired t-tests for post-red vs. post-control intervention
stds_post_t.test_paired <- stds_df_forstats_tidy %>%
  filter(pre_post == "post") %>%
  dplyr::select(Subject, pre_post_intervention, mz_rt, rel_abund_log2) %>%
  filter(Subject != 6106) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post_intervention, 
         paired = TRUE) %>% 
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
stds_post_t.test_paired_sig <- stds_post_t.test_paired %>%
  filter(p <= 0.05)
tibble(stds_post_t.test_paired_sig)

# how many are significant?
nrow(stds_post_t.test_paired_sig)
```


### Volcano plots

#### Post-intervention comparisons 

##### Wrangle (no outlier)
```{r}
# calculate mean rel abund (not log) by sample, and avg fold change (FC) diff by feature
red_v_yel_volcano_data_noOutlier <- df_for_stats %>%
  filter(pre_post == "post",
         Subject != 6106) %>% # remove outlier subj
  group_by(Intervention, mz_rt) %>%
  summarize(mean_rel_abund = mean(rel_abund)) %>%
  pivot_wider(names_from = Intervention, values_from = mean_rel_abund) %>%
  mutate(FC_postRed_div_postYellow = Red/Yellow) 

# bind back pval
red_v_yel_tobind_noOutlier <- post_noOutlier_t.test_paired %>%
  dplyr::select(p)

# calculate log2FC, and -log10p
red_v_yel_volcano_data_noOutlier <- 
  bind_cols(red_v_yel_volcano_data_noOutlier, red_v_yel_tobind_noOutlier) %>%
  mutate(log2_FC_postRed_div_postYellow = if_else(FC_postRed_div_postYellow > 0,
                                                  log2(FC_postRed_div_postYellow),
                                                  -(log2(abs(FC_postRed_div_postYellow)))), 
         neglog10p = -log10(p))


# create a df of features passing FC and pval cutoffs higher in post-Red
postRed_sig_red_v_yel_volcano_noOutlier <- red_v_yel_volcano_data_noOutlier %>%
  filter(p <= 0.05 & log2_FC_postRed_div_postYellow >= 0.6)

# create a df of features passing FC and pval cutoffs higher in post-control
postYellow_sig_red_v_yel_volcano_noOutlier <- red_v_yel_volcano_data_noOutlier %>%
  filter(p <= 0.05 & log2_FC_postRed_div_postYellow <= -0.6)  
```

##### Export sig features

Create feature lists with significant features along with their clusters
```{r}
#post-Red list
postRed_sig_intrvntn_comp_clusters <- left_join(postRed_sig_red_v_yel_volcano_noOutlier, cluster_features,
                                               by = "mz_rt")

write_csv(postRed_sig_intrvntn_comp_clusters,
          "Feature lists/postRed-sigfeatures-intervntn-comp.csv")

#post-Yellow list
postYellow_sig_intrvntn_comp_clusters <- left_join(postYellow_sig_red_v_yel_volcano_noOutlier, cluster_features,
                                               by = "mz_rt")

write_csv(postYellow_sig_intrvntn_comp_clusters,
          "Feature lists/postYellow-sigfeatures-intervntn-comp.csv")
```




##### Plot
```{r}
(red_v_yellow_volcano_noOutlier <- red_v_yel_volcano_data_noOutlier %>%
  ggplot(aes(x = log2_FC_postRed_div_postYellow, y = neglog10p, 
             text = glue("Mass_retention time: {mz_rt}
                         P-value: {p}
                         Fold change tomato/control: {round(FC_postRed_div_postYellow, 2)}"))) +
  geom_point(color = "grey") +
  geom_point(data = postRed_sig_intrvntn_comp_clusters, 
             aes(x = log2_FC_postRed_div_postYellow, y = neglog10p),
             color = "tomato") +
  geom_point(data = postYellow_sig_intrvntn_comp_clusters, 
             aes(x = log2_FC_postRed_div_postYellow, y = neglog10p),
             color = "yellow2") +
  geom_vline(xintercept = 0.6, linetype = "dashed", color = "grey") +
  geom_vline(xintercept = -0.6, linetype = "dashed", color = "grey") +
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "grey") +
  coord_cartesian(xlim = c(-5, 8)) +
  labs(title = "Volcano Plot of Features Different in People After Tomato-Soy and Control Juice Consumption",
       subtitle = "Red points are higher after tomato-soy juice consumption while yellow points are higher \nafter control tomato juice consumption. Subject 6106 removed",
       caption = "Vertical dashed lines represent a log2 fold change > 0.6 or < -0.6, and horizontal dashed line represents an FDR corrected \np-value of 0.05.",
       x = "Log2 Fold Change (TomatoSoy/Control)",
       y = "-Log10(P-value)") +
  theme_bw() +
  theme(plot.title = element_text(size = 12, hjust = 0),
        plot.caption = element_text(hjust = 0.5)))

(red_v_yellow_volcano_ggplotly_noOutlier <- ggplotly(red_v_yellow_volcano_noOutlier, tooltip = "text"))
```

Save plots
```{r, eval=FALSE}
# save volcano plot
ggsave(plot = red_v_yellow_volcano_noOutlier,
       filename = "plots and figures/volcano plots/red_v_yellow_volcano_noOutlier.svg")

# save interactive volcano plot
saveWidget(widget = red_v_yellow_volcano_ggplotly_noOutlier,
           file = "plots and figures/volcano plots/interactive_redvyellow_volcano_plot_noOutlier.html")
```



#### Red

##### Wrangle (no outlier)
```{r}
# calculate mean rel abund (not log) by sample, and avg fold change (FC) diff by feature
red_volcano_data_noOutlier <- df_for_stats %>%
  filter(Intervention == "Red",
         Subject != 6106) %>%
  group_by(pre_post, mz_rt) %>%
  summarize(mean_rel_abund = mean(rel_abund)) %>%
  pivot_wider(names_from = pre_post, values_from = mean_rel_abund) %>%
  mutate(FC_post_div_pre = post/pre) 

# bind back pval
red_tobind_noOutlier <- red_noOutlier_t.test_paired %>%
  dplyr::select(p)

# calculate log2FC, and -log10p
red_volcano_data_noOutlier <- 
  bind_cols(red_volcano_data_noOutlier, red_tobind_noOutlier) %>%
  mutate(log2_FC_post_div_pre = log2(FC_post_div_pre),
         neglog10p = -log10(p))


# create a df of features passing FC and pval cutoffs higher in post-intervention compared to pre
red_pre_v_post_volcano_noOutlier <- red_volcano_data_noOutlier %>%
  filter(p <= 0.05 & abs(log2_FC_post_div_pre) >= 0.6)

```

##### Export sig features

Create feature lists with significant features along with their clusters
```{r}
red_sig_prepost_comp_clusters <- left_join(red_pre_v_post_volcano_noOutlier, cluster_features,
                                               by = "mz_rt")

write_csv(red_sig_prepost_comp_clusters,
          "Feature lists/Red-sigfeatures-PrevsPost-noOutliers.csv")

```


##### Plot
```{r}
(red_volcano_noOutlier <- red_volcano_data_noOutlier %>%
  ggplot(aes(x = log2_FC_post_div_pre, y = neglog10p, 
             text = glue("Mass_retention time: {mz_rt}
                         P-value: {p}
                         Fold change post/pre: {round(FC_post_div_pre, 2)}"))) +
  geom_point(color = "grey") +
  geom_point(data = red_sig_prepost_comp_clusters, 
             aes(x = log2_FC_post_div_pre, y = neglog10p),
             color = "tomato") +
  geom_vline(xintercept = 0.6, linetype = "dashed", color = "grey") +
  geom_vline(xintercept = -0.6, linetype = "dashed", color = "grey") + 
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "grey") +
  coord_cartesian(xlim = c(-5, 6)) +
  labs(title = "Volcano Plot of Features Different in People After Tomato-Soy Juice Consumption",
       subtitle = "Red points are higher after tomato-soy juice consumption when compared to prior to consumption",
       caption = "Vertical dashed lines represent an abs(log2 fold change) > 0.6, and horizontal dashed line represents an FDR corrected \np-value of 0.05.",
       x = "Log2 Fold Change (Post/Pre)",
       y = "-Log10(P-value)") +
  theme_bw() +
  theme(plot.title = element_text(size = 12, hjust = 0),
        plot.caption = element_text(hjust = 0.5)))

(red_volcano_ggplotly_noOutlier <- ggplotly(red_volcano_noOutlier, tooltip = "text"))
```

Save plots
```{r, eval=FALSE}
# save volcano plot
ggsave(plot = red_volcano_noOutlier,
       filename = "plots and figures/volcano plots/red_volcano_noOutlier.svg")

# save interactive volcano plot
saveWidget(widget = red_volcano_ggplotly_noOutlier,
           file = "plots and figures/volcano plots/interactive_red_volcano_plot_noOutlier.html")
```

#### Yellow

##### Wrangle (no outlier)
```{r}
# calculate mean rel abund (not log) by sample, and avg fold change (FC) diff by feature
yel_volcano_data_noOutlier <- df_for_stats %>%
  filter(Intervention == "Yellow",
         Subject != 6106) %>%
  group_by(pre_post, mz_rt) %>%
  summarize(mean_rel_abund = mean(rel_abund)) %>%
  pivot_wider(names_from = pre_post, values_from = mean_rel_abund) %>%
  mutate(FC_post_div_pre = post/pre) 

# bind back pval
yel_tobind_noOutlier <- ctrl_noOutlier_t.test_paired %>%
  dplyr::select(p)

# calculate log2FC, and -log10p
yel_volcano_data_noOutlier <- 
  bind_cols(yel_volcano_data_noOutlier, yel_tobind_noOutlier) %>%
  mutate(log2_FC_post_div_pre = log2(FC_post_div_pre),
         neglog10p = -log10(p))


# create a df of features passing FC and pval cutoffs higher in post-intervention compared to pre
yel_pre_v_post_volcano_noOutlier <- yel_volcano_data_noOutlier %>%
  filter(p <= 0.05 & abs(log2_FC_post_div_pre) >= 0.6)

```

##### Export sig features

Create feature lists with significant features along with their clusters
```{r}
yel_sig_prepost_comp_clusters <- left_join(yel_pre_v_post_volcano_noOutlier, cluster_features,
                                               by = "mz_rt")

write_csv(yel_sig_prepost_comp_clusters,
          "Yellow-sigfeatures-PrevsPost-noOutliers.csv")

```

##### Plot
```{r}
(yel_volcano_noOutlier <- yel_volcano_data_noOutlier %>%
  ggplot(aes(x = log2_FC_post_div_pre, y = neglog10p, 
             text = glue("Mass_retention time: {mz_rt}
                         P-value: {p}
                         Fold change post/pre: {round(FC_post_div_pre, 2)}"))) +
  geom_point(color = "grey") +
  geom_point(data = yel_sig_prepost_comp_clusters, 
             aes(x = log2_FC_post_div_pre, y = neglog10p),
             color = "yellow2") +
  geom_vline(xintercept = 0.6, linetype = "dashed", color = "grey") +
  geom_vline(xintercept = -0.6, linetype = "dashed", color = "grey") +
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "grey") +
  coord_cartesian(xlim = c(-6, 6)) +
  labs(title = "Volcano Plot of Features Different in People After Control, Yellow Tomato Juice Consumption",
       subtitle = "Yellow points are higher after control juice consumption when compared to prior to consumption.\nSubject 6106 removed",
       caption = "Vertical dashed lines represent abs(log2 fold change) > 0.6, and horizontal dashed line represents an FDR corrected \np-value of 0.05.",
       x = "Log2 Fold Change (Post/Pre)",
       y = "-Log10(P-value)") +
  theme_bw() +
  theme(plot.title = element_text(size = 12, hjust = 0),
        plot.caption = element_text(hjust = 0.5)))

(yel_volcano_ggplotly_noOutlier <- ggplotly(yel_volcano_noOutlier, tooltip = "text"))
```

Save plots
```{r, eval=FALSE}
# save volcano plot
ggsave(plot = yel_volcano_noOutlier,
       filename = "plots and figures/volcano plots/yel_volcano_noOutlier.svg")

# save interactive volcano plot
saveWidget(widget = yel_volcano_ggplotly_noOutlier,
           file = "plots and figures/volcano plots/interactive_yel_volcano_plot_noOutlier.html")
```


## Joined lists
Here, I want to venn significant features before I begin to look more into them. I am interested in the following effects: tomato effect, lycopene and/or soy isoflavones effect.

### Tomato effect
1. Tomato effect: join a list that only keeps features that are both significant in pre vs. post-red and pre vs. post-yellow. Manually deleted the features that don't have the same directionality

```{r}
# keep only features present in both pre vs post red and pre vs post yellow
tomato_effect <- inner_join(red_sig_prepost_comp_clusters,
                            yel_sig_prepost_comp_clusters,
                            by = "mz_rt")
dim(tomato_effect)
```

Export venned list
```{r}
write_csv(tomato_effect,
          "Feature lists/sig-features-tomato-effect.csv")
```

#### Mummichog matches

```{r}
# read in hits from red 
red_mummichog_hits <- read_csv("../mummichog analysis/red-hilic-mixed mode results-integ/red-hilic-mummichog_matched_compound_all.csv") %>%
  mutate(Query.Mass = round(Query.Mass, digits = 4)) %>% # keep 4 decimal points for mass
  unite(mz_rt,
        c("Query.Mass", "Retention.Time"),
        sep = "_")

```


Mummichog makes a list of hits for all of the compounds, so we only need to do an inner join for one of the lists. The outcome would be the same for all of the lists used since I have to input my whole dataset (no cutoffs) into analysis. 

```{r}
mummichog_mass_matches_tomato <- inner_join(tomato_effect,
                                            red_mummichog_hits,
                                            by = "mz_rt")

length(unique(mummichog_mass_matches_tomato$mz_rt)) # how many?

tibble(unique(mummichog_mass_matches_tomato$mz_rt)) # which features have a hit with mummichog?

```




```{r}
# map KEGG IDs to compound names
tomato_KEGGmatches <- as.data.frame(cpdkegg2name(mummichog_mass_matches_tomato$Matched.Compound))

mummichog_mass_matches_tomato$NAME <- tomato_KEGGmatches$NAME

```



#### Boxplots


##### all sig tomato features

```{r}
# metabs with pval < 0.05 and fc >= 1.51
sigmetabs_tomato_effect <- tomato_effect$mz_rt 
```

```{r}
tomato_effect_df_for_stats_wide <- df_for_stats %>%
  dplyr::select(!rel_abund) %>%
  pivot_wider(names_from = mz_rt,
              values_from = rel_abund_log2) %>%
  dplyr::select(c(1:11),
                sigmetabs_tomato_effect)

# make tidy df
tomato_effect_df_for_stats_tidy <- tomato_effect_df_for_stats_wide %>%
  pivot_longer(cols = 12:ncol(.),
               names_to = "mz_rt",
               values_to = "rel_abund_log2")
```

```{r}
# changing factor levels for pre_post_intervention
tomato_effect_df_for_stats_tidy$pre_post_intervention <- factor(tomato_effect_df_for_stats_tidy$pre_post_intervention,
                              levels = c("pre_Yellow", "post_Yellow", "pre_Red", "post_Red"))

levels(tomato_effect_df_for_stats_tidy$pre_post_intervention)  
```

```{r, fig.height=15, fig.width=12}
tomato_effect_df_for_stats_tidy %>% 
  ggplot(aes(x = pre_post_intervention, y = rel_abund_log2, fill = Intervention)) +
  geom_boxplot(outlier.shape = NA) +
  scale_fill_manual(values = c("Yellow" = "gold",
                                           "Red" = "tomato1")) +
  geom_line(aes(group = Subject), fill = "brown", linewidth = 0.2) +
  facet_wrap(vars(mz_rt), scales = "free_y") + 
  theme_clean() 
```

##### dopamine sulfate

Looking at the mass associated with dopamine sulfate. There are 2 retention times, one of them is a significant feature for tomato effect. The other feature (same mass, diff RT) is the only one I collected MS/MS data for. So I am looking to see if the trends for both features are the same, and the likelihood that they are configurational isomers. 

```{r}
dopamineSO4H_df_for_stats_wide <- df_for_stats_noOutlier %>%
  dplyr::select(!rel_abund) %>%
  pivot_wider(names_from = mz_rt,
              values_from = rel_abund_log2) %>%
  dplyr::select(c(1:11),
                "232.0284_4.836",
                "232.0283_5.427")

# make tidy df
dopamineSO4H_df_forstats_tidy <- dopamineSO4H_df_for_stats_wide %>%
  pivot_longer(cols = 12:ncol(.),
               names_to = "mz_rt",
               values_to = "rel_abund_log2")
```


```{r}
# changing factor levels for pre_post_intervention
dopamineSO4H_df_forstats_tidy$pre_post_intervention <- factor(dopamineSO4H_df_forstats_tidy$pre_post_intervention,
                              levels = c("pre_Yellow", "post_Yellow", "pre_Red", "post_Red"))

levels(dopamineSO4H_df_forstats_tidy$pre_post_intervention)  
```

```{r}
dopamineSO4H_df_forstats_tidy %>% 
  ggplot(aes(x = pre_post_intervention, y = rel_abund_log2, fill = Intervention)) +
  geom_boxplot(outlier.shape = NA) +
  scale_fill_manual(values = c("Yellow" = "gold",
                                           "Red" = "tomato1")) +
  geom_line(aes(group = Subject), fill = "brown", linewidth = 0.2) +
  facet_wrap(vars(mz_rt), scales = "free_y") + 
  theme_clean() 
```

We do see a decrease for both features. I would need to confirm with targeted MS/MS.


### Lyc/soy effect
2. lycopene and/or soy isoflavones effect: join a list that only keeps features that are:
- significantly different between post-Red and post-Yellow
- and significant between pre- and post-Red. 

```{r}
# combine sig features from post-red vs post-yellow
sig_postintervention_noOutlier <- full_join(postRed_sig_intrvntn_comp_clusters,
                                               postYellow_sig_intrvntn_comp_clusters)
dim(sig_postintervention_noOutlier)

# select only sig features that are present when comparing pre-Red to post-Red
lyc_soy_effect <- inner_join(sig_postintervention_noOutlier,
                             red_sig_prepost_comp_clusters,
                             by = "mz_rt") 
dim(lyc_soy_effect)
```

Export venned list
```{r}
write_csv(lyc_soy_effect,
          "Feature lists/sig-features-lyc-soy-effect.csv")
```

#### Mummichog matches

Mummichog makes a list of hits for all of the compounds, so we only need to do an inner join for one of the lists. The outcome would be the same for all of the lists used since I have to input my whole dataset (no cutoffs) into analysis. 

```{r}
mummichog_mass_matches_lycsoy <- inner_join(lyc_soy_effect,
                                            red_mummichog_hits,
                                            by = "mz_rt")

length(unique(mummichog_mass_matches_lycsoy$mz_rt)) # how many?

tibble(unique(mummichog_mass_matches_lycsoy$mz_rt)) # which features have a hit with mummichog?

```




```{r}
# map KEGG IDs to compound names
lycsoy_KEGGmatches <- as.data.frame(cpdkegg2name(mummichog_mass_matches_lycsoy$Matched.Compound))

mummichog_mass_matches_lycsoy$NAME <- lycsoy_KEGGmatches$NAME

```



#### Boxplots


##### all sig tomato features

```{r}
# metabs with pval < 0.05 and fc >= 1.51
sigmetabs_lycsoy_effect <- lyc_soy_effect$mz_rt 
```

```{r}
lycsoy_effect_df_for_stats_wide <- df_for_stats %>%
  dplyr::select(!rel_abund) %>%
  pivot_wider(names_from = mz_rt,
              values_from = rel_abund_log2) %>%
  dplyr::select(c(1:11),
                sigmetabs_lycsoy_effect)

# make tidy df
lycsoy_effect_df_for_stats_tidy <- lycsoy_effect_df_for_stats_wide %>%
  pivot_longer(cols = 12:ncol(.),
               names_to = "mz_rt",
               values_to = "rel_abund_log2")
```

```{r}
# changing factor levels for pre_post_intervention
lycsoy_effect_df_for_stats_tidy$pre_post_intervention <- factor(lycsoy_effect_df_for_stats_tidy$pre_post_intervention,
                              levels = c("pre_Yellow", "post_Yellow", "pre_Red", "post_Red"))

levels(lycsoy_effect_df_for_stats_tidy$pre_post_intervention)  
```

```{r, fig.height=40, fig.width=30}
lycsoy_effect_df_for_stats_tidy %>% 
  ggplot(aes(x = pre_post_intervention, y = rel_abund_log2, fill = Intervention)) +
  geom_boxplot(outlier.shape = NA) +
  scale_fill_manual(values = c("Yellow" = "gold",
                                           "Red" = "tomato1")) +
  geom_line(aes(group = Subject), fill = "brown", linewidth = 0.2) +
  facet_wrap(vars(mz_rt), scales = "free_y") + 
  theme_clean() 
```



### Low carotenoid tomato effect
2. yellow tomato effect: use list that only keeps features that are both significant between post-Red and post-Yellow timepoints, and significant between pre- and post-Yellow. These features are NOT significant between pre-Yellow and post-Yellow.

```{r}
# sig features from post-red vs post-yellow
dim(sig_postintervention_noOutlier)

# select only sig features that are present when comparing pre-Yellow to post-Yellow
low_carot_tomato_effect <- inner_join(sig_postintervention_noOutlier,
                             yel_sig_prepost_comp_clusters,
                             by = "mz_rt") 
dim(low_carot_tomato_effect)
# remove features that are significant pre-Red vs post-Red comparison
low_carot_tomato_effect <- anti_join(low_carot_tomato_effect,
                            red_sig_prepost_comp_clusters,
                            by = "mz_rt")
dim(low_carot_tomato_effect) # how many features were removed?
```

Export venned list
```{r}
write_csv(low_carot_tomato_effect,
          "Feature lists/sig-features-low-carot-tomato-effect.csv")
```


### Mummichog masses
```{r}
mummichog_mass_matches_yellow_tomato <- inner_join(low_carot_tomato_effect,
                                            masses_mummichog,
                                            by = "mz_rt")

tibble(unique(mummichog_mass_matches_yellow_tomato$mz_rt)) # which features have a hit with mummichog?
length(unique(mummichog_mass_matches_yellow_tomato$mz_rt)) # how many?
```


#### Boxplots


##### all sig yellow tom features

```{r}
# metabs with pval < 0.05 and fc >= 1.51
sigmetabs_yellow_effect <- as.character(low_carot_tomato_effect$mz_rt)
```

```{r}
yellow_effect_df_for_stats_wide <- df_for_stats %>%
  dplyr::select(!rel_abund) %>%
  pivot_wider(names_from = mz_rt,
              values_from = rel_abund_log2) %>%
  dplyr::select(c(1:11),
                sigmetabs_yellow_effect)

# make tidy df
yellow_effect_df_for_stats_tidy <- yellow_effect_df_for_stats_wide %>%
  pivot_longer(cols = 12:ncol(.),
               names_to = "mz_rt",
               values_to = "rel_abund_log2")
```

```{r}
# changing factor levels for pre_post_intervention
yellow_effect_df_for_stats_tidy$pre_post_intervention <- factor(yellow_effect_df_for_stats_tidy$pre_post_intervention,
                              levels = c("pre_Yellow", "post_Yellow", "pre_Red", "post_Red"))

levels(yellow_effect_df_for_stats_tidy$pre_post_intervention)  
```

```{r, fig.height=25, fig.width=12}
yellow_effect_df_for_stats_tidy %>% 
  ggplot(aes(x = pre_post_intervention, y = rel_abund_log2, fill = Intervention)) +
  geom_boxplot(outlier.shape = NA) +
  scale_fill_manual(values = c("Yellow" = "gold",
                                           "Red" = "tomato1")) +
  geom_line(aes(group = Subject), fill = "brown", linewidth = 0.2) +
  facet_wrap(vars(mz_rt), scales = "free_y") + 
  theme_clean() 
```

# Immuno correlations

Here, I am going to look at correlations between the changes in each outcome from pre to post-red interventions. I can do this for post-intervention comparisons also.

## Wrangle (no outliers)

IL-5 was significantly decreased after tomato-soy intervention (only when comparing pre to post in Red). x25_cd19_cd3_b_cells and x26_cd27_ig_d_naive_b_cells were significantly increased from pre to post-Red, so let's see how these significant immuno outcomes correlate with metabolites found to be significant at p > 0.05 (and FC >= 2).

Import other outcomes (carotenoids and immunology data)
```{r}
# load data
carot_immunology_meta <- read_excel("CompiledData_Results_Meta.xlsx",
                         sheet = "metadata_corrected_withsequence")

# clean up variable names 
carot_immunology_meta <- clean_names(carot_immunology_meta)
```


```{r}
# convert variables that should be factors to factors
carot_immunology_meta <- carot_immunology_meta %>%
  filter(intervention != "Baseline") %>%
  mutate(across(.cols = c("patient_id", "period", 
                          "intervention", "intervention_week", 
                          "pre_post", "sex", "sequence"),
                .fns = as.factor))


# some stuff came in as characters but should be numeric
carot_immunology_meta <- carot_immunology_meta %>%
  mutate(across(.cols = c("il_2", "il_10", "il_13", "il_4"),
                .fns = as.numeric))



# changing factor levels for pre_post
carot_immunology_meta$pre_post <- factor(carot_immunology_meta$pre_post,
                              levels = c("pre", "post"))

levels(carot_immunology_meta$pre_post)        

# Calculate total_cis_lyc, total_lyc, and total_carotenoids
carot_immunology_meta <- carot_immunology_meta %>%
  mutate(total_cis_lyc = other_cis_lyc + x5_cis_lyc,
         total_lyc = all_trans_lyc + total_cis_lyc,
         total_carotenoids = lutein + zeaxanthin + b_cryptoxanthin + 
                             a_carotene + b_carotene + total_lyc)
```


```{r}
# go back to wide for stats df
df_for_stats_wide_noOutlier <- df_for_stats_noOutlier %>%
  dplyr::select(!rel_abund) %>%
  pivot_wider(names_from = mz_rt,
              values_from = rel_abund_log2)

# take outliers out of carot_immuno df 
carot_immunology_meta_noOutlier <- carot_immunology_meta %>%
  filter(patient_id != 6106)

# add immuno outcome columns to dataset
forcorr_metabslog2_immuno_noOutlier <- df_for_stats_wide_noOutlier %>%
  mutate(il_5 = carot_immunology_meta_noOutlier$il_5) %>%
  mutate(CD19pos_Bcells = carot_immunology_meta_noOutlier$x25_cd19_cd3_b_cells) %>%
  mutate(IgDpos_naiveBcells = carot_immunology_meta_noOutlier$x26_cd27_ig_d_naive_b_cells)
```


Subset df's into pre and post 
```{r}
# pre
forcorr_pre_metabslog2_immuno_noOutlier <- forcorr_metabslog2_immuno_noOutlier %>%
  dplyr::select(Subject, Intervention, pre_post, 12:1875) %>%
  filter(pre_post == "pre")

# post 
forcorr_post_metabslog2_immuno_noOutlier <- forcorr_metabslog2_immuno_noOutlier %>%
  dplyr::select(Subject, Intervention, pre_post, 12:1875) %>%
  filter(pre_post == "post")
```

Create df with differences calculated for each outcome
```{r}
# difference for calculated for each outcome
forcorr_diff_red_metabslog2_immuno_noOutlier <- forcorr_post_metabslog2_immuno_noOutlier[,4:1867] - forcorr_pre_metabslog2_immuno_noOutlier[,4:1867]


```

## Corr table
These are correlations based on significant metabolites with p value < 0.05 AND FC > 2

```{r}
# add subject and intervention back to df. Select only significant metabolites (pval > 0.05 and FC >=2)
forcorr_diff_red_metabslog2_immuno_noOutlier <- forcorr_diff_red_metabslog2_immuno_noOutlier %>%
  mutate(Subject = forcorr_post_metabslog2_immuno_noOutlier$Subject,
         Intervention = forcorr_post_metabslog2_immuno_noOutlier$Intervention) %>%
  filter(Intervention == "Red") %>%
  dplyr::select(Subject, Intervention, il_5, CD19pos_Bcells, IgDpos_naiveBcells, all_of(higher_postRed_noOutlier$mz_rt))

# correlation table
red_corr_results_metabs_immuno_diff_noOutlier <- forcorr_diff_red_metabslog2_immuno_noOutlier %>% 
  correlate() 

kable(red_corr_results_metabs_immuno_diff_noOutlier, format = "markdown", digits = 3)

# metabolites strongly correlated with immuno outcomes. R^2 >= to 0.5
red_sigcorr_metabsP05_FC2_immunodata <- red_corr_results_metabs_immuno_diff_noOutlier %>%
  dplyr::select(term, il_5, CD19pos_Bcells, IgDpos_naiveBcells) %>%
  filter(abs(red_corr_results_metabs_immuno_diff_noOutlier$il_5) >= 0.5 | abs(red_corr_results_metabs_immuno_diff_noOutlier$CD19pos_Bcells) >= 0.5 | abs(red_corr_results_metabs_immuno_diff_noOutlier$IgDpos_naiveBcells) >= 0.5)

kable(red_sigcorr_metabsP05_FC2_immunodata, digits = 3)

```


```{r, fig.height=12, fig.width=12}

library(ggcorrplot)

red_corr_noOutlier <- round(cor(forcorr_diff_red_metabslog2_immuno_noOutlier[,-c(1:2)]), 2)


red_corr_noOutlier[,c(1:3)] %>%
  ggcorrplot(lab = TRUE, outline.color = "white", ggtheme = ggplot2::theme_gray,
  colors = c("#6D9EC1", "white", "#E46726")) +
  theme(axis.text.x = element_text(angle = 45, size = 12),
        axis.text.y = element_text(size = 12)) +
  coord_flip()


```

```{r, fig.width=20, fig.height=18}
#
red_p.mat <- cor_pmat(forcorr_diff_red_metabslog2_immuno_noOutlier[,-c(1:2)])

red_corr_noOutlier[] %>%
  ggcorrplot(lab = TRUE, outline.color = "white", hc.order = TRUE, type = "lower", p.mat = red_p.mat, insig = "blank") +
  theme(axis.text.x = element_text(angle = 45, size = 12),
        axis.text.y = element_text(size = 12))

```

### Corr scatterplots

```{r, fig.width=12, fig.height=12}
forcorr_diff_red_metabslog2_immuno_noOutlier_tidy <- forcorr_diff_red_metabslog2_immuno_noOutlier %>%
  pivot_longer(cols = 6:ncol(.),
               names_to = "mz_rt",
               values_to = "rel_abund_log2")

forcorr_diff_red_metabslog2_immuno_noOutlier_tidy %>%
  ggplot(aes(x = 	il_5, y = rel_abund_log2, color = mz_rt)) +
  geom_smooth(method=lm, show.legend = FALSE) +
  geom_point(show.legend = FALSE) +
  theme_bw() +
  facet_wrap(vars(mz_rt), scales = "free")
```

```{r}
forcorr_diff_red_metabslog2_immuno_noOutlier_tidy %>%
  filter(mz_rt == "333.0076_2.172") %>%
  ggplot(aes(x = 	il_5, y = rel_abund_log2, color = mz_rt)) +
  geom_smooth(method=lm) +
  geom_point(show.legend = FALSE) +
  theme_clean() 
```


## Corr table 2
These are correlations based on significant metabolites with p value < 0.05 only.

```{r}
# difference for calculated for each outcome
forcorr2_diff_red_metabslog2_immuno_noOutlier <- forcorr_post_metabslog2_immuno_noOutlier[,4:1867] - forcorr_pre_metabslog2_immuno_noOutlier[,4:1867]

# add subject and intervention back to df. Select only significant metabolites (pval < 0.05)
forcorr2_diff_red_metabslog2_immuno_noOutlier <- forcorr2_diff_red_metabslog2_immuno_noOutlier %>%
  mutate(Subject = forcorr_post_metabslog2_immuno_noOutlier$Subject,
         Intervention = forcorr_post_metabslog2_immuno_noOutlier$Intervention) %>%
  filter(Intervention == "Red") %>%
  dplyr::select(Subject, Intervention, il_5, CD19pos_Bcells, IgDpos_naiveBcells, all_of(red_noOutlier_t.test_paired_sig$mz_rt))

# correlation table
red2_corr_results_metabs_immuno_diff_noOutlier <- forcorr2_diff_red_metabslog2_immuno_noOutlier %>% 
  correlate() 

kable(red2_corr_results_metabs_immuno_diff_noOutlier, format = "markdown", digits = 3)

# metabolites strongly correlated with immuno outcomes. R^2 >= to 0.5
red2_sigcorr_metabsP05_immunodata <- red2_corr_results_metabs_immuno_diff_noOutlier %>%
  dplyr::select(term, il_5, CD19pos_Bcells, IgDpos_naiveBcells) %>%
  filter(abs(red2_corr_results_metabs_immuno_diff_noOutlier$il_5) >= 0.5 | abs(red2_corr_results_metabs_immuno_diff_noOutlier$CD19pos_Bcells) >= 0.5 | abs(red2_corr_results_metabs_immuno_diff_noOutlier$IgDpos_naiveBcells) >= 0.5)

kable(red2_sigcorr_metabsP05_immunodata, digits = 3)

```

## Just IL-5
```{r}
# difference calc
forcorr_diff_red_metabslog2_IL5_noOutlier <- forcorr_post_metabslog2_immuno_noOutlier[,4:1867] - forcorr_pre_metabslog2_immuno_noOutlier[,4:1867]

# add subject and intervention back to df. Select only significant metabolites (pval > 0.05 and FC >=2)
forcorr_diff_red_metabslog2_IL5_noOutlier <- forcorr_diff_red_metabslog2_IL5_noOutlier %>%
  mutate(Subject = forcorr_post_metabslog2_immuno_noOutlier$Subject,
         Intervention = forcorr_post_metabslog2_immuno_noOutlier$Intervention) %>%
  filter(Intervention == "Red") %>%
  dplyr::select(Subject, Intervention, il_5, all_of(red_higher_post_noOutlier$mz_rt))

# correlation table
red_corr_results_metabs_IL5_diff_noOutlier <- forcorr_diff_red_metabslog2_IL5_noOutlier %>% 
  correlate() %>%
  rearrange() %>%
  shave()

kable(red_corr_results_metabs_IL5_diff_noOutlier, format = "markdown", digits = 3)

# metabolites strongly correlated with immuno outcomes. R^2 >= to 0.5
red_sigcorr_metabsP05_FC2_IL5data <- red_corr_results_metabs_IL5_diff_noOutlier %>%
  dplyr::select(term, il_5) %>%
  filter(abs(red_corr_results_metabs_IL5_diff_noOutlier$il_5) >= 0.5)

kable(red_sigcorr_metabsP05_FC2_IL5data, digits = 3)

```



```{r, fig.height=10, fig.width=5}

fashion(red_corr_results_metabs_IL5_diff_noOutlier)

corrr::rplot(red_corr_results_metabs_IL5_diff_noOutlier[,1:2],
             print_cor = TRUE,
             shape = 16) +
  theme_bw(base_size = 11) +
  theme(axis.text.x = element_text(angle = 0)) +
  coord_fixed(ratio = 1)



```


```{r, fig.width=16, fig.height=15, fig.asp=1}
red_corr_justIL5_noOutlier <- round(cor(forcorr_diff_red_metabslog2_IL5_noOutlier[,-c(1:2)]), 2)

red_corr_justIL5_noOutlier[] %>%
  ggcorrplot(lab = TRUE, 
             outline.color = "white", 
             hc.order = TRUE, 
             type = "lower", 
             ggtheme = ggthemes::theme_clean(base_size = 14, base_family = "sans"),
             colors = c("#6D9EC1", "white", "#E46726")) +
  theme(axis.text.x = element_text(angle = 90, size = 12))

```