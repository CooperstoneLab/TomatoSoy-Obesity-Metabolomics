---
title: "USDA Inflammation Metabolomics Data analysis"
subtitle: "Urine, C18(-) LCMS"
author: "Maria Sholola"
date: '2023-06-05'
output: 
  html_document:
    highlight: kate
    theme: yeti
    toc: true
    toc_float: true
    toc_depth: 5
    code_download: true
    fig_width: 7
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo=TRUE) 
```

# Load libraries
```{r, warning = FALSE, message = FALSE}
library(readxl) # for reading in excel files
library(janitor) # data checks and cleaning
library(glue) # for easy pasting
library(FactoMineR) # for PCA
library(factoextra) # for PCA
library(rstatix) # for stats
library(pheatmap) # for heatmaps
library(plotly) # for interactive plots
library(htmlwidgets) # for saving interactive plots
library(devtools)
library(notame) # used for feature clustering
library(doParallel)
library(igraph) # feature clustering
library(ggpubr) # visualizations
library(knitr) # clean table printing
library(rmarkdown)
library(mixOmics) # for multilevel PCAs
library(corrr)
library(ggcorrplot)
library(corrplot)
library(ggthemes)
library(ggtext)
library(ggpmisc) # scatter plot annotations
library(PCAtools)
library(pathview) # for functional analysis and KEGG annotation
library(tidyverse)
```

# Read in data
```{r}
# raw filtered metabolomics data in C18 (-)
omicsdata <- read_csv("Feature lists/C18Neg-Data-Filtered-in-R.csv")

# metadata
metadata <- read_excel("Metadata-urine-c18neg.xlsx")
```

# Wrangle data

```{r}
metadata <- metadata %>%
  rename("sample_ID" = Sample_ID)
```


```{r}
# rename "row ID"
omicsdata <- omicsdata %>%
  rename("row_ID" = `row ID`)

# how many features
nrow(omicsdata)

# are there any duplicates?
omicsdata %>% get_dupes(mz_rt)

```

```{r}
# remove dupes
omicsdata <- omicsdata %>% 
  distinct(mz_rt, .keep_all = TRUE)

# check again for dupes
omicsdata %>% get_dupes(mz_rt)

# how many features
nrow(omicsdata)
```


Sometimes a weird logical column (lgl) comes up in my data. Let's check if it's there

```{r}
colnames(omicsdata)
```


```{r}
# remove weird lgl column
omicsdata <- omicsdata %>%
  dplyr::select(!where(is.logical)) 

colnames(omicsdata)
```



```{r}
# create long df for omics df
omicsdata_tidy <- omicsdata %>%
  pivot_longer(cols = 3:ncol(.),
               names_to = "sample_ID",
               values_to = "peak_height")

# combine meta and omics dfs
meta_omics <- full_join(omicsdata_tidy,
                         metadata,
                         by = c("sample_ID" = "sample_ID"))

# separate mz and rt
meta_omics_sep <- meta_omics %>%
  separate(col = mz_rt,
           into = c("mz", "rt"),
           sep = "_") 

# convert columns to correct type
meta_omics_sep$mz <- as.numeric(meta_omics_sep$mz)
meta_omics_sep$rt <- as.numeric(meta_omics_sep$rt)
meta_omics_sep$Subject <- as.character(meta_omics_sep$Subject)
meta_omics_sep$Intervention <- as.character(meta_omics_sep$Intervention)

# rearrange column order
meta_omics_sep <- meta_omics_sep %>%
  dplyr::select(sample_ID, pre_post, Intervention, everything())

str(meta_omics_sep)


```


```{r}
# replace NA's in subject and intervention columns with QC
meta_omics_sep$Subject <- meta_omics_sep$Subject %>%
  replace_na("QC")

meta_omics_sep$Intervention <- meta_omics_sep$Intervention %>%
  replace_na("QC")
```


# Data summaries

## Number of masses detected
```{r}
nrow(omicsdata)
```


## Mass range for metabolites detected?

```{r}
range(meta_omics_sep$mz)
```

## RT range for metabolites detected?

```{r}
range(meta_omics_sep$rt)
```

## mass vs RT scatterplot
```{r}
# plot
(plot_mzvsrt <- meta_omics_sep %>%
  ggplot(aes(x = rt, y = mz)) +
  geom_point() +
  theme_minimal() +
  labs(x = "Retention time, min",
       y = "m/z, neutral",
       title = "mz across RT for all features"))
```

## Histogram for mass range
```{r}
meta_omics_sep %>%
  group_by(row_ID) %>%
  ggplot(aes(x = mz)) +
  geom_histogram(binwidth = 25) +
  theme_minimal() +
  labs(x = "Monoisotopic mass (amu)",
       y = "Number of features",
       title = "Distribution of features by mass")
```

## Histogram for RT

```{r}
meta_omics_sep %>%
  ggplot(aes(x = rt)) +
  geom_histogram(binwidth = 0.1) + # 6 second bins
  theme_minimal() +
  labs(x = "Retention time",
       y = "Number of features",
       title = "Distribution of features by retention time")
```


# NAs and imputing

## NAs

```{r}
# samples only (no QCs)
omicsdata_noQC <- omicsdata %>%
  dplyr::select(-contains("QC"))

#NAs in samples only?
NAbyRow_noQC <- rowSums(is.na(omicsdata_noQC[,-1]))

hist(NAbyRow_noQC,
     breaks = 48, # because there are 48 samples 
     xlab = "Number of missing values",
     ylab = "Number of metabolites",
     main = "How many missing values are there?")
```

Are there any missing values in QCs? There shouldn't be after data preprocessing/filtering
```{r}
omicsdata_QC <- omicsdata %>%
  dplyr::select(starts_with("P")) 

NAbyRow_QC <- colSums(is.na(omicsdata_QC))
# lets confirm that there are no missing values from my QCs
sum(NAbyRow_QC) # no
```


```{r}
# calculate how many NAs there are per feature in whole data set
contains_NAs <- meta_omics %>%
  group_by(mz_rt) %>%
  count(is.na(peak_height)) %>%
  filter(`is.na(peak_height)` == TRUE)
kable(contains_NAs)
```


## Remove NAs


## Data imputation
```{r}
# impute any missing values by replacing them with 1/2 of the lowest peak height value of a feature (i.e. in a row).
imputed_omicsdata <- omicsdata

imputed_omicsdata[] <- lapply(imputed_omicsdata, 
                              function(x) ifelse(is.na(x),
                                                 min(x, na.rm = TRUE)/2, x))

dim(imputed_omicsdata)
```

Are there any NAs?
```{r}
imputed_omicsdata %>%
  is.na() %>%
  sum()

# imputations worked
```


# Create new imputed tidy datasets
```{r}
# create long df for imputed omics df
imputed_omicsdata_tidy <- imputed_omicsdata %>%
  pivot_longer(cols = 3:ncol(.),
               names_to = "sample_ID",
               values_to = "peak_height")

# combine meta and imputed omics dfs
imp_meta_omics <- full_join(imputed_omicsdata_tidy,
                         metadata,
                         by = c("sample_ID" = "sample_ID"))

# separate mz and rt
imp_meta_omics_sep <- imp_meta_omics %>%
  separate(col = mz_rt,
           into = c("mz", "rt"),
           sep = "_") 

# convert columns to correct type
imp_meta_omics_sep$mz <- as.numeric(imp_meta_omics_sep$mz)
imp_meta_omics_sep$rt <- as.numeric(imp_meta_omics_sep$rt)
imp_meta_omics_sep$Subject <- as.character(imp_meta_omics_sep$Subject)
imp_meta_omics_sep$Intervention <- as.character(imp_meta_omics_sep$Intervention)
```


# Notame feature reduction
vignette for reference
```{r}
#browseVignettes("notame")
```

Let's look at what masses come up at each RT again

```{r}
# rt vs mz plot
imp_meta_omics_sep %>%
  ggplot(aes(x = rt, y = mz)) +
  geom_point() +
  theme_minimal() +
  labs(x = "RT (min)",
       y = "mz")
```
There are several points that are at the same RT, meaning they could be coming from the same compound. We'll run notame clustering to collapse features coming from one mass into one feature.

## Data restructuring for notame
```{r}
# create features list from imputed data set to only include unique feature ID's (mz_rt), mz and RT
features <- imp_meta_omics_sep %>%
  cbind(imp_meta_omics$mz_rt) %>%
  rename("mz_rt" = "imp_meta_omics$mz_rt") %>%
  dplyr::select(c(mz_rt, mz, rt)) %>%
  distinct() # remove the duplicate rows

# create a second data frame which is just imp_meta_omics restructured to another wide format
data_notame <- data.frame(imputed_omicsdata %>%
                            dplyr::select(-row_ID) %>%
                            t())

data_notame <- data_notame %>%
  tibble::rownames_to_column() %>% # change samples from rownames to its own column
  row_to_names(row_number = 1) # change the feature IDs (mz_rt) from first row obs into column names


```

Check structures
```{r}
# check if mz and rt are numeric
str(features)
```

```{r}
# check if results are numeric
head(data_notame)

# change to results to numeric
data_notame <- data_notame %>%
  mutate_at(-1, as.numeric)

head(data_notame)
```


## Find connections
```{r}
connection <- find_connections(data = data_notame,
                               features = features,
                               corr_thresh = 0.9,
                               rt_window = 1/60,
                               name_col = "mz_rt",
                               mz_col = "mz",
                               rt_col = "rt")

head(connection)
```

## Clustering
```{r}
clusters <- find_clusters(connections = connection, d_thresh = 0.8)
```

```{r}
# assign a cluster ID to all features. Clusters are named after feature with highest median peak height
features_clustered <- assign_cluster_id(data_notame, clusters, features, name_col = "mz_rt")

# lets see how many features are removed when we only keep one feature per cluster
pulled <- pull_clusters(data_notame, features_clustered, name_col = "mz_rt")
cluster_data <- pulled$cdata
cluster_features <- pulled$cfeatures

# how much did we trim our data down by?
nrow(omicsdata) - nrow(cluster_features)

```


```{r}
# export clustered feature list
write_csv(cluster_features,
          "Feature lists/c18neg-clustered-features.csv")

```


## Reduce dataset based on clustering
 
```{r}
# transpose the full dataset back to wide so that it is more similar to the notame dataset
imp_meta_omics_wide <- imp_meta_omics %>%
  dplyr::select(-"row_ID") %>%
  pivot_wider(names_from = mz_rt,
              values_from = peak_height)

# list of reduced features
clusternames <- cluster_features$mz_rt

# select only the features are in the reduced list
imp_clust <- imp_meta_omics_wide[,c(names(imp_meta_omics_wide) %in% clusternames)]

# bind back sample names
imp_clust <- cbind(imp_meta_omics_wide[1], imp_clust)

tibble(imp_clust)

```

## New mz vs rt plot

Let's see how our clustered data looks now compared to the original

```{r}
# plot new rt vs mz scatterplot post-clustering
(plot_mzvsrt_postcluster <- cluster_features %>%
  ggplot(aes(x = rt,
             y = mz)) +
  geom_point() +
  theme_minimal() +
  labs(x = "Retention time, min",
       y = "m/z, neutral",
       title = "mz across RT for all features after clustering"))


```


```{r, fig.height=10, fig.asp=1}
# plot both scatterplots to compare with and without notame clustering
(scatterplots <- ggarrange(plot_mzvsrt, 
                           plot_mzvsrt_postcluster, 
                           nrow = 2))
```

There are still some features that line up, but the clustered data looks much better.

# Wrangle new data

```{r}
# bind back new clustered data with metadata
imp_metabind_clust <- right_join(metadata, 
                                 imp_clust,
                                 by = "sample_ID")
```

# Visualize untransformed data

## More wrangling
```{r}
# change meta data columns to character so that I can change NAs from QCs to "QC"
imp_metabind_clust <- imp_metabind_clust %>%
  mutate_at(c("Subject",
              "Period",
              "Intervention",
              "pre_post",
              "sequence",
              "Intervention_week",
              "Sex",
              "Age",
              "BMI"),
            as.character) 

# replace NAs in metadata columns for QCs
imp_metabind_clust[is.na(imp_metabind_clust)] <- "QC"

# unite pre_post column with intervention column to create pre_intervention column
imp_metabind_clust <- imp_metabind_clust %>%
  unite(col = "pre_post_intervention",
        c("pre_post","Intervention"),
        sep = "_",
        remove = FALSE)

# long df
imp_metabind_clust_tidy <- imp_metabind_clust %>%
  pivot_longer(cols = 12:ncol(.),
               names_to = "mz_rt",
               values_to = "rel_abund")

# structure check
str(imp_metabind_clust_tidy)
```


## Boxplot
```{r}
imp_metabind_clust_tidy %>%
  ggplot(aes(x = sample_ID, y = rel_abund, color = Intervention)) +
  geom_boxplot(alpha = 0.6) +
  scale_color_manual(values = c("light grey", "tomato1", "gold")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "LC-MS (-) Feature Abundances by Sample",
       subtitle = "Unscaled data",
       y = "Relative abundance")
```

Will need to log transform in order to normalize and actually see the data

# Log2 transform
```{r}
imp_metabind_clust_tidy_log2 <- imp_metabind_clust_tidy %>%
  mutate(rel_abund_log2 = log2(rel_abund))
```

## Boxplot
```{r}
(bp_data_quality <- imp_metabind_clust_tidy_log2 %>%
   mutate(Sample = if_else(Intervention %in% c("Yellow", "Red"), "Sample", "QC")) %>%
  ggplot(aes(x = sample_ID, y = rel_abund_log2, fill = Sample))) +
  geom_boxplot(alpha = 0.6) +
  scale_fill_manual(values = c("light gray", "deepskyblue2")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "C18 (-) Feature Abundances by Sample",
       subtitle = "Log2 transformed data",
       y = "Relative abundance")
```

Much better! QCs look good.


# Load Feature ID Key
Here, I'm inserting a key that would indicate identified features above level 2 ID.

```{r}
key_omics <- read_xlsx("../annotated-features-table.xlsx",
                 sheet = "Features") %>%
  clean_names() %>%
  filter(lc_mode_c18_hilic == "C18") %>% # c18 mode
  filter(esi_mode == "-") %>% # ESI -
  dplyr::select(mz_rt, id, metabolite_class, parent_compound) # select relevant columns

# add key columns (left_join to only keep all observations present in full feature table)
anno_imp_metabind_clust_tidy_log2 <- left_join(imp_metabind_clust_tidy_log2, key_omics, by = "mz_rt") %>%
  # replace NAs in feature ID columns to un-annotated feature id's (mz_rt)
  mutate(Feature_ID = coalesce(id, mz_rt))
```

# PCAs

## With QCS

### Wrangle

```{r}
# go back to wide data
anno_imp_metabind_clust_log2 <- anno_imp_metabind_clust_tidy_log2 %>%
  dplyr::select(c(1:11),
                Feature_ID, rel_abund_log2) %>%
  pivot_wider(names_from = Feature_ID,
              values_from = rel_abund_log2)
```


```{r}
PCA.imp_metabind_clust_log2 <- PCA(anno_imp_metabind_clust_log2,  # wide data
                                   quali.sup = 1:11, # remove qualitative variables
                                   graph = FALSE, # don't graph
                                   scale.unit = FALSE) # don't scale, already transformed data

# PCA summary
kable(summary(PCA.imp_metabind_clust_log2))
```

```{r}
# pull PC coordinates into df
PC_coord_QC_log2 <- as.data.frame(PCA.imp_metabind_clust_log2$ind$coord)

# bind back metadata from cols 1-10
PC_coord_QC_log2 <- bind_cols(anno_imp_metabind_clust_log2[,1:11], PC_coord_QC_log2)

# grab some variance explained
importance_QC <- PCA.imp_metabind_clust_log2$eig

# set variance explained with PC1, round to 2 digits
PC1_withQC <- round(importance_QC[1,2], 2)

# set variance explained with PC2, round to 2 digits
PC2_withQC <- round(importance_QC[2,2], 2)
```

### Plots
Using FactoExtra package
```{r}
# scree plot
fviz_eig(PCA.imp_metabind_clust_log2)

# get eigenvalues
kable(get_eig(PCA.imp_metabind_clust_log2))
```

```{r}
# scores plot
fviz_pca_ind(PCA.imp_metabind_clust_log2)
```


### Manual scores plot

```{r}
# manual scores plot
(PCA_withQCs <- PC_coord_QC_log2 %>%
  ggplot(aes(x = Dim.1, y = Dim.2,
             fill = factor(Intervention, levels = c("Yellow", "Red", "QC")))) +
  geom_point(shape = 21, alpha = 0.8) +
  scale_fill_manual(values = c("gold", "tomato1", "light grey")) +
  scale_color_manual(values = "black") +  
  theme_minimal() +
  coord_fixed(PC2_withQC/PC1_withQC) +
  labs(x = glue::glue("PC1: {PC1_withQC}%"),
       y = glue::glue("PC2: {PC2_withQC}%"),
       fill = "Group",
       title = "Principal Components Analysis Scores Plot",
       subtitle = "Log2 transformed data"))
```

There seems to be outliers here. We'll keep investigating. Let's see how the data looks without the QCs.

## Without QCs

### Wrangle 

```{r}
anno_imp_metabind_clust_log2_noQCs <- anno_imp_metabind_clust_log2 %>%
  filter(Intervention != "QC")

PCA.imp_metabind_clust_log2_noQCs <- PCA(anno_imp_metabind_clust_log2_noQCs, # wide data
                               quali.sup=1:11, # remove qualitative variables
                               graph=FALSE, # don't graph
                               scale.unit=FALSE) # don't scale, we already did this

# look at summary
kable(summary(PCA.imp_metabind_clust_log2_noQCs))
```

```{r}
# pull PC coordinates into df
PC_coord_noQCs_log2 <- as.data.frame(PCA.imp_metabind_clust_log2_noQCs$ind$coord)

# bind back metadata from cols 1-10
PC_coord_noQCs_log2 <- bind_cols(anno_imp_metabind_clust_log2_noQCs[,1:11], PC_coord_noQCs_log2)

# grab some variance explained
importance_noQC <- PCA.imp_metabind_clust_log2_noQCs$eig

# set variance explained with PC1, round to 2 digits
PC1_noQC <- round(importance_noQC[1,2], 2)

# set variance explained with PC2, round to 2 digits
PC2_noQC <- round(importance_noQC[2,2], 2)
```

### Plots
Using FactoExtra

```{r}
# scree plot
fviz_eig(PCA.imp_metabind_clust_log2_noQCs)
```

```{r}
# scores plot
fviz_pca_ind(PCA.imp_metabind_clust_log2_noQCs)
```




### Manual scores plot

```{r}
(PCA_withoutQCs <- PC_coord_noQCs_log2 %>%
  ggplot(aes(x = Dim.1, 
             y = Dim.2,
             fill = Intervention,
             text = sample_ID)) +
    geom_point(shape = 21, alpha = 0.8) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha=0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha=0.5) +
    scale_fill_manual(values = c("gold", "tomato1")) +
    scale_color_manual(values = "black") +  
    theme_minimal() +
    coord_fixed(PC2_noQC/PC1_noQC) +
    labs(x = glue::glue("PC1: {PC1_noQC}%"),
         y = glue::glue("PC2: {PC2_noQC}%"),
         fill = "Intervention",
         title = "Principal Components Analysis Scores Plot",
         subtitle = "Log2 transformed data, without QCs"))
ggplotly(PCA_withoutQCs, tooltip = "text")
```

Interactive plot shows us that all of those visual outliers are subject 6106. Let's see what the data looks like when we remove this outlier.

Let's look at the top 100 features that are driving separation between 6106 and the rest of the subjects.
```{r}
# plot top 100 features that have at least a 95% cos2 (correlation)
fviz_pca_var(PCA.imp_metabind_clust_log2_noQCs, select.var = list(contrib = 100, cos2 = 0.90 ))

# table of values                    
(contrib_vars_6106 <- fviz_pca_var(PCA.imp_metabind_clust_log2_noQCs, select.var = list(contrib = 100, cos2 = 0.90 ), graph = F )$data)

```


What if we remove these features?

To try and handle outliers, I came up with filtering out metabolites that are only present in one person. Omitting for now.

```{r}
# remove features assoc with subj 6106
# omit_features <- imp_metabind_clust_tidy_log2 %>%
#   filter(mz_rt %in% contrib_vars_6106$name)
```



## Removal of visual outlier

### With QCs

#### Wrangle

```{r}
# remove subjects
imp_no6106_log2 <- anno_imp_metabind_clust_log2 %>%
  filter(Subject != 6106)

PCA.imp_no6106_log2 <- PCA(imp_no6106_log2,  # wide data
                                   quali.sup = 1:11, # remove qualitative variables
                                   graph = FALSE, # don't graph
                                   scale.unit = FALSE) # don't scale, already transformed data

# PCA summary
kable(summary(PCA.imp_no6106_log2))
```

```{r}
# pull PC coordinates into df
PC_no6106_QC_log2 <- as.data.frame(PCA.imp_no6106_log2$ind$coord)

# bind back metadata from cols 1-11
PC_no6106_QC_log2 <- bind_cols(imp_no6106_log2[,1:11], PC_no6106_QC_log2)

# grab some variance explained
importance_no6106_QC <- PCA.imp_no6106_log2$eig

# set variance explained with PC1, round to 2 digits
PC1_no6106_withQC <- round(importance_no6106_QC[1,2], 2)

# set variance explained with PC2, round to 2 digits
PC2_no6106_withQC <- round(importance_no6106_QC[2,2], 2)
```

#### Plots
Using FactoExtra package
```{r}
# scree plot
fviz_eig(PCA.imp_no6106_log2)
```

```{r}
# scores plot
fviz_pca_ind(PCA.imp_no6106_log2)
```


#### Manual scores plot

```{r}
# manual scores plot
(PCA_no6106_withQCs <- PC_no6106_QC_log2 %>%
  ggplot(aes(x = Dim.1, y = Dim.2,
             fill = factor(Intervention, levels = c("Yellow", "Red", "QC")))) +
  geom_point(shape = 21, alpha = 0.8) +
  scale_fill_manual(values = c("gold", "tomato1", "light grey")) +
  scale_color_manual(values = "black") +  
  theme_minimal() +
  coord_fixed(PC2_no6106_withQC/PC1_no6106_withQC) +
  labs(x = glue::glue("PC1: {PC1_no6106_withQC}%"),
       y = glue::glue("PC2: {PC2_no6106_withQC}%"),
       fill = "Group",
       title = "Principal Components Analysis Scores Plot"))
```


Because of subject 6106, the pooled QC sample points are quite far from samples. 

### Without QCs

#### Wrangle
```{r}
imp_no6106_log2_noQCs <- imp_no6106_log2 %>%
  filter(Intervention != "QC") 

PCA.imp_no6106_log2_noQCs <- PCA(imp_no6106_log2_noQCs, # wide data
                               quali.sup=1:11, # remove qualitative variables
                               graph=FALSE, # don't graph
                               scale.unit=FALSE) # don't scale, we already did this

# look at summary
kable(summary(PCA.imp_no6106_log2_noQCs))
```

```{r}
# pull PC coordinates into df
PC_coord_no6106_noQC_log2 <- as.data.frame(PCA.imp_no6106_log2_noQCs$ind$coord)

# bind back metadata from cols 1-11
PC_coord_no6106_noQC_log2 <- bind_cols(imp_no6106_log2_noQCs[,1:11], PC_coord_no6106_noQC_log2)

# grab some variance explained
importance_no6106_noQC <- PCA.imp_no6106_log2_noQCs$eig

# set variance explained with PC1, round to 2 digits
PC1_no6106_noQC <- round(importance_no6106_noQC[1,2], 2)

# set variance explained with PC2, round to 2 digits
PC2_no6106_noQC <- round(importance_no6106_noQC[2,2], 2)
```


#### Plots
Using FactoExtra
```{r}
# scree plot
fviz_eig(PCA.imp_no6106_log2_noQCs)
```

```{r}
# scores plot
fviz_pca_ind(PCA.imp_no6106_log2_noQCs)
```


#### Manual scores plot

```{r}
(PCA_no6106_withoutQCs <- PC_coord_no6106_noQC_log2 %>%
  ggplot(aes(x = Dim.1, 
             y = Dim.2,
             fill = Intervention,
             text = sample_ID)) +
    geom_point(shape = 21, alpha = 0.8) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha=0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha=0.5) +
    scale_fill_manual(values = c("tomato1", "gold")) +
    scale_color_manual(values = "black") +  
    theme_minimal() +
    coord_fixed(PC2_no6106_noQC/PC1_no6106_noQC) +
    labs(x = glue::glue("PC1: {PC1_no6106_noQC}%"),
         y = glue::glue("PC2: {PC2_no6106_noQC}%"),
         fill = "Intervention",
         title = "Principal Components Analysis Scores Plot"))
ggplotly(PCA_no6106_withoutQCs, tooltip = "text")
```

Now we're seeing some separation along PC2! Let's explore this more with a pub-friendly package for PCAs, the PCAtools package.


# PCAtools

## W/ Outlier

### Data wrangling
```{r}
# create rel abund df suitable for PCAtools package
imp_clust_omicsdata_outliers_forPCAtools <- as.data.frame(t(anno_imp_metabind_clust_log2[,-c(2:11)])) # transpose df (using df with key)

names(imp_clust_omicsdata_outliers_forPCAtools) <- imp_clust_omicsdata_outliers_forPCAtools[1,] # make sample IDs column names

imp_clust_omicsdata_outliers_forPCAtools <- imp_clust_omicsdata_outliers_forPCAtools[-1,] # remove sample ID row

# create metadata df suitable for PCAtools pckg
metadata_outliers_forPCAtools <- metadata %>%
  column_to_rownames(var = "sample_ID") # change sample ID column to rownames

# create a vector so that col names in abundance df matches metadata df
order_outliers_forPCAtools <- match(rownames(metadata_outliers_forPCAtools), colnames(imp_clust_omicsdata_outliers_forPCAtools))

# reorder col names in abundance df so that it matches metadata
abundata_outliers_reordered_forPCAtools <- imp_clust_omicsdata_outliers_forPCAtools[ ,order_outliers_forPCAtools] 

# change abundance df to numeric and change name to for consistency! (using df that is already log2 transformed as of 8/26/24)
log2_abundata_outliers_reordered_forPCAtools <-
  abundata_outliers_reordered_forPCAtools %>%
  mutate_all(as.numeric)


# unite pre_post column with intervention column to create pre_intervention column
metadata_outliers_forPCAtools <- metadata_outliers_forPCAtools %>%
  unite(col = "pre_post_intervention",
        c("pre_post","Intervention"),
        sep = "_",
        remove = FALSE)
```


### PCA

```{r, fig.width=10, fig.height=6}
# pca
p_outliers <- PCAtools::pca(log2_abundata_outliers_forPCAtools, 
         metadata = metadata_outliers_forPCAtools, 
         scale = FALSE # using scaled data already (log2 transformed)
         
)

(PCAtools_outliers <- biplot(p_outliers,
                               lab = paste0(metadata_outliers_forPCAtools$Subject),
                           colby = 'pre_post_intervention',
                           colkey = c("pre_Yellow" = "lemonchiffon1",
                                        "post_Yellow" = "yellow2",
                                        "pre_Red" = "rosybrown2",
                                        "post_Red" = "darkred"),
                           hline = 0, vline = 0,
                           legendPosition = 'right',
                           title = "PCA Scores Plot with Loadings",
                           subtitle = "Log2 transformed data, C18 (-), without QCs but with outliers \n99% Confidence Ellipses",
                           ellipse = TRUE,
                           ellipseType = 't', # assumes multivariate
                           ellipseLevel = 0.99,
                           ellipseFill = TRUE,
                           ellipseAlpha = 0.2,
                           xlim = c(-50, 90),
                           ylim = c(-50, 50),
                           ellipseLineSize = 0.5,
                           showLoadings = FALSE))
```


```{r, fig.width=10, fig.height=6}


biplot(p_outliers,
                               lab = paste0(metadata_outliers_forPCAtools$Subject),
                           colby = 'pre_post_intervention',
                           colkey = c("pre_Yellow" = "lemonchiffon1",
                                        "post_Yellow" = "yellow2",
                                        "pre_Red" = "rosybrown2",
                                        "post_Red" = "darkred"),
                           hline = 0, vline = 0,
                           legendPosition = 'right',
                           title = "PCA Scores Plot with Loadings",
                           subtitle = "Log2 transformed data, C18 (-), without QCs but with outliers",
                           ellipseLineSize = 0.5,
                           showLoadings = TRUE)
```

We see here the top 5 metabolites driving separation along PC1, which is really separation between subject 6106 and the rest of the samples. These metabolites are worth me exploring a bit more as to why subject 6106 is an outlier. Let's move on and explore the data without outliers more. Confidence ellipses were added to show that 6106 samples are statistical outliers.

## No outliers

### Data wrangling
```{r}
# create rel abund df suitable for PCAtools package

imp_clust_omicsdata_forPCAtools <- as.data.frame(t(anno_imp_metabind_clust_log2[,-c(2:11)])) # transpose df 

names(imp_clust_omicsdata_forPCAtools) <- imp_clust_omicsdata_forPCAtools[1,] # make sample IDs column names

imp_clust_omicsdata_forPCAtools <- imp_clust_omicsdata_forPCAtools[-1,] # remove sample ID row

imp_clust_omicsdata_forPCAtools <- imp_clust_omicsdata_forPCAtools %>%
  dplyr::select(!contains("QC")) # remove QC observations


# create metadata df suitable for PCAtools pckg
metadata_forPCAtools <- metadata %>%
  column_to_rownames(var = "sample_ID") # change sample ID column to rownames

# create a vector so that col names in abundance df matches metadata df
order_forPCAtools <- match(rownames(metadata_forPCAtools), colnames(imp_clust_omicsdata_forPCAtools))

# reorder col names in abundance df so that it matches metadata
abundata_reordered_forPCAtools <- imp_clust_omicsdata_forPCAtools[ ,order_forPCAtools] 

# change abundance df to numeric
log2_abundata_reordered_forPCAtools <- abundata_reordered_forPCAtools %>%
  mutate_at(1:ncol(.), as.numeric)

# fix rownames to have keys again
rownames(log2_abundata_reordered_forPCAtools) <- rownames(abundata_reordered_forPCAtools)

# remove 6106 subj from both df
log2_abundata_reordered_forPCAtools <- log2_abundata_reordered_forPCAtools %>%
  dplyr::select(!contains("6106"))

metadata_forPCAtools <- metadata_forPCAtools %>%
  filter(Subject != 6106)

# unite pre_post column with intervention column to create pre_intervention column
metadata_forPCAtools <- metadata_forPCAtools %>%
  unite(col = "pre_post_intervention",
        c("pre_post","Intervention"),
        sep = "_",
        remove = FALSE)

```

### Screeplot

Elbow method
```{r}
# pca
p <- PCAtools::pca(log2_abundata_reordered_forPCAtools, 
         metadata = metadata_forPCAtools, 
         scale = FALSE # using scaled data already (log2 transformed)
         
)

elbow <- findElbowPoint(p$variance)

elbow
```

```{r}
  screeplot(p,
    components = getComponents(p, 1:20),
    vline = elbow) +
    geom_label(aes(x = elbow + 1, y = 50,
      label = 'Elbow method', vjust = -3, size = 8))
```

How many PCs do we need to capture at least 80% variance?
```{r}
which(cumsum(p$variance) > 80)[1]
```

This shows we'd need quite a few PCs to capture most of the variance. Let's move on with 2 PCs and explore more later.

### PCA plots

#### w/ stats ellipses

```{r, fig.width=10, fig.height=10}
PCAtools::biplot(p,
       lab = paste0(metadata_forPCAtools$Subject),
       colby = 'pre_post_intervention',
       colkey = c("pre_Yellow" = "lemonchiffon1",
                                        "post_Yellow" = "yellow2",
                                        "pre_Red" = "rosybrown2",
                                        "post_Red" = "darkred"),
       hline = 0, vline = 0,
       # ellipse config
       ellipse = TRUE,
       ellipseType = 't', # assumes multivariate t-distribution
       ellipseLevel = 0.99,
       ellipseFill = TRUE,
       ellipseAlpha = 0.2,
       ellipseLineSize = 0.5,
       xlim = c(-50,50), ylim = c(-30,30),
       legendPosition = 'right',
       title = "PCA Scores Plot",
       subtitle = "Log2 transformed data, C18 (-), outliers removed, no QCs \n99% confidence level ellipses")

```

With confidence intervals (Hotelling's t), most samples are within the intervals except for a few that are not far off. We will move forward.

#### w/ loadings
Let's look at the metabolites driving separation 
```{r, fig.width=8.5, fig.height=6.5}
p$metadata$pre_post_intervention <- factor(p$metadata$pre_post_intervention, 
                                           levels = c("pre_Yellow", "post_Yellow", "pre_Red", "post_Red"),
                                           labels = c("pre-Control", "post-Control", "pre-Tomato-Soy", "post-Tomato-Soy"))

(PCA.colby.prevspost <- biplot(p,
                               lab = NULL,
                           # or lab = paste0(metadata_forPCAtools$Subject),
                           colby = 'pre_post_intervention',
                           colLegendTitle = "Intervention Timepoint",
                          colkey = c("pre-Control" = "lemonchiffon1",
                                        "post-Control" = "yellow2",
                                        "pre-Tomato-Soy" = "rosybrown2",
                                        "post-Tomato-Soy" = "darkred"),
                           hline = 0, vline = 0,
                           legendPosition = 'right',
                           title = "PCA Scores Plot",
                           subtitle = "Log2 transformed data, C18 (-), subject 6106 removed, no QCs",
                           ylim = c(-45,25),
                           showLoadings = TRUE) +
    geom_point(shape = 21, size = 3, colour = "black"))


```

ethylphenol sulfate isomer at RT 4.555 drives the most separation along PC2 according to this PCA.

#### customize plot

```{r, fig.width=8, fig.height=6}
biplot(p,
       lab = NULL,
       colby = 'pre_post_intervention',
       colLegendTitle = "Intervention Timepoint",
       colkey = c("pre-Control" = "lemonchiffon1",
                  "post-Control" = "yellow2",
                  "pre-Tomato-Soy" = "rosybrown2",
                  "post-Tomato-Soy" = "darkred"),
       hline = 0, vline = 0,
       legendPosition = 'right',
       title = "PCA Scores Plot",
       subtitle = "Log2 transformed data, C18 (-), subject 6106 removed, no QCs",
       ylim = c(-45,25),
       showLoadings = F,) +
  geom_point(shape = 21, size = 3, colour = "black")
```

```{r, fig.height=10}
loadings_PC2 <- plotloadings(p, components = getComponents(p, 2),rangeRetain = 15)
```


### Pairs plots

Here, we will look at separations for several components at once using pairs plots.

#### post-intervention comparisons
```{r, fig.width=10, fig.height=10}
(PCA_pairsplot.prevspost <-
  pairsplot(p,
    components = getComponents(p, c(1:10)),
    triangle = TRUE, trianglelabSize = 12,
    hline = 0, vline = 0,
    pointSize = 0.4,
    gridlines.major = FALSE, gridlines.minor = FALSE,
    colby = 'pre_post_intervention', 
    colkey = c("pre_Yellow" = "yellow",
               "post_Yellow" = "yellow4",
               "pre_Red" = "pink",
               "post_Red" = "red4"),
    title = 'Pairs plot', plotaxes = FALSE,
    margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm')))

```

#### sex?
Are there any obvious clusterings when colored by sex?

```{r, fig.width=10, fig.height=10}
  pairsplot(p,
    components = getComponents(p, c(1:10)),
    triangle = TRUE, trianglelabSize = 12,
    hline = 0, vline = 0,
    pointSize = 0.4,
    gridlines.major = FALSE, gridlines.minor = FALSE,
    colby = 'Sex', 
    colkey = c("M" = "red",
               "F" = "purple"),
    title = 'Pairs plot', plotaxes = FALSE,
    margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm'))
```


#### sequence?

```{r, fig.width=10, fig.height=10}
  pairsplot(p,
    components = getComponents(p, c(1:10)),
    triangle = TRUE, trianglelabSize = 12,
    hline = 0, vline = 0,
    pointSize = 0.4,
    gridlines.major = FALSE, gridlines.minor = FALSE,
    colby = 'sequence',
    title = 'Pairs plot', plotaxes = FALSE,
    margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm'))
```

## Eigen corplots

This is a cool way to explore the correlations between the metadata and the PCs! I want to look at how the metavariables correlate with PCs that account for 80% variation in the dataset. 

Again: How many PCs do we need to capture at least 80% variance?
```{r}
which(cumsum(p$variance) > 80)[1]
```

```{r, fig.width=12, fig.height=7.5}
  eigencorplot(p,
    components = getComponents(p, 1:which(cumsum(p$variance) > 80)[1]), # get components that account for 80% variance
    metavars = colnames(metadata_forPCAtools),
    col = c('darkblue', 'blue2', 'gray', 'red2', 'darkred'),
    cexCorval = 0.7,
    colCorval = 'white',
    fontCorval = 2,
    posLab = 'bottomleft',
    rotLabX = 45,
    posColKey = 'top',
    cexLabColKey = 1.5,
    scale = TRUE,
    main = 'PC1-15 metadata correlations',
    colFrame = 'white',
    plotRsquared = FALSE)
```


```{r, fig.width=14, fig.height=7.5}
  eigencorplot(p,
    components = getComponents(p, 1:which(cumsum(p$variance) > 80)[1]),
    metavars = colnames(metadata_forPCAtools),
    col = c('white', 'cornsilk1', 'gold', 'forestgreen', 'darkgreen'),
    cexCorval = 1.2,
    fontCorval = 2,
    posLab = 'all',
    rotLabX = 45,
    scale = TRUE,
    main = bquote(Principal ~ component ~ Pearson ~ r^2 ~ metadata ~ correlates),
    plotRsquared = TRUE,
    corFUN = 'pearson',
    corUSE = 'pairwise.complete.obs',
    corMultipleTestCorrection = 'BH',
    signifSymbols = c('****', '***', '**', '*', ''),
    signifCutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 1))
```


I am most interested in PCs affected by pre_post_intervention, so I think it would be good to investigate the metabolites that contribute the most to these PCs.



# Multilevel PCA

Because this is a crossover trial, measurements are taken from the same person repeatedly and thus introduces variance not dependent on the treatment but the subject. To account for interindividual variations in MVA, I try multilevel PCAs from the mixOmics package. Here, I do not remove subject 6106.

```{r}
# make df suitable for mixOmics
Data_forMPCA <- anno_imp_metabind_clust_log2_noQCs %>%
  mutate_at("Subject", as.factor) # change subject id to factor
 

summary(as.factor(Data_forMPCA$Subject))

# make a vector for meta variables
(metavar <- Data_forMPCA[,c(1:11)] %>%
    colnames())
```

## Regular scores plot
```{r}
mixOmicsPCA.result <- mixOmics::pca(Data_forMPCA[,!names(Data_forMPCA) %in% metavar],
                            scale = FALSE,
                            center = FALSE)

plotIndiv(mixOmicsPCA.result, 
          ind.names = Data_forMPCA$Subject, 
          group = Data_forMPCA$pre_post_intervention, 
          legend = TRUE, 
          legend.title = "Treatment", 
          title = 'Regular PCA, C18 (-), Log2 transformed')

```
We see the same thing we've been seeing with 6106 overwhelming PC2. Let's try the multilevel pca and see what happens!

## Manual PCA no outliers

```{r}
# make df suitable for mixOmics
Data_forMPCA_noOutliers <- anno_imp_metabind_clust_log2_noQCs %>%
  filter(Subject != 6106) %>%
  mutate_at("Subject", as.factor) # change subject id to factor

summary(as.factor(Data_forMPCA_noOutliers$Subject))

# make a vector for meta variables
(metavar_noOutliers <- Data_forMPCA_noOutliers[,c(1:11)] %>%
    colnames())
```

```{r}
mixOmicsPCA.result_noOutlier <- mixOmics::pca(Data_forMPCA_noOutliers[,!names(Data_forMPCA_noOutliers) %in% metavar_noOutliers],
                            scale = FALSE,
                            center = T)

plotIndiv(mixOmicsPCA.result_noOutlier, 
          ind.names = Data_forMPCA_noOutliers$Subject, 
          group = Data_forMPCA_noOutliers$pre_post_intervention, 
          legend = TRUE, 
          legend.title = "Treatment", 
          title = 'Regular PCA, C18 (-), Log2 transformed, no outliers')

```

### Loadings 

```{r, fig.width=10}
(loadings_PC2 <- plotLoadings(mixOmicsPCA.result_noOutlier, ndisplay = 5,comp = 2))
```

### Beautify 


```{r}
mixOmicsPCA_scores <- mixOmicsPCA.result_noOutlier$variates$X %>% # retrieve scores
  as.data.frame() %>%
  mutate(sample_ID = Data_forMPCA_noOutliers$sample_ID)

# join with metadata
mixOmicsPCA_points <- left_join(mixOmicsPCA_scores, Data_forMPCA_noOutliers[,1:11]) 
```

#### Scores
```{r}
# visualize!
(plot_mixOmicsPCA_manual <- mixOmicsPCA_points %>% 
  ggplot(aes(x = PC1, y = PC2, 
             fill = factor(pre_post_intervention, levels = c("pre_Yellow",
                                                             "post_Yellow",
                                                             "pre_Red",
                                                             "post_Red")),
             text = sample_ID)) +
    geom_point(shape = 21, alpha = 0.8) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha=0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha=0.5) +
    scale_fill_manual(values = c("lemonchiffon1",
                                 "yellow2",
                                 "rosybrown2",
                                 "darkred")) +
    scale_color_manual(values = "black") +  
    theme_minimal() +
    labs(x = "PC1, 11% variation",
         y = "PC2, 15% variation",
         fill = "Timepoint",
         title = "Principal Components Analysis Scores Plot",
         subtitle = "Log2 transformed data, C18 (-), Outlier subjects removed"))

ggplotly(plot_multilevelPCA_manual,
         tooltip = "text")
```

#### Biplot

```{r}
# retrieve loadings
mixOmicsPCA_loadings <- mixOmicsPCA.result_noOutlier$loadings$X %>%
  as.data.frame() %>%
  rownames_to_column("mz_rt")
```

```{r}
mixOmicsPCA_loadings %>%
  filter(PC2 %in% loadings_PC2$importance) %>%
  ggplot(aes(x = PC1, y = PC2, label = mz_rt)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  geom_point() +
  geom_label_repel(size = 2.5) +
  scale_fill_brewer() +
  theme_minimal() +
  labs( x = "PC1, 11% variation",
         y = "PC2, 15% variation",
       title = "Loadings Plot for PCA",
       subtitle = "C18 (-), Outliers removed",)
```


```{r}
# fx to normalize scores so that scores and loadings are on the same scale
normalize <- function(x) return((x - min(x))/(max(x) - min(x)))
```

```{r}
# normalize scores
mixOmicsPCA_scores_normalized <- mixOmicsPCA_scores %>%
  mutate(PC1_norm = scale(normalize(PC1), center = TRUE, scale = FALSE)) %>%
  mutate(PC2_norm = scale(normalize(PC2), center = TRUE, scale = FALSE)) %>%
  dplyr::select(sample_ID, PC1_norm, PC2_norm, everything()) # reorder 
```

How did it go? PC1_norm and PC2_norm should all now be between -1 and 1
```{r}
head(mixOmicsPCA_scores_normalized) # looks good
```


Now we can plot together the scores and loadings in one plot.
```{r}
# join with metadata
mixOmicsPCA_points_norm <- left_join(mixOmicsPCA_scores_normalized, Data_forMPCA_noOutliers[,1:11]) 
```

```{r reg pca biplot arrows}
mixOmicsPCA_points_norm %>%
  ggplot() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  geom_point(aes(x = PC1_norm, y = PC2_norm, 
                 fill = factor(pre_post_intervention, 
                               levels = c("pre_Yellow",
                                          "post_Yellow",
                                          "pre_Red",
                                          "post_Red"))),
             inherit.aes = F,
             shape = 21) +
  geom_segment(data = mixOmicsPCA_loadings %>%
                 filter(PC2 %in% loadings_PC2$importance), 
               aes(x = 0, y = 0, 
                   xend = (PC1*4), yend = (PC2*4)), 
               arrow = arrow(length = unit(1/2, "picas")),
                                color = "black", alpha=0.55) +
  geom_label_repel(data = mixOmicsPCA_loadings %>%
                    filter(PC2 %in% loadings_PC2$importance),
                   aes(x = PC1*4.6, y = PC2*4, label = mz_rt), 
                   size = 2.5, segment.color = "transparent",
                   direction = "both", max.overlaps = 15) +
  scale_fill_manual(values = c("lemonchiffon1",
                                 "yellow2",
                                 "rosybrown2",
                                 "darkred")) +
  theme_minimal() +
  labs(x = "PC1, 11% variation",
         y = "PC2, 15% variation",
       title = "Principal Component Analysis Biplot",
       subtitle = "C18 (-), Log2 transformed data, Subj 6106 removed",
       fill = "Timepoint",
       caption = "")
```


```{r reg pca biplot no arrows}
mixOmicsPCA_points_norm %>%
  ggplot() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  geom_point(aes(x = PC1_norm, y = PC2_norm, 
                 fill = factor(pre_post_intervention, 
                               levels = c("pre_Yellow",
                                          "post_Yellow",
                                          "pre_Red",
                                          "post_Red"))),
             inherit.aes = F,
             shape = 21) +
  geom_label_repel(data = mixOmicsPCA_loadings %>%
                    filter(PC2 %in% loadings_PC2$importance),
                   aes(x = PC1*4.6, y = PC2*4, label = mz_rt), 
                   size = 2.5, segment.color = "transparent",
                   direction = "both", max.overlaps = 15) +
  scale_fill_manual(values = c("lemonchiffon1",
                                 "yellow2",
                                 "rosybrown2",
                                 "darkred"),
                    labels = c("pre control",
                               "post control",
                               "pre tomato-soy",
                               "post tomato-soy")) +
  theme_bw() +
  labs(x = "PC1, 11% variation",
         y = "PC2, 15% variation",
       title = "Principal Component Analysis Biplot",
       subtitle = "C18 (-), Log2 transformed data, Subj 6106 removed",
       caption = "",
       fill = "Timepoint")
```




## Multilevel scores plot

```{r}
multilevelPCA.result <- mixOmics::pca(Data_forMPCA[,-(c(1:11))], 
                            multilevel = Data_forMPCA$Subject,
                            scale = FALSE,
                            center = FALSE)

plotIndiv(multilevelPCA.result, 
          ind.names = Data_forMPCA$Subject, 
          group = Data_forMPCA$pre_post_intervention, 
          legend = TRUE, 
          legend.title = "Treatment", 
          title = 'Multilevel PCA, C18 (-), Log2 transformed')

```

Now, even with 6106 still included, we see clear separation between post-Red and other timepoints! Let's take a look at a loadings plot to see the top  features that contribute to PC1 separation.

### Loadings 
```{r, fig.width=10}
(loadings_MPCA1 <- plotLoadings(multilevelPCA.result, ndisplay = 5))
```

Ethylphenol sulfate isomer still is the top driver of separation. More digging into PCA/MVA to come!

### Beautify 


```{r}
multilevelPCA_scores <- multilevelPCA.result$variates$X %>% # retrieve scores
  as.data.frame() %>%
  mutate(sample_ID = Data_forMPCA$sample_ID)

# join with metadata
multilevelPCA_points <- left_join(multilevelPCA_scores, Data_forMPCA[,1:11]) 
```

#### Scores
```{r}
# visualize!
(plot_multilevelPCA_manual <- multilevelPCA_points %>% 
  ggplot(aes(x = PC1, y = PC2, 
             fill = factor(pre_post_intervention, levels = c("pre_Yellow",
                                                             "post_Yellow",
                                                             "pre_Red",
                                                             "post_Red")),
             text = sample_ID)) +
    geom_point(shape = 21, alpha = 0.8) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha=0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha=0.5) +
    scale_fill_manual(values = c("lemonchiffon1",
                                 "yellow2",
                                 "rosybrown2",
                                 "darkred")) +
    scale_color_manual(values = "black") +  
    theme_minimal() +
    labs(x = "PC1, 23% variation",
         y = "PC2, 10% variation",
         fill = "Timepoint",
         title = "Multilevel Principal Components Analysis Scores Plot",
         subtitle = "Log2 transformed data, C18 (-), All subjects included"))

ggplotly(plot_multilevelPCA_manual,
         tooltip = "text")
```

#### Biplot

```{r}
# retrieve loadings
multilevelPCA_loadings <- multilevelPCA.result$loadings$X %>%
  as.data.frame() %>%
  rownames_to_column("mz_rt")
```

```{r}
multilevelPCA_loadings %>%
  filter(PC1 %in% loadings_MPCA1$importance) %>%
  ggplot(aes(x = PC1, y = PC2, label = mz_rt)) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  geom_point() +
  geom_label_repel(size = 2.5) +
  scale_fill_brewer() +
  theme_minimal() +
  labs( x = "PC1, 23% variation",
         y = "PC2, 10% variation",
       title = "Loadings Plot for Multilevel PCA",
       subtitle = "C18 (-)",)
```


```{r}
# fx to normalize scores so that scores and loadings are on the same scale
normalize <- function(x) return((x - min(x))/(max(x) - min(x)))
```

```{r}
# normalize scores
multilevelPCA_scores_normalized <- multilevelPCA_scores %>%
  mutate(PC1_norm = scale(normalize(PC1), center = TRUE, scale = FALSE)) %>%
  mutate(PC2_norm = scale(normalize(PC2), center = TRUE, scale = FALSE)) %>%
  dplyr::select(sample_ID, PC1_norm, PC2_norm, everything()) # reorder 
```

How did it go? PC1_norm and PC2_norm should all now be between -1 and 1
```{r}
head(multilevelPCA_scores_normalized) # looks good
```


Now we can plot together the scores and loadings in one plot.
```{r}
# join with metadata
multilevelPCA_points_norm <- left_join(multilevelPCA_scores_normalized, Data_forMPCA[,1:11]) 
```

```{r multilevel biplot arrows}
multilevelPCA_points_norm %>%
  ggplot() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  geom_point(aes(x = PC1_norm, y = PC2_norm, 
                 fill = factor(pre_post_intervention, 
                               levels = c("pre_Yellow",
                                          "post_Yellow",
                                          "pre_Red",
                                          "post_Red"))),
             inherit.aes = F,
             shape = 21) +
  geom_segment(data = multilevelPCA_loadings %>%
                 filter(PC1 %in% loadings_MPCA1$importance), 
               aes(x = 0, y = 0, 
                   xend = (PC1*4), yend = (PC2*4)), 
               arrow = arrow(length = unit(1/2, "picas")),
                                color = "black", alpha=0.55) +
  geom_label_repel(data = multilevelPCA_loadings %>%
                    filter(PC1 %in% loadings_MPCA1$importance),
                   aes(x = PC1*4.6, y = PC2*5, label = mz_rt), 
                   size = 2.5, segment.color = "transparent",
                   direction = "both", max.overlaps = 15) +
  scale_fill_manual(values = c("lemonchiffon1",
                                 "yellow2",
                                 "rosybrown2",
                                 "darkred")) +
  theme_minimal() +
  labs(x = "PC1, 23% variation",
         y = "PC2, 10% variation",
       title = "Biplot for Multilevel PCA",
       subtitle = "C18 (-)",
       fill = "Timepoint",
       caption = "")
```


```{r multilevel biplot no arrows}
multilevelPCA_points_norm %>%
  ggplot() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_vline(xintercept = 0, linetype = "dashed") +
  geom_point(aes(x = PC1_norm, y = PC2_norm, 
                 fill = factor(pre_post_intervention, 
                               levels = c("pre_Yellow",
                                          "post_Yellow",
                                          "pre_Red",
                                          "post_Red"))),
             inherit.aes = F,
             shape = 21) +
  geom_label_repel(data = multilevelPCA_loadings %>%
                    filter(PC1 %in% loadings_MPCA1$importance),
                   aes(x = PC1*4.6, y = PC2*5, label = mz_rt), 
                   size = 2.5, segment.color = "transparent",
                   direction = "both", max.overlaps = 15) +
  scale_fill_manual(values = c("lemonchiffon1",
                                 "yellow2",
                                 "rosybrown2",
                                 "darkred"),
                    labels = c("pre control",
                               "post control",
                               "pre tomato-soy",
                               "post tomato-soy")) +
  theme_minimal() +
  labs(x = "PC1, 23% variation",
         y = "PC2, 10% variation",
       title = "Biplot for Multilevel PCA",
       subtitle = "C18 (-)",
       caption = "",
       fill = "Timepoint")
```


# Univariate analysis

## Wrangle data
```{r}
# use tidy data 
head(anno_imp_metabind_clust_tidy_log2)

# remove QCs
df_for_stats <- anno_imp_metabind_clust_tidy_log2 %>%
  filter(Intervention != "QC")

# check if QCs were removed
unique(df_for_stats$Intervention)
```

```{r}
# df without outlier 6106
df_for_stats_noOutlier <- df_for_stats %>%
  filter(Subject != "6106")

# check if outlier was removed
unique(df_for_stats_noOutlier$Subject)
```

```{r}
# turn off sci notation outputs
options(scipen = 999)
```


## Parametric tests

## ANOVA (repeated measures) across timepoints

```{r}
anova_outpout_df <- df_for_stats_noOutlier %>% 
  dplyr::select(Subject, pre_post_intervention, Feature_ID, rel_abund_log2) %>%
  group_by(Feature_ID) %>%
  anova_test(rel_abund_log2 ~ pre_post_intervention, wid = Subject,
             detailed = TRUE) %>%
  adjust_pvalue(method = "BH") %>%
  as.data.frame()

anova_sig <- anova_outpout_df %>%
  filter(p.adj <= .05)

# how many significant features?
nrow(anova_sig)
  
```

```{r}
# tukey's posthoc
tukey_anova <- df_for_stats_noOutlier %>% 
  dplyr::select(Subject, pre_post_intervention, Feature_ID, rel_abund_log2) %>%
  group_by(Feature_ID) %>%
  tukey_hsd(rel_abund_log2 ~ pre_post_intervention, wid = subject)
```


### Heatmap of features significant by ANOVA

```{r, fig.height=20, fig.width=12, fig.asp=1}
# go back to wide for stats df (keeping all subjects in the visualization, but anova was done without outliers)
df_for_stats_wide <- df_for_stats %>%
  dplyr::select(!c(rel_abund, metabolite_class, parent_compound, id, mz_rt)) %>%
  pivot_wider(names_from = Feature_ID,
              values_from = rel_abund_log2)

ANOVA_heatmap_data <- df_for_stats_wide %>%
  unite("Subject_pre_post_intervention", Subject, pre_post_intervention, sep = "_", remove = FALSE) %>%
  dplyr::select(Subject, Subject_pre_post_intervention, pre_post, all_of(anova_sig$Feature_ID))


ANOVA_heatmap_annotated <- 
  pheatmap(t(ANOVA_heatmap_data[,-c(1:3)]),
           scale = "row",
           cluster_rows = TRUE,
           clustering_distance_rows = "euclidean",
           clustering_distance_cols = "euclidean",
           clustering_method = "ward.D2",
           labels_col = ANOVA_heatmap_data$Subject_pre_post_intervention,
           color = colorRampPalette(c("#67a9cf", "#f7f7f7", "#ef8a62"))(16),
           main = "Heatmap of features significant across timepoints \nby repeated measures one-way ANOVA \nBenjamoni-Hochberg corrected p-values > 0.05 \nC18 (-)")
  
```


```{r}
ggsave(plot = ANOVA_heatmap_annotated, height = 20, width = 12,
       filename = "plots and figures/ANOVA_sig_heatmap.svg")
```


```{r}
ANOVA_heatmap_data2 <- df_for_stats_wide %>%
  unite("Subject_pre_post_intervention", Subject, pre_post_intervention, sep = "_", remove = FALSE) %>%
  dplyr::select(sample_ID, Subject_pre_post_intervention, pre_post_intervention, all_of(anova_sig$Feature_ID)) %>%
  column_to_rownames("sample_ID") 
```


```{r}
# change pre_post_intervention to factor
df_for_stats_wide$pre_post_intervention <- as.factor(df_for_stats_wide$pre_post_intervention)

# create annotation rows for treatment and wrangle
# select sample col from heatmap metadata (also ensures the order is correct)
anno_trt_row <- as.data.frame(rownames(ANOVA_heatmap_data2))

# pull desired columns
anno_trt_row$pre_post_intervention <- ANOVA_heatmap_data2$pre_post_intervention

# select trt
anno_trt_row <- anno_trt_row %>%
  dplyr::select(pre_post_intervention) 

# get rownames to match heatmap
rownames(anno_trt_row) <- rownames(ANOVA_heatmap_data2)

# create annotation colors
annotation_colors <- list(pre_post_intervention = c("pre_Yellow" = "lemonchiffon1",
                                                    "post_Yellow" = "yellow2",
                                                    "pre_Red" = "rosybrown2",
                                                    "post_Red" = "darkred"))
```

```{r, fig.height=20, fig.width=12, fig.asp=1}
ANOVA_heatmap <- 
  pheatmap(t(ANOVA_heatmap_data2[,-c(1:2)]),
           scale = "row",
           cluster_rows = TRUE,
           clustering_distance_rows = "euclidean",
           clustering_distance_cols = "euclidean",
           clustering_method = "ward.D2",
           labels_col = ANOVA_heatmap_data2$Subject_pre_post_intervention,
           color = colorRampPalette(c("#67a9cf", "#f7f7f7", "#ef8a62"))(16),
           annotation_col = anno_trt_row,
           annotation_colors = annotation_colors,
           annotation_names_col = F,
           main = "Heatmap of features significant across timepoints \nby repeated measures one-way ANOVA \nBenjamoni-Hochberg corrected p-values > 0.05 \nC18 (-)")
  
```

### Paired t tests

Here, I am comparing pre- to post-intervention for both yellow and tomato soy (Red) juice interventions. I also compare post-yellow to post-red intervention. I am using the log transformed values of rel abundance since parametric tests assume normality.

#### Ctrl
```{r}
# run paired t-tests for control intervention
ctrl_t.test_paired <- df_for_stats %>%
  filter(Intervention == "Yellow") %>%
  dplyr::select(Subject, pre_post, Feature_ID, rel_abund_log2) %>%
  group_by(Feature_ID) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
ctrl_t.test_paired_sig <- ctrl_t.test_paired %>%
  filter(p <= 0.05)
kable(ctrl_t.test_paired_sig)

# how many are significant?
nrow(ctrl_t.test_paired_sig)
```


#### Ctrl - no outlier
```{r}
# run paired t-tests for control intervention
ctrl_noOutlier_t.test_paired <- df_for_stats_noOutlier %>%
  filter(Intervention == "Yellow") %>%
  dplyr::select(Subject, pre_post, mz_rt, Feature_ID, rel_abund_log2) %>%
  group_by(Feature_ID) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
ctrl_noOutlier_t.test_paired_sig <- ctrl_noOutlier_t.test_paired %>%
  filter(p <= 0.05)
kable(ctrl_noOutlier_t.test_paired_sig)

# how many are significant?
nrow(ctrl_noOutlier_t.test_paired_sig)
```


#### Red
```{r}
# run paired t-tests for control intervention
red_t.test_paired <- df_for_stats %>%
  filter(Intervention == "Red") %>%
  dplyr::select(Subject, pre_post, mz_rt, Feature_ID, rel_abund_log2) %>%
  group_by(Feature_ID) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
red_t.test_paired_sig <- red_t.test_paired %>%
  filter(p <= 0.05)
kable(red_t.test_paired_sig)

# how many are significant?
nrow(red_t.test_paired_sig)
```


#### Red Without outlier
```{r}
# run paired t-tests for control intervention
red_noOutlier_t.test_paired <- df_for_stats_noOutlier %>%
  filter(Intervention == "Red") %>%
  dplyr::select(Subject, pre_post, mz_rt, Feature_ID, rel_abund_log2) %>%
  group_by(Feature_ID) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
red_noOutlier_t.test_paired_sig <- red_noOutlier_t.test_paired %>%
  filter(p <= 0.05)
kable(red_noOutlier_t.test_paired_sig)

# how many are significant?
nrow(red_noOutlier_t.test_paired_sig)
```


#### Post-red vs post-yellow

```{r}
# run paired t-tests for post interventions
post_t.test_paired <- df_for_stats %>%
  filter(pre_post == "post") %>%
  dplyr::select(Subject, Intervention, mz_rt, Feature_ID, rel_abund_log2) %>%
  group_by(Feature_ID) %>%
  t_test(rel_abund_log2 ~ Intervention, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
post_t.test_paired_sig <- post_t.test_paired %>%
  filter(p <= 0.05)
kable(post_t.test_paired_sig)

# how many are significant?
nrow(post_t.test_paired_sig)
```

#### Post-red vs post-yellow Without Outlier

```{r}
# run paired t-tests for post interventions
post_noOutlier_t.test_paired <- df_for_stats %>%
  filter(pre_post == "post",
         Subject != "6106") %>%
  dplyr::select(Subject, Intervention, mz_rt, Feature_ID, rel_abund_log2) %>%
  group_by(Feature_ID) %>%
  t_test(rel_abund_log2 ~ Intervention, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
post_noOutlier_t.test_paired_sig <- post_noOutlier_t.test_paired %>%
  filter(p <= 0.05)
kable(post_noOutlier_t.test_paired_sig)

# how many are significant?
nrow(post_noOutlier_t.test_paired_sig)
```


#### Outlier comparison
Are there any significant features shared between tests with and without outlier?

```{r}
# return sig features present only in df with outlier, and not in df without outlier
kable(anti_join(post_noOutlier_t.test_paired_sig,
          post_t.test_paired_sig,
          by = "Feature_ID"))

nrow(anti_join(post_noOutlier_t.test_paired_sig,
          post_t.test_paired_sig,
          by = "Feature_ID"))

# return sig features from df with no outlier that are also present in df with outlier
kable(semi_join(post_noOutlier_t.test_paired_sig,
          post_t.test_paired_sig,
          by = "Feature_ID"))

nrow(semi_join(post_noOutlier_t.test_paired_sig,
          post_t.test_paired_sig,
          by = "Feature_ID"))
```


### Standard comparisons

Here, I want to only focus on the metabolites that I hypothesized to change. This way I can avoid multiple correction adjustments and see if I can capture any significant differences at different timepoints

#### Wrangle

```{r}
endog_stds_in_data <- df_for_stats %>%
  filter(Feature_ID %in% c("hippuric acid", "glucose", "histidine", "citric acid", "indoxyl sulfate"))
```


```{r}
# changing factor levels for pre_post_intervention
endog_stds_in_data$pre_post_intervention <- factor(endog_stds_in_data$pre_post_intervention,
                                                   levels = c("pre_Yellow", "post_Yellow", 
                                                              "pre_Red", "post_Red"))

levels(endog_stds_in_data$pre_post_intervention)  
```


#### Boxplots
```{r, fig.width=10}
endog_stds_in_data %>% 
  ggplot(aes(x = pre_post_intervention, y = rel_abund_log2, fill = Intervention)) +
  geom_boxplot(outlier.shape = NA) +
  scale_fill_manual(values = c("Yellow" = "gold",
                                           "Red" = "tomato1")) +
  geom_line(aes(group = Subject), colour = "gray", linewidth = 0.2) +
  facet_wrap(vars(Feature_ID), scales = "free_y") + 
  theme_bw() 
```

```{r, fig.width=10}
my_comparisons <- list( c("pre_Yellow", "post_Yellow"), c("pre_Red", "post_Red"), c("post_Yellow", "post_Red") )

endog_stds_in_data %>% 
  ggpaired(x = "pre_post_intervention", y = "rel_abund_log2", 
           fill = "Intervention", line.color = "gray",
           id = "Subject", line.size = 0.15) +
  scale_fill_manual(values = c("Red" = "tomato1",
                               "Yellow" = "yellow1")) +
  geom_point() +
  scale_x_discrete(labels = labs_ppintervention) +
  labs(x = "",
       y = "Log2 relative abundance",
       title = "Daidzein metabolites (Level 2 ID or higher)",
       subtitle = "FDR adjusted p-values from paired T tests") +
  facet_wrap( ~ Feature_ID, scales = "free", ncol = 5, labeller = labeller(Feature_ID = label_wrap_gen(8))) +
  stat_compare_means(comparisons = my_comparisons, method = "t.test", paired = TRUE, p.adjust.method = "BH") +
  theme_classic(base_size = 14, base_family = "sans") +
  theme(axis.text.x = element_text(angle = 45)) +
  rremove("legend")
```



### Volcano plots

#### Post-intervention comparisons 

##### Wrangle (no outlier)
```{r}
# calculate mean rel abund (not log) by sample, and avg fold change (FC) diff by feature
red_v_yel_volcano_data_noOutlier <- df_for_stats %>%
  filter(pre_post == "post",
         Subject != 6106) %>% # remove outlier subj
  group_by(Intervention, Feature_ID, mz_rt) %>%
  summarize(mean_rel_abund = mean(rel_abund)) %>%
  pivot_wider(names_from = Intervention, values_from = mean_rel_abund) %>%
  mutate(FC_postRed_div_postYellow = Red/Yellow) 

# bind back pval
red_v_yel_tobind_noOutlier <- post_noOutlier_t.test_paired %>%
  dplyr::select(p)

# calculate log2FC, and -log10p
red_v_yel_volcano_data_noOutlier <- 
  bind_cols(red_v_yel_volcano_data_noOutlier, red_v_yel_tobind_noOutlier) %>%
  mutate(log2_FC_postRed_div_postYellow = if_else(FC_postRed_div_postYellow > 0,
                                                  log2(FC_postRed_div_postYellow),
                                                  -(log2(abs(FC_postRed_div_postYellow)))), 
         neglog10p = -log10(p))


# create a df of features passing FC and pval cutoffs higher in post-Red
postRed_sig_red_v_yel_volcano_noOutlier <- red_v_yel_volcano_data_noOutlier %>%
  filter(p <= 0.05 & log2_FC_postRed_div_postYellow >= 0.6)

# create a df of features passing FC and pval cutoffs higher in post-control
postYellow_sig_red_v_yel_volcano_noOutlier <- red_v_yel_volcano_data_noOutlier %>%
  filter(p <= 0.05 & log2_FC_postRed_div_postYellow <= -0.6)  
```

##### Export sig features

Create feature lists with significant features along with their clusters
```{r}
#post-Red list
postRed_sig_intrvntn_comp_clusters <- left_join(postRed_sig_red_v_yel_volcano_noOutlier, cluster_features,
                                               by = "Feature_ID")

write_csv(postRed_sig_intrvntn_comp_clusters,
          "Feature lists/postRed-sigfeatures-intervntn-comp.csv")

#post-Yellow list
postYellow_sig_intrvntn_comp_clusters <- left_join(postYellow_sig_red_v_yel_volcano_noOutlier, cluster_features,
                                               by = "mz_rt")

write_csv(postYellow_sig_intrvntn_comp_clusters,
          "Feature lists/postYellow-sigfeatures-intervntn-comp.csv")
```


##### Plot
```{r}
(red_v_yellow_volcano_noOutlier <- red_v_yel_volcano_data_noOutlier %>%
  ggplot(aes(x = log2_FC_postRed_div_postYellow, y = neglog10p, 
             text = glue("Feature ID: {Feature_ID}
                         P-value: {p}
                         Fold change tomato/control: {round(FC_postRed_div_postYellow, 2)}"))) +
  geom_point(color = "grey") +
  geom_point(data = postRed_sig_red_v_yel_volcano_noOutlier, 
             aes(x = log2_FC_postRed_div_postYellow, y = neglog10p),
             color = "tomato") +
  geom_point(data = postYellow_sig_red_v_yel_volcano_noOutlier, 
             aes(x = log2_FC_postRed_div_postYellow, y = neglog10p),
             color = "yellow2") +
  geom_vline(xintercept = 0.6, linetype = "dashed", color = "grey") +
  geom_vline(xintercept = -0.6, linetype = "dashed", color = "grey") +
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "grey") +
  coord_cartesian(xlim = c(-5, 8)) +
  labs(title = "Volcano Plot of Features Different in People After Tomato-Soy and Control Juice Consumption",
       subtitle = "Red points are higher after tomato-soy juice consumption while yellow points are higher \nafter control tomato juice consumption. Subject 6106 removed",
       caption = "Vertical dashed lines represent a log2 fold change > 0.6 or < -0.6, and horizontal dashed line represents an FDR corrected \np-value of 0.05.",
       x = "Log2 Fold Change (TomatoSoy/Control)",
       y = "-Log10(P-value)") +
  theme_bw() +
  theme(plot.title = element_text(size = 12, hjust = 0),
        plot.caption = element_text(hjust = 0.5)))

(red_v_yellow_volcano_ggplotly_noOutlier <- ggplotly(red_v_yellow_volcano_noOutlier, tooltip = "text"))
```

Save plots
```{r, eval=FALSE}
# save volcano plot
ggsave(plot = red_v_yellow_volcano_noOutlier,
       filename = "plots and figures/volcano plots/red_v_yellow_volcano_noOutlier.svg")

# save interactive volcano plot
saveWidget(widget = red_v_yellow_volcano_ggplotly_noOutlier,
           file = "plots and figures/volcano plots/interactive_redvyellow_volcano_plot_noOutlier.html")
```


#### Red

##### Wrangle (no outlier)
```{r}
# calculate mean rel abund (not log) by sample, and avg fold change (FC) diff by feature
red_volcano_data_noOutlier <- df_for_stats %>%
  filter(Intervention == "Red",
         Subject != 6106) %>%
  group_by(pre_post, Feature_ID) %>%
  summarize(mean_rel_abund = mean(rel_abund)) %>%
  pivot_wider(names_from = pre_post, values_from = mean_rel_abund) %>%
  mutate(FC_post_div_pre = post/pre) 

# bind back pval
red_tobind_noOutlier <- red_noOutlier_t.test_paired %>%
  dplyr::select(p)

# calculate log2FC, and -log10p
red_volcano_data_noOutlier <- 
  bind_cols(red_volcano_data_noOutlier, red_tobind_noOutlier) %>%
  mutate(log2_FC_post_div_pre = log2(FC_post_div_pre),
         neglog10p = -log10(p))


# create a df of features passing FC and pval cutoffs higher in post-intervention compared to pre
red_pre_v_post_volcano_noOutlier <- red_volcano_data_noOutlier %>%
  filter(p <= 0.05 & abs(log2_FC_post_div_pre) >= 0.6)

```

##### Export sig features

Create feature lists with significant features along with their clusters
```{r}
red_sig_prepost_comp_clusters <- left_join(red_pre_v_post_volcano_noOutlier, cluster_features,
                                               by = "mz_rt")

write_csv(red_sig_prepost_comp_clusters,
          "Feature lists/Red-sigfeatures-PrevsPost-noOutliers.csv")

```


##### Plot
```{r}
(red_volcano_noOutlier <- red_volcano_data_noOutlier %>%
  ggplot(aes(x = log2_FC_post_div_pre, y = neglog10p, 
             text = glue("Feature ID: {Feature_ID}
                         P-value: {p}
                         Fold change post/pre: {round(FC_post_div_pre, 2)}"))) +
  geom_point(color = "grey") +
  geom_point(data = red_pre_v_post_volcano_noOutlier, 
             aes(x = log2_FC_post_div_pre, y = neglog10p),
             color = "tomato") +
  geom_vline(xintercept = 0.6, linetype = "dashed", color = "grey") +
  geom_vline(xintercept = -0.6, linetype = "dashed", color = "grey") + 
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "grey") +
  coord_cartesian(xlim = c(-5, 8)) +
  labs(title = "Volcano Plot of Features Different in People After Tomato-Soy Juice Consumption",
       subtitle = "Red points are higher after tomato-soy juice consumption when compared to prior to consumption",
       caption = "Vertical dashed lines represent an abs(log fold change) > 0.6, and horizontal dashed line represents an FDR corrected \np-value of 0.05.",
       x = "Log2 Fold Change (Post/Pre)",
       y = "-Log10(P-value)") +
  theme_bw() +
  theme(plot.title = element_text(size = 12, hjust = 0),
        plot.caption = element_text(hjust = 0.5)))

(red_volcano_ggplotly_noOutlier <- ggplotly(red_volcano_noOutlier, tooltip = "text"))
```

Save plots
```{r, eval=FALSE}
# save volcano plot
ggsave(plot = red_volcano_noOutlier,
       filename = "plots and figures/volcano plots/red_volcano_noOutlier.svg")

# save interactive volcano plot
saveWidget(widget = red_volcano_ggplotly_noOutlier,
           file = "plots and figures/volcano plots/interactive_red_volcano_plot_noOutlier.html")
```

#### Yellow

##### Wrangle (no outlier)
```{r}
# calculate mean rel abund (not log) by sample, and avg fold change (FC) diff by feature
yel_volcano_data_noOutlier <- df_for_stats %>%
  filter(Intervention == "Yellow",
         Subject != 6106) %>%
  group_by(pre_post, Feature_ID) %>%
  summarize(mean_rel_abund = mean(rel_abund)) %>%
  pivot_wider(names_from = pre_post, values_from = mean_rel_abund) %>%
  mutate(FC_post_div_pre = post/pre) 

# bind back pval
yel_tobind_noOutlier <- ctrl_noOutlier_t.test_paired %>%
  dplyr::select(p)

# calculate log2FC, and -log10p
yel_volcano_data_noOutlier <- 
  bind_cols(yel_volcano_data_noOutlier, yel_tobind_noOutlier) %>%
  mutate(log2_FC_post_div_pre = log2(FC_post_div_pre),
         neglog10p = -log10(p))


# create a df of features passing FC and pval cutoffs higher in post-intervention compared to pre
yel_pre_v_post_volcano_noOutlier <- yel_volcano_data_noOutlier %>%
  filter(p <= 0.05 & abs(log2_FC_post_div_pre) >= 0.6)

```

##### Export sig features

Create feature lists with significant features along with their clusters
```{r}
yel_sig_prepost_comp_clusters <- left_join(yel_pre_v_post_volcano_noOutlier, cluster_features,
                                               by = "mz_rt")

write_csv(yel_sig_prepost_comp_clusters,
          "Yellow-sigfeatures-PrevsPost-noOutliers.csv")

```

##### Plot
```{r}
(yel_volcano_noOutlier <- yel_volcano_data_noOutlier %>%
  ggplot(aes(x = log2_FC_post_div_pre, y = neglog10p, 
             text = glue("Feature ID: {Feature_ID}
                         P-value: {p}
                         Fold change post/pre: {round(FC_post_div_pre, 2)}"))) +
  geom_point(color = "grey") +
  geom_point(data = yel_pre_v_post_volcano_noOutlier, 
             aes(x = log2_FC_post_div_pre, y = neglog10p),
             color = "yellow2") +
  geom_vline(xintercept = 0.6, linetype = "dashed", color = "grey") +
  geom_vline(xintercept = -0.6, linetype = "dashed", color = "grey") +
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "grey") +
  coord_cartesian(xlim = c(-5, 8)) +
  labs(title = "Volcano Plot of Features Different in People After Control, Yellow Tomato Juice Consumption",
       subtitle = "Yellow points are higher after control juice consumption when compared to prior to consumption.\nSubject 6106 removed",
       caption = "Vertical dashed lines represent abs(log2 fold change) > 0.6, and horizontal dashed line represents an FDR corrected \np-value of 0.05.",
       x = "Log2 Fold Change (Post/Pre)",
       y = "-Log10(P-value)") +
  theme_bw() +
  theme(plot.title = element_text(size = 12, hjust = 0),
        plot.caption = element_text(hjust = 0.5)))

(yel_volcano_ggplotly_noOutlier <- ggplotly(yel_volcano_noOutlier, tooltip = "text"))
```

Save plots
```{r, eval=FALSE}
# save volcano plot
ggsave(plot = yel_volcano_noOutlier,
       filename = "plots and figures/volcano plots/yel_volcano_noOutlier.svg")

# save interactive volcano plot
saveWidget(widget = yel_volcano_ggplotly_noOutlier,
           file = "plots and figures/volcano plots/interactive_yel_volcano_plot_noOutlier.html")
```


## Joined lists
Here, I want to venn significant features before I begin to look more into them. I am interested in the following effects: tomato effect, lycopene and/or soy isoflavones effect. 

### Tomato effect
1. Tomato effect: join a list that only keeps features that are both significant in pre vs. post-red and pre vs. post-yellow. Manually deleted the features that don't have the same directionality

```{r}
# keep only features present in both pre vs post red and pre vs post yellow
tomato_effect <- inner_join(red_sig_prepost_comp_clusters,
                            yel_sig_prepost_comp_clusters,
                            by = "mz_rt")
dim(tomato_effect)
```


#### Boxplots

##### all sig tomato features

```{r}
# metabs with pval < 0.05 and fc >= 1.51. bind back key
sigmetabs_tomato_effect <- tomato_effect %>%
  left_join(df_for_stats_noOutlier)
```


```{r}
# changing factor levels for pre_post_intervention
sigmetabs_tomato_effect$pre_post_intervention <- factor(sigmetabs_tomato_effect$pre_post_intervention,
                              levels = c("pre_Yellow", "post_Yellow", "pre_Red", "post_Red"))

levels(sigmetabs_tomato_effect$pre_post_intervention)  
```

```{r, fig.width=10}
sigmetabs_tomato_effect %>% 
  ggplot(aes(x = pre_post_intervention, y = rel_abund_log2, fill = Intervention)) +
  geom_boxplot(outlier.shape = NA) +
  scale_fill_manual(values = c("Yellow" = "gold",
                                           "Red" = "tomato1")) +
  geom_line(aes(group = Subject), fill = "brown", linewidth = 0.2) +
  facet_wrap(vars(Feature_ID), scales = "free_y") + 
  theme_clean() 
```




### Lyc/soy effect
2. lycopene and/or soy isoflavones effect: join a list that only keeps features that are:
- significantly different between post-Red and post-Yellow, 
- and significant between pre- and post-Red. 
- remove features that are significant between pre-Yellow and post-Yellow.

```{r}
# combine sig features from post-red vs post-yellow
sig_postintervention_noOutlier <- full_join(postRed_sig_intrvntn_comp_clusters,
                                               postYellow_sig_intrvntn_comp_clusters)
dim(sig_postintervention_noOutlier)

# select only sig features that are present when comparing pre-Red to post-Red
lyc_soy_effect <- inner_join(sig_postintervention_noOutlier,
                             red_sig_prepost_comp_clusters,
                             by = "mz_rt") 
dim(lyc_soy_effect)

```


#### Mummichog matches

Mummichog makes a list of hits for all of the compounds, so we only need to do an inner join for one of the lists. The outcome would be the same for all of the lists used since I have to input my whole dataset (no cutoffs) into analysis. 

```{r}
mummichog_mass_matches_lycsoy <- inner_join(lyc_soy_effect,
                                            red_mummichog_hits,
                                            by = "mz_rt")

length(unique(mummichog_mass_matches_lycsoy$mz_rt)) # how many?

tibble(unique(mummichog_mass_matches_lycsoy$mz_rt)) # which features have a hit with mummichog?

```




```{r}
# map KEGG IDs to compound names
lycsoy_KEGGmatches <- as.data.frame(cpdkegg2name(mummichog_mass_matches_lycsoy$Matched.Compound))

mummichog_mass_matches_lycsoy$NAME <- lycsoy_KEGGmatches$NAME

```



#### Boxplots


##### all sig lyc soy features

```{r}
# metabs with pval < 0.05 and fc >= 1.51
sigmetabs_lycsoy_effect <- lyc_soy_effect %>%
  left_join(df_for_stats_noOutlier)
```


```{r}
# changing factor levels for pre_post_intervention
sigmetabs_lycsoy_effect$pre_post_intervention <- factor(sigmetabs_lycsoy_effect$pre_post_intervention,
                                                                levels = c("pre_Yellow", "post_Yellow", 
                                                                           "pre_Red", "post_Red"))

levels(sigmetabs_lycsoy_effect$pre_post_intervention)  
```

```{r, fig.height=40, fig.width=30}
sigmetabs_lycsoy_effect %>% 
  ggplot(aes(x = pre_post_intervention, y = rel_abund_log2, fill = Intervention)) +
  geom_boxplot(outlier.shape = NA) +
  scale_fill_manual(values = c("Yellow" = "gold",
                                           "Red" = "tomato1")) +
  geom_line(aes(group = Subject), linewidth = 0.2) +
  facet_wrap(vars(Feature_ID), scales = "free_y") + 
  theme_clean() 
```


### Low carotenoid tomato effect
2. yellow tomato effect: use list that only keeps features that are both significant between post-Red and post-Yellow timepoints, and significant between pre- and post-Yellow. These features are NOT significant between pre-Yellow and post-Yellow.

```{r}
# sig features from post-red vs post-yellow
dim(sig_postintervention_noOutlier)

# select only sig features that are present when comparing pre-Yellow to post-Yellow
low_carot_tomato_effect <- inner_join(sig_postintervention_noOutlier,
                             yel_sig_prepost_comp_clusters,
                             by = "mz_rt") 
dim(low_carot_tomato_effect)
```


#### Boxplots

##### all sig yellow tom features

```{r}
# metabs with pval < 0.05 and fc >= 1.51
sigmetabs_yellow_effect <- low_carot_tomato_effect %>%
  left_join(df_for_stats_noOutlier)
```


```{r}
# changing factor levels for pre_post_intervention
sigmetabs_yellow_effect$pre_post_intervention <- factor(sigmetabs_yellow_effect$pre_post_intervention,
                                                                levels = c("pre_Yellow", "post_Yellow", 
                                                                           "pre_Red", "post_Red"))

levels(sigmetabs_yellow_effect$pre_post_intervention)  
```

```{r}
sigmetabs_yellow_effect %>% 
  ggplot(aes(x = pre_post_intervention, y = rel_abund_log2, fill = Intervention)) +
  geom_boxplot(outlier.shape = NA) +
  scale_fill_manual(values = c("Yellow" = "gold",
                                           "Red" = "tomato1")) +
  geom_line(aes(group = Subject), fill = "brown", linewidth = 0.2) +
  facet_wrap(vars(Feature_ID), scales = "free_y") + 
  theme_clean() 
```

# Immuno Correlations

IL-5, IL-12p70, and GM-CSF were significantly decreased after tomato-soy intervention (only when comparing pre to post in Red) according to Wilcoxon rank-sum tests (p<0.05). Immune cell types were significantly altered in all 3 comparisons - so let's see how these significant immuno outcomes correlate with metabolites found to be significant at p > 0.05 and FC >=1.61.

Import other outcomes (carotenoids and immunology data)
```{r}
# load data
carot_immunology_meta <- read_excel("CompiledData_Results_Meta.xlsx",
                         sheet = "metadata_corrected_withsequence")

# clean up variable names 
carot_immunology_meta <- clean_names(carot_immunology_meta)
```

## Wrangle 

```{r}
# convert variables that should be factors to factors
carot_immunology_meta <- carot_immunology_meta %>%
  filter(intervention != "Baseline") %>%
  mutate(across(.cols = c("patient_id", "period", 
                          "intervention", "intervention_week", 
                          "pre_post", "sex", "sequence"),
                .fns = as.factor))


# some stuff came in as characters but should be numeric
carot_immunology_meta <- carot_immunology_meta %>%
  mutate(across(.cols = c("il_2", "il_10", "il_13", "il_4"),
                .fns = as.numeric))



# changing factor levels for pre_post
carot_immunology_meta$pre_post <- factor(carot_immunology_meta$pre_post,
                              levels = c("pre", "post"))

levels(carot_immunology_meta$pre_post)        

# Calculate total_cis_lyc, total_lyc, and total_carotenoids
carot_immunology_meta <- carot_immunology_meta %>%
  mutate(total_cis_lyc = other_cis_lyc + x5_cis_lyc,
         total_lyc = all_trans_lyc + total_cis_lyc,
         total_carotenoids = lutein + zeaxanthin + b_cryptoxanthin + 
                             a_carotene + b_carotene + total_lyc) 
```


### Rm outliers

```{r}
# go back to wide for stats df
df_for_stats_wide_noOutlier <- df_for_stats_noOutlier %>%
  select(!c(mz_rt, rel_abund, id:parent_compound)) %>%
  pivot_wider(names_from = Feature_ID,
              values_from = rel_abund_log2)

# take outliers out of carot_immuno df 
carot_immunology_meta_noOutlier <- carot_immunology_meta %>%
  filter(patient_id != 6106)

# add sig immuno outcome columns and lyc levels to dataset
forcorr_metabslog2_immuno_noOutlier <- df_for_stats_wide_noOutlier %>%
  mutate(il_5 = carot_immunology_meta_noOutlier$il_5,
         il_12p70 = carot_immunology_meta_noOutlier$il_12p70,
         gm_csf = carot_immunology_meta_noOutlier$gm_csf,
         total_lyc = carot_immunology_meta_noOutlier$total_lyc) %>%
  #log2 transform cytokines and total lycopene levels
  mutate_at(c("il_5", "il_12p70", "gm_csf" ,"total_lyc"), log2)

```



Here, I am going to look at correlations between fold change differences and sig metabolites from the lycopene/soy effect list

### More wrangling
No outliers

Subset df's into pre and post 
```{r}
# pre
forcorr_pre_metabslog2_immuno_noOutlier <- forcorr_metabslog2_immuno_noOutlier %>%
  dplyr::select(Subject, Intervention, pre_post, 12:ncol(.)) %>%
  filter(pre_post == "pre")

# post 
forcorr_post_metabslog2_immuno_noOutlier <- forcorr_metabslog2_immuno_noOutlier %>%
  dplyr::select(Subject, Intervention, pre_post, 12:ncol(.)) %>%
  filter(pre_post == "post")
```

Create df with differences calculated for each outcome
```{r}
# difference for calculated for each outcome
forcorr_diff_metabslog2_immuno_noOutlier <- forcorr_post_metabslog2_immuno_noOutlier[,-c(1:3)] - forcorr_pre_metabslog2_immuno_noOutlier[,-c(1:3)]

```

## All metabs corr

```{r}
forcorr_diff_allmetabs_immuno_noOutlier <- forcorr_diff_metabslog2_immuno_noOutlier %>%
  # add subject and intervention back to df.
  mutate(Subject = forcorr_post_metabslog2_immuno_noOutlier$Subject,
         Intervention = forcorr_post_metabslog2_immuno_noOutlier$Intervention)

# correlation table
corr_results_metabs_immuno_diff_noOutlier <- forcorr_diff_allmetabs_immuno_noOutlier %>% 
  correlate(method = "spearman") %>%
  rearrange() %>%
  shave()
```


Look for strongly correlated outcomes. R^2 >= to 0.5
```{r}
strongcorr_allmetabs_immunodata <- corr_results_metabs_immuno_diff_noOutlier %>%
  dplyr::select(term, il_5, il_12p70, gm_csf, total_lyc) %>%
  filter(abs(corr_results_metabs_immuno_diff_noOutlier$il_5) >= 0.5 |
           abs(corr_results_metabs_immuno_diff_noOutlier$il_12p70) >= 0.5 |
           abs(corr_results_metabs_immuno_diff_noOutlier$gm_csf) >= 0.5 |
           abs(corr_results_metabs_immuno_diff_noOutlier$total_lyc) >= 0.5)
```

## Lycsoy metab list Corr
These are correlations based on significant metabolites with FDR < 0.05 AND FC > 1.51 (from lyc/soy effect list) against immuno outcomes that were significant (padj < 0.05) when comparing pre to post red intervention.

```{r}
# add subject and intervention back to df. Select only significant metabolites (pval > 0.05 and FC >=1.51) that are in lyc/soy effect list
lyc_soy_forcorr_diff_metabslog2_immuno_noOutlier <- forcorr_diff_metabslog2_immuno_noOutlier %>%
  mutate(Subject = forcorr_post_metabslog2_immuno_noOutlier$Subject,
         Intervention = forcorr_post_metabslog2_immuno_noOutlier$Intervention) %>%
  dplyr::select(Subject, Intervention, 
                il_5, il_12p70, gm_csf, 
                total_lyc, all_of(sigmetabs_lycsoy_effect$Feature_ID))

# correlation table
lycsoy_corr_results_metabs_immuno_diff_noOutlier <- lyc_soy_forcorr_diff_metabslog2_immuno_noOutlier %>% 
  correlate(method = "spearman") %>%
  rearrange() %>%
  shave()

kable(lycsoy_corr_results_metabs_immuno_diff_noOutlier, format = "markdown", digits = 3)
```

```{r}
write_csv(lycsoy_corr_results_metabs_immuno_diff_noOutlier, "lyc_soy_fx_corr_prepostRed.csv")
```


Look for strongly correlated outcomes. R^2 >= to 0.5
```{r}
lycsoy_sigcorr_metabsP05_FC1.6_immunodata <- lycsoy_corr_results_metabs_immuno_diff_noOutlier %>%
  dplyr::select(term, il_5, il_12p70, gm_csf, total_lyc) %>%
  filter(abs(lycsoy_corr_results_metabs_immuno_diff_noOutlier$il_5) >= 0.5 |
           abs(lycsoy_corr_results_metabs_immuno_diff_noOutlier$il_12p70) >= 0.5 |
           abs(lycsoy_corr_results_metabs_immuno_diff_noOutlier$gm_csf) >= 0.5 |
           abs(lycsoy_corr_results_metabs_immuno_diff_noOutlier$total_lyc) >= 0.5)

 kable(lycsoy_red_sigcorr_metabsP05_FC1.6_immunodata, digits = 3, caption = "sig metabolites in lyc/soy effect list and sig immuno outcomes with strong correlations. R^2 >= to 0.5. Based on Pre vs. post-red log2fc")
```



### plot

```{r, fig.height=45, fig.width=40, fig.asp=1}
lycsoy_ggcorr_noOutlier <- round(cor(lyc_soy_forcorr_diff_metabslog2_immuno_noOutlier[,-c(1:2)], method = "spearman"), digits = 2)

p.mat.lycsoy <- cor_pmat(lycsoy_ggcorr_noOutlier, method = "spearman")

(lyc_soy_immuno_metabs_ggcorrplot <- lycsoy_ggcorr_noOutlier %>%
  ggcorrplot(lab = TRUE, 
             outline.color = "white", type = "full", hc.order = T,
             ggtheme = ggthemes::theme_clean(base_size = 8, base_family = "sans"),
             colors = c("#6D9EC1", "white", "#E46726"),
             p.mat = p.mat.lycsoy,
             sig.level = 0.05,
             insig = "blank") +
  theme(axis.text.x = element_text(angle = 90, size = 12),
        axis.text.y = element_text(size = 12)))
```

Export corplot
```{r, eval=FALSE}
ggsave(plot = lyc_soy_immuno_metabs_ggcorrplot,
       filename = "plots and figures/prepostRedFC-C18-Neg-lycsoy-Metabs-and-immunology-corrplot.svg",
       width = 45,
       height = 40,
       scale = 1)
```


```{r, fig.height=20, fig.width=25, fig.asp=1}
corrplot(lycsoy_ggcorr_noOutlier, order = 'hclust', type = "upper", method = "ellipse")
```


```{r, fig.height=25, fig.width=25, fig.asp=1}
corrplot(lycsoy_ggcorr_noOutlier, order = 'hclust', method = "square", addrect = 2, p.mat = p.mat.lycsoy, insig = "blank", sig.level = c(0.05, 0.01, 0.001))
```

# Scatter plots

## OH-ODMA glucuronide

```{r}
forcorr_diff_allmetabs_immuno_noOutlier %>%
  ggplot(aes(x = il_12p70,
             y = `6-OH-O-DMA glucuronide`)) +
  geom_point(aes(color = factor(Intervention, 
                               levels = c("Yellow",
                                          "Red")))) +
  geom_point(color = "black", shape = 1) +
  stat_correlation(use_label(c("R", "P")), method = "spearman") +
  stat_poly_line() +
  scale_color_manual(values = c("yellow2",
                                "darkred")) +
  labs(title = "Metabolite LFC vs. Cytokine LFC",
       color = "Intervention") +
  theme_bw() 
```


```{r}
forcorr_diff_allmetabs_immuno_noOutlier %>%
  ggplot(aes(x = il_5,
             y = `6-OH-O-DMA glucuronide`)) +
  geom_point(aes(color = factor(Intervention, 
                               levels = c("Yellow",
                                          "Red")))) +
  geom_point(color = "black", shape = 1) +
  stat_correlation(use_label(c("R", "P")), method = "spearman") +
  stat_poly_line() +
  scale_color_manual(values = c("yellow2",
                                "darkred")) +
  labs(title = "Metabolite LFC vs. Cytokine LFC",
       color = "Intervention") +
  theme_bw() 
```

## Daidzein

```{r}
forcorr_diff_allmetabs_immuno_noOutlier %>%
  ggplot(aes(x = il_5,
             y = Daidzein)) +
  geom_point(aes(color = factor(Intervention, 
                               levels = c("Yellow",
                                          "Red")))) +
  geom_point(color = "black", shape = 1) +
  stat_correlation(use_label(c("R", "P")), method = "spearman") +
  stat_poly_line() +
  scale_color_manual(values = c("yellow2",
                                "darkred")) +
  labs(title = "Metabolite LFC vs. Cytokine LFC",
       color = "Intervention") +
  theme_bw() 
```


## ODMA glucuronide isomer 1

```{r}
forcorr_diff_allmetabs_immuno_noOutlier %>%
  ggplot(aes(x = il_12p70,
             y = `O-DMA glucuronide isomer 1`)) +
  geom_point(aes(color = factor(Intervention, 
                               levels = c("Yellow",
                                          "Red")))) +
  geom_point(color = "black", shape = 1) +
  stat_correlation(use_label(c("R", "P")), method = "spearman") +
  stat_poly_line() +
  scale_color_manual(values = c("yellow2",
                                "darkred")) +
  labs(title = "Metabolite LFC vs. Cytokine LFC",
       color = "Intervention") +
  theme_bw() 
```


```{r}
forcorr_metabslog2_immuno_noOutlier %>%
  ggplot(aes(x = il_12p70,
                 y = `O-DMA glucuronide isomer 1`)) +
  geom_point(aes(color = factor(pre_post_intervention, 
                               levels = c("pre_Yellow",
                                          "post_Yellow",
                                          "pre_Red",
                                          "post_Red")))) +
  geom_point(color = "black", shape = 1) +
  stat_correlation(use_label(c("R", "P")), method = "spearman") +
  stat_poly_line() +
  scale_color_manual(values = c("lemonchiffon1", "yellow2",
                                  "rosybrown2", "darkred")) +
  labs(color = "Timepoint") +
  theme_bw() 
```

## total lyc

```{r}
forcorr_diff_allmetabs_immuno_noOutlier %>%
  ggplot(aes(x = il_12p70,
             y = total_lyc)) +
  geom_point(aes(color = factor(Intervention, 
                               levels = c("Yellow",
                                          "Red")))) +
  geom_point(color = "black", shape = 1) +
  stat_correlation(use_label(c("R", "P")), method = "spearman") +
  stat_poly_line() +
  scale_color_manual(values = c("yellow2",
                                "darkred")) +
  labs(title = "Metabolite LFC vs. Cytokine LFC",
       color = "Intervention") +
  theme_bw() 
```


```{r}
forcorr_metabslog2_immuno_noOutlier %>%
  ggplot(aes(x = il_12p70,
                 y = total_lyc)) +
  geom_point(aes(color = factor(pre_post_intervention, 
                               levels = c("pre_Yellow",
                                          "post_Yellow",
                                          "pre_Red",
                                          "post_Red")))) +
  geom_point(color = "black", shape = 1) +
  stat_correlation(use_label(c("R", "P")), method = "spearman") +
  stat_poly_line() +
  scale_color_manual(values = c("lemonchiffon1", "yellow2",
                                  "rosybrown2", "darkred")) +
  labs(color = "Timepoint") +
  theme_bw() 
```

```{r}
forcorr_metabslog2_immuno_noOutlier %>%
  ggplot(aes(x = il_5,
                 y = total_lyc)) +
  geom_point(aes(color = factor(pre_post_intervention, 
                               levels = c("pre_Yellow",
                                          "post_Yellow",
                                          "pre_Red",
                                          "post_Red")))) +
  geom_point(color = "black", shape = 1) +
  stat_correlation(use_label(c("R", "P")), method = "spearman") +
  stat_poly_line() +
  scale_color_manual(values = c("lemonchiffon1", "yellow2",
                                  "rosybrown2", "darkred")) +
  labs(color = "Timepoint") +
  theme_bw() 
```

export a df for isoflavones analysis
```{r}
write_csv(imp_metabind_clust_log2_noQCs, file = "meta_omics_noQCs.csv")
```

