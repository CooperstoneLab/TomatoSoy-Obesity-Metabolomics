---
title: "Metabolomics Data analysis"
subtitle: "Urine, C18 (-) LCMS"
author: "Maria Sholola"
date: '2023-06-05'
output: github_document
---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo=TRUE) 
```

# Load libraries
```{r, warning = FALSE, message = FALSE}
library(tidyverse) # for everything
library(readxl) # for reading in excel files
library(janitor) # data checks and cleaning
library(glue) # for easy pasting
library(FactoMineR) # for PCA
library(factoextra) # for PCA
library(rstatix) # for stats
library(pheatmap) # for heatmaps
library(plotly) # for interactive plots
library(htmlwidgets) # for saving interactive plots
library(devtools)
library(notame) # used for feature clustering
library(doParallel)
library(igraph) # feature clustering
library(ggpubr) # visualizations
library(knitr) # clean table printing
library(rmarkdown)
library(mixOmics) # for multilevel PCAs
library(corrr)
library(ggthemes)
library(ggtext)
library(PCAtools)
```

# Read in data
```{r}
# raw filtered metabolomics data in C18 (-)
omicsdata <- read_csv("Feature lists/C18Neg-Data-Filtered-in-R.csv")

# metadata
metadata <- read_excel("Metadata-urine-c18neg.xlsx")
```

# Wrangle data

```{r}
metadata <- metadata %>%
  rename("sample_ID" = Sample_ID)
```


```{r}
# rename "row ID"
omicsdata <- omicsdata %>%
  rename("row_ID" = `row ID`)

# how many features
nrow(omicsdata)

# are there any duplicates?
omicsdata %>% get_dupes(mz_rt)

```

```{r}
# remove dupes
omicsdata <- omicsdata %>% 
  distinct(mz_rt, .keep_all = TRUE)

# check again for dupes
omicsdata %>% get_dupes(mz_rt)

# how many features
nrow(omicsdata)
```


Sometimes a weird logical column (lgl) comes up in my data. Let's check if it's there

```{r}
colnames(omicsdata)
```


```{r}
# remove weird lgl column
omicsdata <- omicsdata %>%
  dplyr::select(!where(is.logical)) 

colnames(omicsdata)
```



```{r}
# create long df for omics df
omicsdata_tidy <- omicsdata %>%
  pivot_longer(cols = 3:ncol(.),
               names_to = "sample_ID",
               values_to = "peak_height")

# combine meta and omics dfs
meta_omics <- full_join(omicsdata_tidy,
                         metadata,
                         by = c("sample_ID" = "sample_ID"))

# separate mz and rt
meta_omics_sep <- meta_omics %>%
  separate(col = mz_rt,
           into = c("mz", "rt"),
           sep = "_") 

# convert columns to correct type
meta_omics_sep$mz <- as.numeric(meta_omics_sep$mz)
meta_omics_sep$rt <- as.numeric(meta_omics_sep$rt)
meta_omics_sep$Subject <- as.character(meta_omics_sep$Subject)
meta_omics_sep$Intervention <- as.character(meta_omics_sep$Intervention)

# rearrange column order
meta_omics_sep <- meta_omics_sep %>%
  dplyr::select(sample_ID, pre_post, Intervention, everything())

str(meta_omics_sep)


```


```{r}
# replace NA's in subject and intervention columns with QC
meta_omics_sep$Subject <- meta_omics_sep$Subject %>%
  replace_na("QC")

meta_omics_sep$Intervention <- meta_omics_sep$Intervention %>%
  replace_na("QC")
```


# Data summaries

## Number of masses detected
```{r}
nrow(omicsdata)
```


## Mass range for metabolites detected?

```{r}
range(meta_omics_sep$mz)
```

## RT range for metabolites detected?

```{r}
range(meta_omics_sep$rt)
```

## mass vs RT scatterplot
```{r}
# plot
(plot_mzvsrt <- meta_omics_sep %>%
  ggplot(aes(x = rt, y = mz)) +
  geom_point() +
  theme_minimal() +
  labs(x = "Retention time, min",
       y = "m/z, neutral",
       title = "mz across RT for all features"))
```

## Histogram for mass range
```{r}
meta_omics_sep %>%
  ggplot(aes(x = mz)) +
  geom_histogram(binwidth = 25) +
  theme_minimal() +
  labs(x = "Monoisotopic mass (amu)",
       y = "Number of features",
       title = "Distribution of features by mass")
```

## Histogram for RT

```{r}
meta_omics_sep %>%
  ggplot(aes(x = rt)) +
  geom_histogram(binwidth = 0.1) + # 6 second bins
  theme_minimal() +
  labs(x = "Retention time",
       y = "Number of features",
       title = "Distribution of features by retention time")
```


# NAs and imputing

## NAs

```{r}
# samples only (no QCs)
omicsdata_noQC <- omicsdata %>%
  dplyr::select(-contains("QC"))

#NAs in samples only?
NAbyRow_noQC <- rowSums(is.na(omicsdata_noQC[,-1]))

hist(NAbyRow_noQC,
     breaks = 48, # because there are 48 samples 
     xlab = "Number of missing values",
     ylab = "Number of metabolites",
     main = "How many missing values are there?")
```

Are there any missing values in QCs? There shouldn't be after data preprocessing/filtering
```{r}
omicsdata_QC <- omicsdata %>%
  dplyr::select(starts_with("P")) 

NAbyRow_QC <- colSums(is.na(omicsdata_QC))
# lets confirm that there are no missing values from my QCs
sum(NAbyRow_QC) # no
```


```{r}
# calculate how many NAs there are per feature in whole data set
contains_NAs <- meta_omics %>%
  group_by(mz_rt) %>%
  count(is.na(peak_height)) %>%
  filter(`is.na(peak_height)` == TRUE)
kable(contains_NAs)
```


## Remove NAs


## Data imputation
```{r}
# impute any missing values by replacing them with 1/2 of the lowest peak height value of a feature (i.e. in a row).
imputed_omicsdata <- omicsdata

imputed_omicsdata[] <- lapply(imputed_omicsdata, 
                              function(x) ifelse(is.na(x),
                                                 min(x, na.rm = TRUE)/2, x))

dim(imputed_omicsdata)
```

Are there any NAs?
```{r}
imputed_omicsdata %>%
  is.na() %>%
  sum()

# imputations worked
```


# Create new imputed tidy datasets
```{r}
# create long df for imputed omics df
imputed_omicsdata_tidy <- imputed_omicsdata %>%
  pivot_longer(cols = 3:ncol(.),
               names_to = "sample_ID",
               values_to = "peak_height")

# combine meta and imputed omics dfs
imp_meta_omics <- full_join(imputed_omicsdata_tidy,
                         metadata,
                         by = c("sample_ID" = "sample_ID"))

# separate mz and rt
imp_meta_omics_sep <- imp_meta_omics %>%
  separate(col = mz_rt,
           into = c("mz", "rt"),
           sep = "_") 

# convert columns to correct type
imp_meta_omics_sep$mz <- as.numeric(imp_meta_omics_sep$mz)
imp_meta_omics_sep$rt <- as.numeric(imp_meta_omics_sep$rt)
imp_meta_omics_sep$Subject <- as.character(imp_meta_omics_sep$Subject)
imp_meta_omics_sep$Intervention <- as.character(imp_meta_omics_sep$Intervention)
```


# Notame feature reduction
vignette for reference
```{r}
#browseVignettes("notame")
```

Let's look at what masses come up at each RT again

```{r}
# rt vs mz plot
imp_meta_omics_sep %>%
  ggplot(aes(x = rt, y = mz)) +
  geom_point() +
  theme_minimal() +
  labs(x = "RT (min)",
       y = "mz")
```
There are several points that are at the same RT, meaning they could be coming from the same compound. We'll run notame clustering to collapse features coming from one mass into one feature.

## Data restructuring for notame
```{r}
# create features list from imputed data set to only include unique feature ID's (mz_rt), mz and RT
features <- imp_meta_omics_sep %>%
  cbind(imp_meta_omics$mz_rt) %>%
  rename("mz_rt" = "imp_meta_omics$mz_rt") %>%
  dplyr::select(c(mz_rt, mz, rt)) %>%
  distinct() # remove the duplicate rows

# create a second data frame which is just imp_meta_omics restructured to another wide format
data_notame <- data.frame(imputed_omicsdata %>%
                            dplyr::select(-row_ID) %>%
                            t())

data_notame <- data_notame %>%
  tibble::rownames_to_column() %>% # change samples from rownames to its own column
  row_to_names(row_number = 1) # change the feature IDs (mz_rt) from first row obs into column names


```

Check structures
```{r}
# check if mz and rt are numeric
str(features)
```

```{r}
# check if results are numeric
head(data_notame)

# change to results to numeric
data_notame <- data_notame %>%
  mutate_at(-1, as.numeric)

head(data_notame)
```


## Find connections
```{r}
connection <- find_connections(data = data_notame,
                               features = features,
                               corr_thresh = 0.9,
                               rt_window = 1/60,
                               name_col = "mz_rt",
                               mz_col = "mz",
                               rt_col = "rt")

head(connection)
```

## Clustering
```{r}
clusters <- find_clusters(connections = connection, d_thresh = 0.8)
```

```{r}
# assign a cluster ID to all features. Clusters are named after feature with highest median peak height
features_clustered <- assign_cluster_id(data_notame, clusters, features, name_col = "mz_rt")

# lets see how many features are removed when we only keep one feature per cluster
pulled <- pull_clusters(data_notame, features_clustered, name_col = "mz_rt")
cluster_data <- pulled$cdata
cluster_features <- pulled$cfeatures

# how much did we trim our data down by?
nrow(omicsdata) - nrow(cluster_features)

```


```{r}
# export clustered feature list
write_csv(cluster_features,
          "Feature lists/c18neg-clustered-features.csv")

```


## Reduce dataset based on clustering
 
```{r}
# transpose the full dataset back to wide so that it is more similar to the notame dataset
imp_meta_omics_wide <- imp_meta_omics %>%
  dplyr::select(-"row_ID") %>%
  pivot_wider(names_from = mz_rt,
              values_from = peak_height)

# list of reduced features
clusternames <- cluster_features$mz_rt

# select only the features are in the reduced list
imp_clust <- imp_meta_omics_wide[,c(names(imp_meta_omics_wide) %in% clusternames)]

# bind back sample names
imp_clust <- cbind(imp_meta_omics_wide[1], imp_clust)

tibble(imp_clust)

```

## New mz vs rt plot

Let's see how our clustered data looks now compared to the original

```{r}
# plot new rt vs mz scatterplot post-clustering
(plot_mzvsrt_postcluster <- cluster_features %>%
  ggplot(aes(x = rt,
             y = mz)) +
  geom_point() +
  theme_minimal() +
  labs(x = "Retention time, min",
       y = "m/z, neutral",
       title = "mz across RT for all features after clustering"))


```


```{r, fig.height=10, fig.asp=1}
# plot both scatterplots to compare with and without notame clustering
(scatterplots <- ggarrange(plot_mzvsrt, 
                           plot_mzvsrt_postcluster, 
                           nrow = 2))
```

There are still some features that line up, but the clustered data looks much better.

# Wrangle new data

```{r}
# bind back new clustered data with metadata
imp_metabind_clust <- right_join(metadata, 
                                 imp_clust,
                                 by = "sample_ID")
```

# Visualize untransformed data

## More wrangling
```{r}
# change meta data columns to character so that I can change NAs from QCs to "QC"
imp_metabind_clust <- imp_metabind_clust %>%
  mutate_at(c("Subject",
              "Period",
              "Intervention",
              "pre_post",
              "sequence",
              "Intervention_week",
              "Sex",
              "Age",
              "BMI"),
            as.character) 

# replace NAs in metadata columns for QCs
imp_metabind_clust[is.na(imp_metabind_clust)] <- "QC"

# unite pre_post column with intervention column to create pre_intervention column
imp_metabind_clust <- imp_metabind_clust %>%
  unite(col = "pre_post_intervention",
        c("pre_post","Intervention"),
        sep = "_",
        remove = FALSE)

# long df
imp_metabind_clust_tidy <- imp_metabind_clust %>%
  pivot_longer(cols = 12:ncol(.),
               names_to = "mz_rt",
               values_to = "rel_abund")

# structure check
str(imp_metabind_clust_tidy)
```


## Boxplot
```{r}
imp_metabind_clust_tidy %>%
  ggplot(aes(x = sample_ID, y = rel_abund, color = Intervention)) +
  geom_boxplot(alpha = 0.6) +
  scale_color_manual(values = c("light grey", "tomato1", "gold")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "LC-MS (-) Feature Abundances by Sample",
       subtitle = "Unscaled data",
       y = "Relative abundance")
```

Will need to log transform in order to normalize and actually see the data

# Log2 transform
```{r}
imp_metabind_clust_tidy_log2 <- imp_metabind_clust_tidy %>%
  mutate(rel_abund_log2 = log2(rel_abund))
```

## Boxplot
```{r}
(bp_data_quality <- imp_metabind_clust_tidy_log2 %>%
  ggplot(aes(x = sample_ID, y = rel_abund_log2, fill = Intervention)) +
  geom_boxplot(alpha = 0.6) +
  scale_fill_manual(values = c("light grey", "tomato1", "gold")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "LC-MS (-) Feature Abundances by Sample",
       subtitle = "Log2 transformed data",
       y = "Relative abundance"))
```

Much better! QCs look good.

# PCAs

## With QCS

### Wrangle

```{r}
# go back to wide data
imp_metabind_clust_log2 <- imp_metabind_clust_tidy_log2 %>%
  dplyr::select(!rel_abund) %>%
  pivot_wider(names_from = mz_rt,
              values_from = rel_abund_log2)

PCA.imp_metabind_clust_log2 <- PCA(imp_metabind_clust_log2,  # wide data
                                   quali.sup = 1:11, # remove qualitative variables
                                   graph = FALSE, # don't graph
                                   scale.unit = FALSE) # don't scale, already transformed data

# PCA summary
kable(summary(PCA.imp_metabind_clust_log2))
```

```{r}
# pull PC coordinates into df
PC_coord_QC_log2 <- as.data.frame(PCA.imp_metabind_clust_log2$ind$coord)

# bind back metadata from cols 1-10
PC_coord_QC_log2 <- bind_cols(imp_metabind_clust_log2[,1:11], PC_coord_QC_log2)

# grab some variance explained
importance_QC <- PCA.imp_metabind_clust_log2$eig

# set variance explained with PC1, round to 2 digits
PC1_withQC <- round(importance_QC[1,2], 2)

# set variance explained with PC2, round to 2 digits
PC2_withQC <- round(importance_QC[2,2], 2)
```

### Plots
Using FactoExtra package
```{r}
# scree plot
fviz_eig(PCA.imp_metabind_clust_log2)

# get eigenvalues
kable(get_eig(PCA.imp_metabind_clust_log2))
```

```{r}
# scores plot
fviz_pca_ind(PCA.imp_metabind_clust_log2)
```


### Manual scores plot

```{r}
# manual scores plot
(PCA_withQCs <- PC_coord_QC_log2 %>%
  ggplot(aes(x = Dim.1, y = Dim.2,
             fill = factor(Intervention, levels = c("Yellow", "Red", "QC")))) +
  geom_point(shape = 21, alpha = 0.8) +
  scale_fill_manual(values = c("gold", "tomato1", "light grey")) +
  scale_color_manual(values = "black") +  
  theme_minimal() +
  coord_fixed(PC2_withQC/PC1_withQC) +
  labs(x = glue::glue("PC1: {PC1_withQC}%"),
       y = glue::glue("PC2: {PC2_withQC}%"),
       fill = "Group",
       title = "Principal Components Analysis Scores Plot",
       subtitle = "Log2 transformed data"))
```

There seems to be outliers here. We'll keep investigating. Let's see how the data looks without the QCs.

## Without QCs

### Wrangle 

```{r}
imp_metabind_clust_log2_noQCs <- imp_metabind_clust_log2 %>%
  filter(Intervention != "QC")

PCA.imp_metabind_clust_log2_noQCs <- PCA(imp_metabind_clust_log2_noQCs, # wide data
                               quali.sup=1:11, # remove qualitative variables
                               graph=FALSE, # don't graph
                               scale.unit=FALSE) # don't scale, we already did this

# look at summary
kable(summary(PCA.imp_metabind_clust_log2_noQCs))
```

```{r}
# pull PC coordinates into df
PC_coord_noQCs_log2 <- as.data.frame(PCA.imp_metabind_clust_log2_noQCs$ind$coord)

# bind back metadata from cols 1-10
PC_coord_noQCs_log2 <- bind_cols(imp_metabind_clust_log2_noQCs[,1:11], PC_coord_noQCs_log2)

# grab some variance explained
importance_noQC <- PCA.imp_metabind_clust_log2_noQCs$eig

# set variance explained with PC1, round to 2 digits
PC1_noQC <- round(importance_noQC[1,2], 2)

# set variance explained with PC2, round to 2 digits
PC2_noQC <- round(importance_noQC[2,2], 2)
```

### Plots
Using FactoExtra

```{r}
# scree plot
fviz_eig(PCA.imp_metabind_clust_log2_noQCs)
```

```{r}
# scores plot
fviz_pca_ind(PCA.imp_metabind_clust_log2_noQCs)
```


### Manual scores plot

```{r}
(PCA_withoutQCs <- PC_coord_noQCs_log2 %>%
  ggplot(aes(x = Dim.1, 
             y = Dim.2,
             fill = Intervention,
             text = sample_ID)) +
    geom_point(shape = 21, alpha = 0.8) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha=0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha=0.5) +
    scale_fill_manual(values = c("gold", "tomato1")) +
    scale_color_manual(values = "black") +  
    theme_minimal() +
    coord_fixed(PC2_noQC/PC1_noQC) +
    labs(x = glue::glue("PC1: {PC1_noQC}%"),
         y = glue::glue("PC2: {PC2_noQC}%"),
         fill = "Intervention",
         title = "Principal Components Analysis Scores Plot",
         subtitle = "Log2 transformed data, without QCs"))
ggplotly(PCA_withoutQCs, tooltip = "text")
```

Interactive plot shows us that all of those visual outliers are subject 6106. Let's see what the data looks like when we remove this outlier.

## Removal of outlier

### With QCs

#### Wrangle

```{r}
# go back to wide data
imp_no6106_log2 <- imp_metabind_clust_tidy_log2 %>%
  dplyr::select(!rel_abund) %>%
  filter(Subject != 6106) %>%
  pivot_wider(names_from = mz_rt,
              values_from = rel_abund_log2)

PCA.imp_no6106_log2 <- PCA(imp_no6106_log2,  # wide data
                                   quali.sup = 1:11, # remove qualitative variables
                                   graph = FALSE, # don't graph
                                   scale.unit = FALSE) # don't scale, already transformed data

# PCA summary
kable(summary(PCA.imp_no6106_log2))
```

```{r}
# pull PC coordinates into df
PC_no6106_QC_log2 <- as.data.frame(PCA.imp_no6106_log2$ind$coord)

# bind back metadata from cols 1-11
PC_no6106_QC_log2 <- bind_cols(imp_no6106_log2[,1:11], PC_no6106_QC_log2)

# grab some variance explained
importance_no6106_QC <- PCA.imp_no6106_log2$eig

# set variance explained with PC1, round to 2 digits
PC1_no6106_withQC <- round(importance_no6106_QC[1,2], 2)

# set variance explained with PC2, round to 2 digits
PC2_no6106_withQC <- round(importance_no6106_QC[2,2], 2)
```

#### Plots
Using FactoExtra package
```{r}
# scree plot
fviz_eig(PCA.imp_no6106_log2)
```

```{r}
# scores plot
fviz_pca_ind(PCA.imp_no6106_log2)
```


#### Manual scores plot

```{r}
# manual scores plot
(PCA_no6106_withQCs <- PC_no6106_QC_log2 %>%
  ggplot(aes(x = Dim.1, y = Dim.2,
             fill = factor(Intervention, levels = c("Yellow", "Red", "QC")))) +
  geom_point(shape = 21, alpha = 0.8) +
  scale_fill_manual(values = c("gold", "tomato1", "light grey")) +
  scale_color_manual(values = "black") +  
  theme_minimal() +
  coord_fixed(PC2_no6106_withQC/PC1_no6106_withQC) +
  labs(x = glue::glue("PC1: {PC1_no6106_withQC}%"),
       y = glue::glue("PC2: {PC2_no6106_withQC}%"),
       fill = "Group",
       title = "Principal Components Analysis Scores Plot"))
```


Because of subject 6106, the pooled QC sample points are quite far from samples. 

### Without QCs

#### Wrangle
```{r}
imp_no6106_log2_noQCs <- imp_metabind_clust_log2 %>%
  filter(Intervention != "QC") %>%
  filter(Subject != "6106")

PCA.imp_no6106_log2_noQCs <- PCA(imp_no6106_log2_noQCs, # wide data
                               quali.sup=1:11, # remove qualitative variables
                               graph=FALSE, # don't graph
                               scale.unit=FALSE) # don't scale, we already did this

# look at summary
kable(summary(PCA.imp_no6106_log2_noQCs))
```

```{r}
# pull PC coordinates into df
PC_coord_no6106_noQC_log2 <- as.data.frame(PCA.imp_no6106_log2_noQCs$ind$coord)

# bind back metadata from cols 1-11
PC_coord_no6106_noQC_log2 <- bind_cols(imp_no6106_log2_noQCs[,1:11], PC_coord_no6106_noQC_log2)

# grab some variance explained
importance_no6106_noQC <- PCA.imp_no6106_log2_noQCs$eig

# set variance explained with PC1, round to 2 digits
PC1_no6106_noQC <- round(importance_no6106_noQC[1,2], 2)

# set variance explained with PC2, round to 2 digits
PC2_no6106_noQC <- round(importance_no6106_noQC[2,2], 2)
```


#### Plots
Using FactoExtra
```{r}
# scree plot
fviz_eig(PCA.imp_no6106_log2_noQCs)
```

```{r}
# scores plot
fviz_pca_ind(PCA.imp_no6106_log2_noQCs)
```


#### Manual scores plot

```{r}
(PCA_no6106_withoutQCs <- PC_coord_no6106_noQC_log2 %>%
  ggplot(aes(x = Dim.1, 
             y = Dim.2,
             fill = Intervention)) +
    geom_point(shape = 21, alpha = 0.8) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha=0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha=0.5) +
    scale_fill_manual(values = c("tomato1", "gold")) +
    scale_color_manual(values = "black") +  
    theme_minimal() +
    coord_fixed(PC2_no6106_noQC/PC1_no6106_noQC) +
    labs(x = glue::glue("PC1: {PC1_no6106_noQC}%"),
         y = glue::glue("PC2: {PC2_no6106_noQC}%"),
         fill = "Intervention",
         title = "Principal Components Analysis Scores Plot"))
ggplotly(PCA_no6106_withoutQCs)
```

Now we're seeing some separation along PC2! Let's explore this more with a pub-friendly package for PCAs, the PCAtools package.


# PCAtools

## W/ Outlier

### Data wrangling
```{r}
# create rel abund df suitable for PCAtools package
imp_clust_omicsdata_outliers_forPCAtools <- as.data.frame(t(imp_clust)) # transpose df 

names(imp_clust_omicsdata_outliers_forPCAtools) <- imp_clust_omicsdata_outliers_forPCAtools[1,] # make sample IDs column names

imp_clust_omicsdata_outliers_forPCAtools <- imp_clust_omicsdata_outliers_forPCAtools[-1,] # remove sample ID row

# create metadata df suitable for PCAtools pckg

metadata_outliers_forPCAtools <- metadata %>%
  column_to_rownames(var = "sample_ID") # change sample ID column to rownames

# create a vector so that col names in abundance df matches metadata df
order_outliers_forPCAtools <- match(rownames(metadata_outliers_forPCAtools), colnames(imp_clust_omicsdata_outliers_forPCAtools))

# reorder col names in abundance df so that it matches metadata
abundata_outliers_reordered_forPCAtools <- imp_clust_omicsdata_outliers_forPCAtools[ ,order_outliers_forPCAtools] 

# change abundance df to numeric
abundata_outliers_reordered_forPCAtools <- abundata_outliers_reordered_forPCAtools %>%
  mutate_all(as.numeric)

# Log transform
log2_abundata_outliers_forPCAtools <- log2(abundata_outliers_reordered_forPCAtools)


# unite pre_post column with intervention column to create pre_intervention column
metadata_outliers_forPCAtools <- metadata_outliers_forPCAtools %>%
  unite(col = "pre_post_intervention",
        c("pre_post","Intervention"),
        sep = "_",
        remove = FALSE)
```


### PCA

```{r, fig.width=10, fig.height=6.5, fig.asp=0.5}
# pca
p_outliers <- PCAtools::pca(log2_abundata_outliers_forPCAtools, 
         metadata = metadata_outliers_forPCAtools, 
         scale = FALSE # using scaled data already (log2 transformed)
         
)

(PCAtools_outliers <- biplot(p_outliers,
                               lab = paste0(metadata_outliers_forPCAtools$Subject),
                           colby = 'pre_post_intervention',
                           colkey = c("pre_Yellow" = "yellow",
                                      "post_Yellow" = "yellow4",
                                      "pre_Red" = "red",
                                      "post_Red" = "red4"),
                           hline = 0, vline = 0,
                           legendPosition = 'right',
                           title = "PCA Scores Plot with Loadings",
                           subtitle = "Log2 transformed data, C18 (-), without QCs but with outliers",
                           ellipse = TRUE,
                           ellipseType = 't', # assumes multivariate
                           ellipseLevel = 0.95,
                           ellipseFill = TRUE,
                           ellipseAlpha = 0.2,
                           ellipseLineSize = 0,
                           showLoadings = TRUE))

```


We see here the top 5 metabolites driving separation along PC1, which is really separation between subject 6106 and the rest of the samples. These metabolites are worth me exploring a bit more as to why subject 6106 is an outlier. Let's move on and explore the data without outliers more. Confidence ellipses were added to show that 6106 samples are statistical outliers.

## No outliers

### Data wrangling
```{r}
# create rel abund df suitable for PCAtools package

imp_clust_omicsdata_forPCAtools <- as.data.frame(t(imp_clust)) # transpose df 

names(imp_clust_omicsdata_forPCAtools) <- imp_clust_omicsdata_forPCAtools[1,] # make sample IDs column names

imp_clust_omicsdata_forPCAtools <- imp_clust_omicsdata_forPCAtools[-1,] # remove sample ID row

imp_clust_omicsdata_forPCAtools <- imp_clust_omicsdata_forPCAtools %>%
  dplyr::select(!contains("QC")) # remove QC observations


# create metadata df suitable for PCAtools pckg

metadata_forPCAtools <- metadata %>%
  column_to_rownames(var = "sample_ID") # change sample ID column to rownames

# create a vector so that col names in abundance df matches metadata df
order_forPCAtools <- match(rownames(metadata_forPCAtools), colnames(imp_clust_omicsdata_forPCAtools))

# reorder col names in abundance df so that it matches metadata
abundata_reordered_forPCAtools <- imp_clust_omicsdata_forPCAtools[ ,order_forPCAtools] 

# change abundance df to numeric
abundata_reordered_forPCAtools <- abundata_reordered_forPCAtools %>%
  mutate_all(as.numeric)

# Log transform
log2_abundata_forPCAtools <- log2(abundata_reordered_forPCAtools)

# remove 6106 subj from both df
log2_abundata_forPCAtools <- log2_abundata_forPCAtools %>%
  dplyr::select(!contains("6106"))

metadata_forPCAtools <- metadata_forPCAtools %>%
  filter(Subject != 6106)

# unite pre_post column with intervention column to create pre_intervention column
metadata_forPCAtools <- metadata_forPCAtools %>%
  unite(col = "pre_post_intervention",
        c("pre_post","Intervention"),
        sep = "_",
        remove = FALSE)

```

### Screeplot

Elbow method
```{r}
# pca
p <- PCAtools::pca(log2_abundata_forPCAtools, 
         metadata = metadata_forPCAtools, 
         scale = FALSE # using scaled data already (log2 transformed)
         
)

elbow <- findElbowPoint(p$variance)

elbow
```

```{r, fig.width=7, fig.height=7.5}
  screeplot(p,
    components = getComponents(p, 1:20),
    vline = elbow) +
    geom_label(aes(x = elbow + 1, y = 50,
      label = 'Elbow method', vjust = -3, size = 8))
```

How many PCs do we need to capture at least 80% variance?
```{r}
which(cumsum(p$variance) > 80)[1]
```

This shows we'd need quite a few PCs to capture most of the variance. Let's move on with 2 PCs and explore more later.

### PCA plots

#### w/ stats ellipses

```{r, fig.width=10, fig.height=10}
PCAtools::biplot(p,
       lab = paste0(metadata_forPCAtools$Subject),
       colby = 'pre_post_intervention',
       colkey = c("pre_Yellow" = "yellow",
                  "post_Yellow" = "yellow4",
                  "pre_Red" = "red",
                  "post_Red" = "red4"),
       hline = 0, vline = 0,
       # ellipse config
       ellipse = TRUE,
       ellipseType = 't', # assumes multivariate t-distribution
       ellipseLevel = 0.95,
       ellipseFill = TRUE,
       ellipseAlpha = 0.2,
       ellipseLineSize = 0,
       xlim = c(-80,80), ylim = c(-40,40),
       legendPosition = 'right',
       title = "PCA Scores Plot",
       subtitle = "Log2 transformed data, C18 (-), outliers removed, no QCs \n95% confidence level ellipses")

```

With confidence intervals (Hotelling's t), most samples are within the intervals except for a few that are not far off. We will move forward.

#### w/ loadings
Let's look at the metabolites driving
```{r, fig.width=8.5, fig.height=6.5}
(PCA.colby.prevspost <- biplot(p,
                               lab = NULL,
                           # or lab = paste0(metadata_forPCAtools$Subject),
                           colby = 'pre_post_intervention',
                           colkey = c("pre_Yellow" = "yellow",
                                      "post_Yellow" = "yellow4",
                                      "pre_Red" = "red",
                                      "post_Red" = "red4"),
                           hline = 0, vline = 0,
                           legendPosition = 'right',
                           title = "PCA Scores Plot",
                           subtitle = "Log2 transformed data, C18 (-), without QCs and outliers",
                           ylim = c(-45,45),
                           showLoadings = TRUE))


```

Feature 201.0228 at RT 4.555 drives the most separation along PC2 according to this PCA.

### Pairs plots

Here, we will look at separations for several components at once using pairs plots.

#### post-intervention comparisons
```{r, fig.width=10, fig.height=10}
(PCA_pairsplot.prevspost <-
  pairsplot(p,
    components = getComponents(p, c(1:10)),
    triangle = TRUE, trianglelabSize = 12,
    hline = 0, vline = 0,
    pointSize = 0.4,
    gridlines.major = FALSE, gridlines.minor = FALSE,
    colby = 'pre_post_intervention', 
    colkey = c("pre_Yellow" = "yellow",
               "post_Yellow" = "yellow4",
               "pre_Red" = "pink",
               "post_Red" = "red4"),
    title = 'Pairs plot', plotaxes = FALSE,
    margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm')))

```

#### sex?
Are there any obvious clusterings when colored by sex?

```{r, fig.width=10, fig.height=10}
  pairsplot(p,
    components = getComponents(p, c(1:10)),
    triangle = TRUE, trianglelabSize = 12,
    hline = 0, vline = 0,
    pointSize = 0.4,
    gridlines.major = FALSE, gridlines.minor = FALSE,
    colby = 'Sex', 
    colkey = c("M" = "red",
               "F" = "purple"),
    title = 'Pairs plot', plotaxes = FALSE,
    margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm'))
```


#### sequence?

```{r, fig.width=10, fig.height=10}
  pairsplot(p,
    components = getComponents(p, c(1:10)),
    triangle = TRUE, trianglelabSize = 12,
    hline = 0, vline = 0,
    pointSize = 0.4,
    gridlines.major = FALSE, gridlines.minor = FALSE,
    colby = 'sequence',
    title = 'Pairs plot', plotaxes = FALSE,
    margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm'))
```

## Eigen corplots

This is a cool way to explore the correlations between the metadata and the PCs! I want to look at how the metavariables correlate with PCs that account for 80% variation in the dataset. 

Again: How many PCs do we need to capture at least 80% variance?
```{r}
which(cumsum(p$variance) > 80)[1]
```

```{r, fig.width=12, fig.height=7.5}
  eigencorplot(p,
    components = getComponents(p, 1:which(cumsum(p$variance) > 80)[1]), # get components that account for 80% variance
    metavars = colnames(metadata_forPCAtools),
    col = c('darkblue', 'blue2', 'gray', 'red2', 'darkred'),
    cexCorval = 0.7,
    colCorval = 'white',
    fontCorval = 2,
    posLab = 'bottomleft',
    rotLabX = 45,
    posColKey = 'top',
    cexLabColKey = 1.5,
    scale = TRUE,
    main = 'PC1-15 metadata correlations',
    colFrame = 'white',
    plotRsquared = FALSE)
```


```{r, fig.width=14, fig.height=7.5}
  eigencorplot(p,
    components = getComponents(p, 1:which(cumsum(p$variance) > 80)[1]),
    metavars = colnames(metadata_forPCAtools),
    col = c('white', 'cornsilk1', 'gold', 'forestgreen', 'darkgreen'),
    cexCorval = 1.2,
    fontCorval = 2,
    posLab = 'all',
    rotLabX = 45,
    scale = TRUE,
    main = bquote(Principal ~ component ~ Pearson ~ r^2 ~ metadata ~ correlates),
    plotRsquared = TRUE,
    corFUN = 'pearson',
    corUSE = 'pairwise.complete.obs',
    corMultipleTestCorrection = 'BH',
    signifSymbols = c('****', '***', '**', '*', ''),
    signifCutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 1))
```


I am most interested in PCs affected by pre_post_intervention, so I think it would be good to investigate the metabolites that contribute the most to these PCs.



# Multilevel PCA

Because this is a crossover trial, measurements are taken from the same person repeatedly and thus introduces variance not dependent on the treatment but the subject. To account for interindividual variations in MVA, I try multilevel PCAs from the mixOmics package. Here, I do not remove subject 6106.

```{r}
library(mixOmics)
```


```{r}
# make df suitable for mixOmics
Data_forMPCA <- imp_metabind_clust_log2_noQCs %>%
  mutate_at("Subject", as.factor) # change subject id to factor
 

summary(as.factor(Data_forMPCA$Subject))

# make a vector for meta variables
(metavar <- Data_forMPCA[,c(1:11)] %>%
    colnames())
```

## Regular scores plot
```{r}
mixOmicsPCA.result <- mixOmics::pca(Data_forMPCA[,!names(Data_forMPCA) %in% metavar],
                            scale = FALSE,
                            center = FALSE)

plotIndiv(mixOmicsPCA.result, 
          ind.names = Data_forMPCA$Subject, 
          group = Data_forMPCA$pre_post_intervention, 
          legend = TRUE, 
          legend.title = "Treatment", 
          title = 'Regular PCA, C18 (-), Log2 transformed')

```

We see the same thing we've been seeing with 6106 overwhelming PC2. Let's try the multilevel pca and see what happens!

## Multilevel scores plot

```{r}
multilevelPCA.result <- mixOmics::pca(Data_forMPCA[,-(c(1:11))], 
                            multilevel = Data_forMPCA$Subject,
                            scale = FALSE,
                            center = FALSE)

plotIndiv(multilevelPCA.result, 
          ind.names = Data_forMPCA$Subject, 
          group = Data_forMPCA$pre_post_intervention, 
          legend = TRUE, 
          legend.title = "Treatment", 
          title = 'Multilevel PCA, C18 (-), Log2 transformed')

```

Now, even with 6106 still included, we see clear separation between post-Red and other timepoints! Let's take a look at a loadings plot to see the top 40 features that contribute to PC1 separation.

### Loadings 
```{r, fig.width=12, fig.height=12}
plotLoadings(multilevelPCA.result, ndisplay = 40)
```

Feature 201.0228 still is the top driver of separation. More digging into PCA/MVA to come!

# Univariate analysis

## Wrangle data
```{r}
# use tidy data 
head(imp_metabind_clust_tidy_log2)

# remove QCs
df_for_stats <- imp_metabind_clust_tidy_log2 %>%
  filter(Intervention != "QC")

# check if QCs were removed
unique(df_for_stats$Intervention)
```

```{r}
# df without outlier 6106
df_for_stats_noOutlier <- df_for_stats %>%
  filter(Subject != "6106")

# check if outlier was removed
unique(df_for_stats_noOutlier$Subject)
```

```{r}
# turn off sci notation outputs
options(scipen = 999)
```


## Parametric tests

### Paired t tests

Here, I am comparing pre- to post-intervention for both yellow and tomato soy (Red) juice interventions. I also compare post-yellow to post-red intervention. I am using the log transformed values of rel abundance since parametric tests assume normality.

#### Ctrl
```{r}
# run paired t-tests for control intervention
ctrl_t.test_paired <- df_for_stats %>%
  filter(Intervention == "Yellow") %>%
  dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
ctrl_t.test_paired_sig <- ctrl_t.test_paired %>%
  filter(p <= 0.05)
kable(ctrl_t.test_paired_sig)

# how many are significant?
nrow(ctrl_t.test_paired_sig)
```


#### Ctrl - no outlier
```{r}
# run paired t-tests for control intervention
ctrl_noOutlier_t.test_paired <- df_for_stats_noOutlier %>%
  filter(Intervention == "Yellow") %>%
  dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
ctrl_noOutlier_t.test_paired_sig <- ctrl_noOutlier_t.test_paired %>%
  filter(p <= 0.05)
kable(ctrl_noOutlier_t.test_paired_sig)

# how many are significant?
nrow(ctrl_noOutlier_t.test_paired_sig)
```

##### Mummichog list
```{r}
yel_for_mummichog <- ctrl_noOutlier_t.test_paired %>%
  dplyr::select(mz_rt,
         p,
         statistic) %>%
  separate(col = mz_rt,
           into = c("m/z", "rt"),
           sep = "_") %>%
  rename("p-value" = "p") %>%
  rename("t-score" = "statistic")

write_csv(yel_for_mummichog,
          "yelcomp-mummichog-list-c18neg.csv")

```

#### Red
```{r}
# run paired t-tests for control intervention
red_t.test_paired <- df_for_stats %>%
  filter(Intervention == "Red") %>%
  dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
red_t.test_paired_sig <- red_t.test_paired %>%
  filter(p <= 0.05)
kable(red_t.test_paired_sig)

# how many are significant?
nrow(red_t.test_paired_sig)
```


#### Red Without outlier
```{r}
# run paired t-tests for control intervention
red_noOutlier_t.test_paired <- df_for_stats_noOutlier %>%
  filter(Intervention == "Red") %>%
  dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
red_noOutlier_t.test_paired_sig <- red_noOutlier_t.test_paired %>%
  filter(p <= 0.05)
kable(red_noOutlier_t.test_paired_sig)

# how many are significant?
nrow(red_noOutlier_t.test_paired_sig)
```


##### Mummichog export
```{r}
red_for_mummichog <- red_noOutlier_t.test_paired %>%
  dplyr::select(mz_rt,
         p,
         statistic) %>%
  separate(col = mz_rt,
           into = c("m/z", "rt"),
           sep = "_") %>%
  rename("p-value" = "p") %>%
  rename("t-score" = "statistic")

write_csv(red_for_mummichog,
          "redcomp-mummichog-list-c18neg.csv")

```

#### Post-red vs post-yellow

```{r}
# run paired t-tests for post interventions
post_t.test_paired <- df_for_stats %>%
  filter(pre_post == "post") %>%
  dplyr::select(Subject, Intervention, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ Intervention, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
post_t.test_paired_sig <- post_t.test_paired %>%
  filter(p <= 0.05)
kable(post_t.test_paired_sig)

# how many are significant?
nrow(post_t.test_paired_sig)
```

#### Post-red vs post-yellow Without Outlier

```{r}
# run paired t-tests for post interventions
post_noOutlier_t.test_paired <- df_for_stats %>%
  filter(pre_post == "post",
         Subject != "6106") %>%
  dplyr::select(Subject, Intervention, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ Intervention, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
post_noOutlier_t.test_paired_sig <- post_noOutlier_t.test_paired %>%
  filter(p <= 0.05)
kable(post_noOutlier_t.test_paired_sig)

# how many are significant?
nrow(post_noOutlier_t.test_paired_sig)
```

##### Mummichog export

```{r}
postcomp_for_mummichog <- post_noOutlier_t.test_paired %>%
  dplyr::select(mz_rt,
         p,
         statistic) %>%
  separate(col = mz_rt,
           into = c("m.z", "r.t"),
           sep = "_") %>%
  rename("p.value" = "p") %>%
  rename("t.score" = "statistic")

write_csv(postcomp_for_mummichog,
          "post-comp-mummichog-list-c18neg.csv")


```

#### Outlier comparison
Are there any significant features shared between tests with and without outlier?

```{r}
# return sig features present only in df with outlier, and not in df without outlier
kable(anti_join(post_noOutlier_t.test_paired_sig,
          post_t.test_paired_sig,
          by = "mz_rt"))

nrow(anti_join(post_noOutlier_t.test_paired_sig,
          post_t.test_paired_sig,
          by = "mz_rt"))

# return sig features from df with no outlier that are also present in df with outlier
kable(semi_join(post_noOutlier_t.test_paired_sig,
          post_t.test_paired_sig,
          by = "mz_rt"))

nrow(semi_join(post_noOutlier_t.test_paired_sig,
          post_t.test_paired_sig,
          by = "mz_rt"))
```


### Standard comparisons

Here, I want to only focus on the metabolites that I hypothesized to change. This way I can avoid multiple correction adjustments and see if I can capture any significant differences at different timepoints

#### Wrangle

```{r}
stds_df_for_stats_wide <- df_for_stats %>%
  dplyr::select(!rel_abund) %>%
  pivot_wider(names_from = mz_rt,
              values_from = rel_abund_log2) %>%
  dplyr::select(c(1:11),
                "178.0515_3.479", #hippuric acid
                "179.0556_0.643", #glucose
                "154.0621_0.609", #histidine
                "191.0203_0.697", #citric acid
                "212.0027_3.304", #indoxyl sulfate
                "253.0503_5.048", #daidzein
                "257.0816_6.056" #O-DMA
                ) 

# make tidy df
stds_df_forstats_tidy <- stds_df_for_stats_wide %>%
  pivot_longer(cols = 12:ncol(.),
               names_to = "mz_rt",
               values_to = "rel_abund_log2")
```


```{r}
# changing factor levels for pre_post_intervention
stds_df_forstats_tidy$pre_post_intervention <- factor(stds_df_forstats_tidy$pre_post_intervention,
                              levels = c("pre_Yellow", "post_Yellow", "pre_Red", "post_Red"))

levels(stds_df_forstats_tidy$pre_post_intervention)  
```


#### Boxplots
```{r, fig.width=12}
stds_df_forstats_tidy %>% 
  ggplot(aes(x = pre_post_intervention, y = rel_abund_log2, fill = Intervention)) +
  geom_boxplot(outlier.shape = NA) +
  scale_fill_manual(values = c("Yellow" = "gold",
                                           "Red" = "tomato1")) +
  geom_line(aes(group = Subject), colour = "purple", linewidth = 0.2) +
  facet_wrap(vars(mz_rt), scales = "free_y") + 
  theme_bw() 
```

#### Control t-test
```{r}
# run paired t-tests for before vs. aftet control intervention
stds_ctrl_t.test_paired <- stds_df_forstats_tidy %>%
  filter(Intervention == "Yellow") %>%
  dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  filter(Subject != 6106) %>% # remove outliers
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE) %>% 
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
stds_ctrl_t.test_paired_sig <- stds_ctrl_t.test_paired %>%
  filter(p <= 0.05)
tibble(stds_ctrl_t.test_paired_sig)

# how many are significant?
nrow(stds_ctrl_t.test_paired_sig)
```

#### Red t-tests
```{r}
# run paired t-tests for before vs. after red intervention
stds_red_t.test_paired <- stds_df_forstats_tidy %>%
  filter(Intervention == "Red") %>%
  dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  filter(Subject != 6106) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE) %>% 
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
stds_red_t.test_paired_sig <- stds_red_t.test_paired %>%
  filter(p <= 0.05)
tibble(stds_red_t.test_paired_sig)

# how many are significant?
nrow(stds_red_t.test_paired_sig)
```

#### Intervention t-tests

```{r}
# run paired t-tests for post-red vs. post-control intervention
stds_post_t.test_paired <- stds_df_forstats_tidy %>%
  filter(pre_post == "post") %>%
  dplyr::select(Subject, pre_post_intervention, mz_rt, rel_abund_log2) %>%
  filter(Subject != 6106) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post_intervention, 
         paired = TRUE) %>% 
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
stds_post_t.test_paired_sig <- stds_post_t.test_paired %>%
  filter(p <= 0.05)
tibble(stds_post_t.test_paired_sig)

# how many are significant?
nrow(stds_post_t.test_paired_sig)
```

### Volcano plots

#### Post-intervention comparisons 

##### Wrangle (no outlier)
```{r}
# calculate mean rel abund (not log) by sample, and avg fold change (FC) diff by feature
red_v_yel_volcano_data_noOutlier <- df_for_stats %>%
  filter(pre_post == "post",
         Subject != 6106) %>% # remove outlier subj
  group_by(Intervention, mz_rt) %>%
  summarize(mean_rel_abund = mean(rel_abund)) %>%
  pivot_wider(names_from = Intervention, values_from = mean_rel_abund) %>%
  mutate(FC_postRed_div_postYellow = Red/Yellow) 

# bind back pval
red_v_yel_tobind_noOutlier <- post_noOutlier_t.test_paired %>%
  dplyr::select(p)

# calculate log2FC, and -log10p
red_v_yel_volcano_data_noOutlier <- 
  bind_cols(red_v_yel_volcano_data_noOutlier, red_v_yel_tobind_noOutlier) %>%
  mutate(log2_FC_postRed_div_postYellow = if_else(FC_postRed_div_postYellow > 0,
                                                  log2(FC_postRed_div_postYellow),
                                                  -(log2(abs(FC_postRed_div_postYellow)))), 
         neglog10p = -log10(p))


# create a df of features passing FC and pval cutoffs higher in post-Red
postRed_sig_red_v_yel_volcano_noOutlier <- red_v_yel_volcano_data_noOutlier %>%
  filter(p <= 0.05 & log2_FC_postRed_div_postYellow >= 0.6)

# create a df of features passing FC and pval cutoffs higher in post-control
postYellow_sig_red_v_yel_volcano_noOutlier <- red_v_yel_volcano_data_noOutlier %>%
  filter(p <= 0.05 & log2_FC_postRed_div_postYellow <= -0.6)  
```

##### Export sig features

Create feature lists with significant features along with their clusters
```{r}
#post-Red list
postRed_sig_intrvntn_comp_clusters <- left_join(postRed_sig_red_v_yel_volcano_noOutlier, cluster_features,
                                               by = "mz_rt")

write_csv(postRed_sig_intrvntn_comp_clusters,
          "Feature lists/postRed-sigfeatures-intervntn-comp.csv")

#post-Yellow list
postYellow_sig_intrvntn_comp_clusters <- left_join(postYellow_sig_red_v_yel_volcano_noOutlier, cluster_features,
                                               by = "mz_rt")

write_csv(postYellow_sig_intrvntn_comp_clusters,
          "Feature lists/postYellow-sigfeatures-intervntn-comp.csv")
```


##### Plot
```{r}
(red_v_yellow_volcano_noOutlier <- red_v_yel_volcano_data_noOutlier %>%
  ggplot(aes(x = log2_FC_postRed_div_postYellow, y = neglog10p, 
             text = glue("Mass_retention time: {mz_rt}
                         P-value: {p}
                         Fold change tomato/control: {round(FC_postRed_div_postYellow, 2)}"))) +
  geom_point(color = "grey") +
  geom_point(data = postRed_sig_intrvntn_comp_clusters, 
             aes(x = log2_FC_postRed_div_postYellow, y = neglog10p),
             color = "tomato") +
  geom_point(data = postYellow_sig_intrvntn_comp_clusters, 
             aes(x = log2_FC_postRed_div_postYellow, y = neglog10p),
             color = "yellow2") +
  geom_vline(xintercept = 0.6, linetype = "dashed", color = "grey") +
  geom_vline(xintercept = -0.6, linetype = "dashed", color = "grey") +
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "grey") +
  coord_cartesian(xlim = c(-5, 8)) +
  labs(title = "Volcano Plot of Features Different in People After Tomato-Soy and Control Juice Consumption",
       subtitle = "Red points are higher after tomato-soy juice consumption while yellow points are higher \nafter control tomato juice consumption. Subject 6106 removed",
       caption = "Vertical dashed lines represent a log2 fold change > 0.6 or < -0.6, and horizontal dashed line represents an FDR corrected \np-value of 0.05.",
       x = "Log2 Fold Change (TomatoSoy/Control)",
       y = "-Log10(P-value)") +
  theme_bw() +
  theme(plot.title = element_text(size = 12, hjust = 0),
        plot.caption = element_text(hjust = 0.5)))

(red_v_yellow_volcano_ggplotly_noOutlier <- ggplotly(red_v_yellow_volcano_noOutlier, tooltip = "text"))
```

Save plots
```{r, eval=FALSE}
# save volcano plot
ggsave(plot = red_v_yellow_volcano_noOutlier,
       filename = "plots and figures/volcano plots/red_v_yellow_volcano_noOutlier.svg")

# save interactive volcano plot
saveWidget(widget = red_v_yellow_volcano_ggplotly_noOutlier,
           file = "plots and figures/volcano plots/interactive_redvyellow_volcano_plot_noOutlier.html")
```


#### Red

##### Wrangle (no outlier)
```{r}
# calculate mean rel abund (not log) by sample, and avg fold change (FC) diff by feature
red_volcano_data_noOutlier <- df_for_stats %>%
  filter(Intervention == "Red",
         Subject != 6106) %>%
  group_by(pre_post, mz_rt) %>%
  summarize(mean_rel_abund = mean(rel_abund)) %>%
  pivot_wider(names_from = pre_post, values_from = mean_rel_abund) %>%
  mutate(FC_post_div_pre = post/pre) 

# bind back pval
red_tobind_noOutlier <- red_noOutlier_t.test_paired %>%
  dplyr::select(p)

# calculate log2FC, and -log10p
red_volcano_data_noOutlier <- 
  bind_cols(red_volcano_data_noOutlier, red_tobind_noOutlier) %>%
  mutate(log2_FC_post_div_pre = log2(FC_post_div_pre),
         neglog10p = -log10(p))


# create a df of features passing FC and pval cutoffs higher in post-intervention compared to pre
red_pre_v_post_volcano_noOutlier <- red_volcano_data_noOutlier %>%
  filter(p <= 0.05 & abs(log2_FC_post_div_pre) >= 0.6)

```

##### Export sig features

Create feature lists with significant features along with their clusters
```{r}
red_sig_prepost_comp_clusters <- left_join(red_pre_v_post_volcano_noOutlier, cluster_features,
                                               by = "mz_rt")

write_csv(red_sig_prepost_comp_clusters,
          "Feature lists/Red-sigfeatures-PrevsPost-noOutliers.csv")

```


##### Plot
```{r}
(red_volcano_noOutlier <- red_volcano_data_noOutlier %>%
  ggplot(aes(x = log2_FC_post_div_pre, y = neglog10p, 
             text = glue("Mass_retention time: {mz_rt}
                         P-value: {p}
                         Fold change post/pre: {round(FC_post_div_pre, 2)}"))) +
  geom_point(color = "grey") +
  geom_point(data = red_sig_prepost_comp_clusters, 
             aes(x = log2_FC_post_div_pre, y = neglog10p),
             color = "tomato") +
  geom_vline(xintercept = 0.6, linetype = "dashed", color = "grey") +
  geom_vline(xintercept = -0.6, linetype = "dashed", color = "grey") + 
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "grey") +
  coord_cartesian(xlim = c(-5, 8)) +
  labs(title = "Volcano Plot of Features Different in People After Tomato-Soy Juice Consumption",
       subtitle = "Red points are higher after tomato-soy juice consumption when compared to prior to consumption",
       caption = "Vertical dashed lines represent an abs(log fold change) > 0.6, and horizontal dashed line represents an FDR corrected \np-value of 0.05.",
       x = "Log2 Fold Change (Post/Pre)",
       y = "-Log10(P-value)") +
  theme_bw() +
  theme(plot.title = element_text(size = 12, hjust = 0),
        plot.caption = element_text(hjust = 0.5)))

(red_volcano_ggplotly_noOutlier <- ggplotly(red_volcano_noOutlier, tooltip = "text"))
```

Save plots
```{r, eval=FALSE}
# save volcano plot
ggsave(plot = red_volcano_noOutlier,
       filename = "plots and figures/volcano plots/red_volcano_noOutlier.svg")

# save interactive volcano plot
saveWidget(widget = red_volcano_ggplotly_noOutlier,
           file = "plots and figures/volcano plots/interactive_red_volcano_plot_noOutlier.html")
```

#### Yellow

##### Wrangle (no outlier)
```{r}
# calculate mean rel abund (not log) by sample, and avg fold change (FC) diff by feature
yel_volcano_data_noOutlier <- df_for_stats %>%
  filter(Intervention == "Yellow",
         Subject != 6106) %>%
  group_by(pre_post, mz_rt) %>%
  summarize(mean_rel_abund = mean(rel_abund)) %>%
  pivot_wider(names_from = pre_post, values_from = mean_rel_abund) %>%
  mutate(FC_post_div_pre = post/pre) 

# bind back pval
yel_tobind_noOutlier <- ctrl_noOutlier_t.test_paired %>%
  dplyr::select(p)

# calculate log2FC, and -log10p
yel_volcano_data_noOutlier <- 
  bind_cols(yel_volcano_data_noOutlier, yel_tobind_noOutlier) %>%
  mutate(log2_FC_post_div_pre = log2(FC_post_div_pre),
         neglog10p = -log10(p))


# create a df of features passing FC and pval cutoffs higher in post-intervention compared to pre
yel_pre_v_post_volcano_noOutlier <- yel_volcano_data_noOutlier %>%
  filter(p <= 0.05 & abs(log2_FC_post_div_pre) >= 0.6)

```

##### Export sig features

Create feature lists with significant features along with their clusters
```{r}
yel_sig_prepost_comp_clusters <- left_join(yel_pre_v_post_volcano_noOutlier, cluster_features,
                                               by = "mz_rt")

write_csv(yel_sig_prepost_comp_clusters,
          "Yellow-sigfeatures-PrevsPost-noOutliers.csv")

```

##### Plot
```{r}
(yel_volcano_noOutlier <- yel_volcano_data_noOutlier %>%
  ggplot(aes(x = log2_FC_post_div_pre, y = neglog10p, 
             text = glue("Mass_retention time: {mz_rt}
                         P-value: {p}
                         Fold change post/pre: {round(FC_post_div_pre, 2)}"))) +
  geom_point(color = "grey") +
  geom_point(data = yel_sig_prepost_comp_clusters, 
             aes(x = log2_FC_post_div_pre, y = neglog10p),
             color = "yellow2") +
  geom_vline(xintercept = 0.6, linetype = "dashed", color = "grey") +
  geom_vline(xintercept = -0.6, linetype = "dashed", color = "grey") +
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "grey") +
  coord_cartesian(xlim = c(-5, 8)) +
  labs(title = "Volcano Plot of Features Different in People After Control, Yellow Tomato Juice Consumption",
       subtitle = "Yellow points are higher after control juice consumption when compared to prior to consumption.\nSubject 6106 removed",
       caption = "Vertical dashed lines represent abs(log2 fold change) > 0.6, and horizontal dashed line represents an FDR corrected \np-value of 0.05.",
       x = "Log2 Fold Change (Post/Pre)",
       y = "-Log10(P-value)") +
  theme_bw() +
  theme(plot.title = element_text(size = 12, hjust = 0),
        plot.caption = element_text(hjust = 0.5)))

(yel_volcano_ggplotly_noOutlier <- ggplotly(yel_volcano_noOutlier, tooltip = "text"))
```

Save plots
```{r, eval=FALSE}
# save volcano plot
ggsave(plot = yel_volcano_noOutlier,
       filename = "plots and figures/volcano plots/yel_volcano_noOutlier.svg")

# save interactive volcano plot
saveWidget(widget = yel_volcano_ggplotly_noOutlier,
           file = "plots and figures/volcano plots/interactive_yel_volcano_plot_noOutlier.html")
```


## Joined lists
Here, I want to venn significant features before I begin to look more into them. I am interested in the following effects: tomato effect, lycopene and/or soy isoflavones effect. 

### Tomato effect
1. Tomato effect: join a list that only keeps features that are both significant in pre vs. post-red and pre vs. post-yellow. Manually deleted the features that don't have the same directionality

```{r}
# keep only features present in both pre vs post red and pre vs post yellow
tomato_effect <- inner_join(red_sig_prepost_comp_clusters,
                            yel_sig_prepost_comp_clusters,
                            by = "mz_rt")
dim(tomato_effect)
```

Export venned list
```{r}
write_csv(tomato_effect,
          "Feature lists/sig-features-tomato-effect.csv")
```

### Lyc/soy effect
2. lycopene and/or soy isoflavones effect: join a list that only keeps features that are:
- significantly different between post-Red and post-Yellow, 
- and significant between pre- and post-Red. 
- remove features that are significant between pre-Yellow and post-Yellow.

```{r}
# combine sig features from post-red vs post-yellow
sig_postintervention_noOutlier <- full_join(postRed_sig_intrvntn_comp_clusters,
                                               postYellow_sig_intrvntn_comp_clusters)
dim(sig_postintervention_noOutlier)

# select only sig features that are present when comparing pre-Red to post-Red
lyc_soy_effect <- inner_join(sig_postintervention_noOutlier,
                             red_sig_prepost_comp_clusters,
                             by = "mz_rt") 
dim(lyc_soy_effect)

```

Export venned list
```{r}
write_csv(lyc_soy_effect,
          "Feature lists/sig-features-lyc-soy-effect.csv")
```


### Low carotenoid tomato effect
2. yellow tomato effect: use list that only keeps features that are both significant between post-Red and post-Yellow timepoints, and significant between pre- and post-Yellow. These features are NOT significant between pre-Yellow and post-Yellow.

```{r}
# sig features from post-red vs post-yellow
dim(sig_postintervention_noOutlier)

# select only sig features that are present when comparing pre-Yellow to post-Yellow
low_carot_tomato_effect <- inner_join(sig_postintervention_noOutlier,
                             yel_sig_prepost_comp_clusters,
                             by = "mz_rt") 
dim(low_carot_tomato_effect)
```

Export venned list
```{r}
#write_csv(low_carot_tomato_effect,
          #"Feature lists/sig-features-low-carot-tomato-effect.csv")
```



# Immuno Correlations

IL-5 was significantly decreased after tomato-soy intervention (only when comparing pre to post in Red). Immune cell types were significantly altered in all 3 comparisons - so let's see how these significant immuno outcomes correlate with metabolites found to be significant at p > 0.05.

Import other outcomes (carotenoids and immunology data)
```{r}
# load data
carot_immunology_meta <- read_excel("CompiledData_Results_Meta.xlsx",
                         sheet = "metadata_corrected_withsequence")

# clean up variable names 
carot_immunology_meta <- clean_names(carot_immunology_meta)
```

## Wrangle 

```{r}
# convert variables that should be factors to factors
carot_immunology_meta <- carot_immunology_meta %>%
  filter(intervention != "Baseline") %>%
  mutate(across(.cols = c("patient_id", "period", 
                          "intervention", "intervention_week", 
                          "pre_post", "sex", "sequence"),
                .fns = as.factor))


# some stuff came in as characters but should be numeric
carot_immunology_meta <- carot_immunology_meta %>%
  mutate(across(.cols = c("il_2", "il_10", "il_13", "il_4"),
                .fns = as.numeric))



# changing factor levels for pre_post
carot_immunology_meta$pre_post <- factor(carot_immunology_meta$pre_post,
                              levels = c("pre", "post"))

levels(carot_immunology_meta$pre_post)        

# Calculate total_cis_lyc, total_lyc, and total_carotenoids
carot_immunology_meta <- carot_immunology_meta %>%
  mutate(total_cis_lyc = other_cis_lyc + x5_cis_lyc,
         total_lyc = all_trans_lyc + total_cis_lyc,
         total_carotenoids = lutein + zeaxanthin + b_cryptoxanthin + 
                             a_carotene + b_carotene + total_lyc)
```


## No outliers

```{r}
# go back to wide for stats df
df_for_stats_wide_noOutlier <- df_for_stats_noOutlier %>%
  dplyr::select(!rel_abund) %>%
  pivot_wider(names_from = mz_rt,
              values_from = rel_abund_log2)

# take outliers out of carot_immuno df 
carot_immunology_meta_noOutlier <- carot_immunology_meta %>%
  filter(patient_id != 6106)

# add immuno outcome columns to dataset
forcorr_metabslog2_immuno_noOutlier <- df_for_stats_wide_noOutlier %>%
  mutate(il_5 = carot_immunology_meta_noOutlier$il_5,
         il_12p70 = carot_immunology_meta_noOutlier$il_12p70,
         gm_csf = carot_immunology_meta_noOutlier$gm_csf,
         total_lyc = carot_immunology_meta_noOutlier$total_lyc,
         CD45ROpos_CD45RAneg_EMCD8 = carot_immunology_meta_noOutlier$x08_cd45ro_cd45ra_em_cd8,
         CD19posCD3neg_Bcells = carot_immunology_meta_noOutlier$x25_cd19_cd3_b_cells,
         CD27neg_IgDpos_naiveBcells = carot_immunology_meta_noOutlier$x26_cd27_ig_d_naive_b_cells)

# df with sig metabs
red_prepost_forcorr_metabslog2_immuno_noOutlier <- forcorr_metabslog2_immuno_noOutlier %>%
  filter(Intervention == "Red") %>%
  dplyr::select(sample_ID, Intervention, pre_post, il_5, total_lyc, CD45ROpos_CD45RAneg_EMCD8, CD19posCD3neg_Bcells, CD27neg_IgDpos_naiveBcells, all_of(red_noOutlier_t.test_paired_sig$mz_rt)) 

# correlation table
red_corr_results_metabs_immuno_noOutlier <- red_prepost_forcorr_metabslog2_immuno_noOutlier %>%  
  correlate(method = "spearman") 

kable(red_corr_results_metabs_immuno_noOutlier, format = "markdown", digits = 3)

# metabolites strongly correlated with sig. immunology outcomes. R^2 >= to 0.5
kable(red_corr_results_metabs_immuno_noOutlier %>%
  dplyr::select(term, il_5, total_lyc, CD45ROpos_CD45RAneg_EMCD8, CD19posCD3neg_Bcells, CD27neg_IgDpos_naiveBcells) %>%
  filter(abs(red_corr_results_metabs_immuno_noOutlier$il_5) >= 0.5 | abs(red_corr_results_metabs_immuno_noOutlier$total_lyc) >= 0.5 | abs(red_corr_results_metabs_immuno_noOutlier$CD45ROpos_CD45RAneg_EMCD8) >= 0.5 |
abs(red_corr_results_metabs_immuno_noOutlier$CD19posCD3neg_Bcells) >= 0.5 |
abs(red_corr_results_metabs_immuno_noOutlier$CD27neg_IgDpos_naiveBcells) >= 0.5))
```
*below are old notes prior to adding new immuno outcomes*
m/z 319 is strongly correlated with all 3 immuno outcomes. It has a positive correlation with IL-5, but a neg correlation with the b cell types. Not sure what this metabolite could be.

m/z 328 is strongly negatively correlated with the B cell types. One of the masses that come up for this in HMDB is cyclic AMP.

m/z 449 is negatively correlated with IL-5. Not sure what it is.

m/z 465 is negatively correlated with B cells (moreso naive B cells) and many hormonal metabolites come up in HMDB for this mass (e.g. testosterone and androsterone metabolites).


# Immuno Corr pt 2

Here, I am going to look at correlations between differences.

## Wrangle
No outliers

Subset df's into pre and post 
```{r}
# pre
forcorr_pre_metabslog2_immuno_noOutlier <- forcorr_metabslog2_immuno_noOutlier %>%
  dplyr::select(Subject, Intervention, pre_post, 12:941) %>%
  filter(pre_post == "pre")

# post 
forcorr_post_metabslog2_immuno_noOutlier <- forcorr_metabslog2_immuno_noOutlier %>%
  dplyr::select(Subject, Intervention, pre_post, 12:941) %>%
  filter(pre_post == "post")
```

Create df with differences calculated for each outcome
```{r}
# difference for calculated for each outcome
forcorr_diff_red_metabslog2_immuno_noOutlier <- forcorr_post_metabslog2_immuno_noOutlier[,4:933] - forcorr_pre_metabslog2_immuno_noOutlier[,4:933]

```

## Corr table
These are correlations based on significant metabolites with p value < 0.05 AND FC > 1.51 against significant immuno outcomes (p < 0.05) when comparing before and after red intervention.

```{r}
# add subject and intervention back to df. Select only significant metabolites (pval > 0.05 and FC >=1.51) that are in lyc/soy effect list
forcorr_diff_red_metabslog2_immuno_noOutlier <- forcorr_diff_red_metabslog2_immuno_noOutlier %>%
  mutate(Subject = forcorr_post_metabslog2_immuno_noOutlier$Subject,
         Intervention = forcorr_post_metabslog2_immuno_noOutlier$Intervention) %>%
  filter(Intervention == "Red") %>%
  dplyr::select(Subject, Intervention, il_5, il_12p70, gm_csf, total_lyc, CD45ROpos_CD45RAneg_EMCD8, CD19posCD3neg_Bcells, CD27neg_IgDpos_naiveBcells, all_of(lyc_soy_effect$mz_rt))

# correlation table
red_corr_results_metabs_immuno_diff_noOutlier <- forcorr_diff_red_metabslog2_immuno_noOutlier %>% 
  correlate(method = "spearman") %>%
  rearrange() %>%
  shave()

kable(red_corr_results_metabs_immuno_diff_noOutlier, format = "markdown", digits = 3)

# metabolites strongly correlated with immuno outcomes. R^2 >= to 0.5
red_sigcorr_metabsP05_FC1.6_immunodata <- red_corr_results_metabs_immuno_diff_noOutlier %>%
  dplyr::select(term, il_5, total_lyc, CD45ROpos_CD45RAneg_EMCD8, CD19posCD3neg_Bcells, CD27neg_IgDpos_naiveBcells) %>%
  filter(abs(red_corr_results_metabs_immuno_diff_noOutlier$il_5) >= 0.5 | abs(red_corr_results_metabs_immuno_noOutlier$total_lyc) >= 0.5 | abs(red_corr_results_metabs_immuno_noOutlier$CD45ROpos_CD45RAneg_EMCD8) >= 0.5 |
abs(red_corr_results_metabs_immuno_noOutlier$CD19posCD3neg_Bcells) >= 0.5 |
abs(red_corr_results_metabs_immuno_noOutlier$CD27neg_IgDpos_naiveBcells) >= 0.5)

kable(red_sigcorr_metabsP05_FC1.6_immunodata, digits = 3, caption = "sig metabolites strongly correlated with sig immuno outcomes. R^2 >= to 0.5. Pre vs. post-red")

```

### plot

```{r, fig.height=10, fig.width=8, fig.asp=2}

library(ggcorrplot)

red_corr_noOutlier <- round(cor(forcorr_diff_red_metabslog2_immuno_noOutlier[,-c(1:2)], method = "spearman"), 2)


(immuno_metabs_corrplot <- red_corr_noOutlier[, c(1:7)] %>%
  ggcorrplot(lab = TRUE, 
             outline.color = "white", 
             ggtheme = ggthemes::theme_clean(base_size = 14, base_family = "sans"),
  colors = c("#6D9EC1", "white", "#E46726")) +
  theme(axis.text.x = element_text(angle = 90, size = 12),
        axis.text.y = element_text(size = 12)) + 
  coord_flip())


```

Export corplot
```{r, eval=FALSE}
ggsave(plot = immuno_metabs_corrplot,
       filename = "figures/C18-Neg-Metabs-and-immunology-corrplot.svg",
       width = 5,
       height = 10,
       scale = 1)
```


export a df for isoflavones analysis
```{r}
write_csv(imp_metabind_clust_log2_noQCs, file = "meta_omics_noQCs.csv")
```

