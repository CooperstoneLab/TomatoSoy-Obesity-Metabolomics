---
title: "USDA Inflammation Metabolomics Data analysis"
subtitle: "Urine, HILIC(+) LCMS"
author: "Maria Sholola"
date: '2023-06-05'
output: 
  html_document:
    highlight: kate
    theme: yeti
    toc: true
    toc_float: true
    toc_depth: 5
    code_download: true
    fig_width: 7
editor_options: 
  chunk_output_type: inline
---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(warning = FALSE, message = FALSE, echo=TRUE) 
```

# Load libraries
```{r, warning = FALSE, message = FALSE}
library(tidyverse) # for everything
library(readxl) # for reading in excel files
library(janitor) # data checks and cleaning
library(glue) # for easy pasting
library(FactoMineR) # for PCA
library(factoextra) # for PCA
library(rstatix) # for stats
library(pheatmap) # for heatmaps
library(plotly) # for interactive plots
library(htmlwidgets) # for saving interactive plots
library(devtools)
library(notame) # used for feature clustering
library(doParallel)
library(igraph) # feature clustering
library(ggpubr) # visualizations
library(knitr) # clean table printing
library(rmarkdown)
library(mixOmics) # for multilevel PCAs
```

# Read in data
```{r}
# raw filtered metabolomics data in HILIC (+)
omicsdata <- read_csv("Feature lists/HILIC-POS-Filtered-Data-05Jun23_1444features.csv")

# metadata
metadata <- read_excel("Metadata-urine-HILIC-POS.xlsx")
```

# Wrangle data

```{r}
metadata <- metadata %>%
  rename("sample_ID" = Sample_ID)
```


```{r}
# rename "row ID"
omicsdata <- omicsdata %>%
  rename("row_ID" = `row ID`)

# how many features
nrow(omicsdata)

# are there any duplicates?
omicsdata %>% get_dupes(mz_rt)

```

```{r}
# remove dupes
omicsdata <- omicsdata %>% 
  distinct(mz_rt, .keep_all = TRUE)

# check again for dupes
omicsdata %>% get_dupes(mz_rt)

# how many features
nrow(omicsdata)
```
Sometimes a weird logical column (lgl) comes up in my data. Let's check if it's there

```{r}
colnames(omicsdata)
```


```{r}
# remove weird lgl column
omicsdata <- omicsdata %>%
  dplyr::select(!where(is.logical))

colnames(omicsdata)
```



```{r}
# create long df for omics df
omicsdata_tidy <- omicsdata %>%
  pivot_longer(cols = 3:ncol(.),
               names_to = "sample_ID",
               values_to = "peak_height")

# combine meta and omics dfs
df_combined <- full_join(omicsdata_tidy,
                         metadata,
                         by = c("sample_ID" = "sample_ID"))

# separate mz and rt
df_combined_sep <- df_combined %>%
  separate(col = mz_rt,
           into = c("mz", "rt"),
           sep = "_") 

# convert columns to correct type
df_combined_sep$mz <- as.numeric(df_combined_sep$mz)
df_combined_sep$rt <- as.numeric(df_combined_sep$rt)
df_combined_sep$Subject <- as.character(df_combined_sep$Subject)
df_combined_sep$Intervention <- as.character(df_combined_sep$Intervention)

# rearrange column order
df_combined_sep <- df_combined_sep %>%
  dplyr::select(sample_ID, pre_post, Intervention, everything())

str(df_combined_sep)

# replace NA's in subject and intervention columns with QC
df_combined_sep$Subject <- df_combined_sep$Subject %>%
  replace_na("QC")

df_combined_sep$Intervention <- df_combined_sep$Intervention %>%
  replace_na("QC")


```

# Data summaries

## Number of masses detected
```{r}
nrow(omicsdata)
```


## Mass range for metabolites detected?

```{r}
range(df_combined_sep$mz)
```

## RT range for metabolites detected?

```{r}
range(df_combined_sep$rt)
```

## mass vs RT scatterplot
```{r}
# plot
(plot_mzvsrt <- df_combined_sep %>%
  ggplot(aes(x = rt, y = mz)) +
  geom_point() +
  theme_minimal() +
  labs(x = "Retention time, min",
       y = "m/z, neutral",
       title = "mz across RT for all features"))
```

## Histogram for mass range
```{r}
df_combined_sep %>%
  ggplot(aes(x = mz)) +
  geom_histogram(binwidth = 25) +
  theme_minimal() +
  labs(x = "Monoisotopic mass (amu)",
       y = "Number of features",
       title = "Distribution of features by mass")
```

## Histogram for RT

```{r}
df_combined_sep %>%
  ggplot(aes(x = rt)) +
  geom_histogram(binwidth = 0.1) + # 6 second bins
  theme_minimal() +
  labs(x = "Retention time",
       y = "Number of features",
       title = "Distribution of features by retention time")
```


# NAs and imputing

## NAs
```{r}
# NAs in all data including QCs
NAbyRow <- rowSums(is.na(omicsdata[,-1]))

hist(NAbyRow,
     breaks = 56, # because there are 56 samples, 48 samples + 8 QCs
     xlab = "Number of missing values",
     ylab = "Number of metabolites",
     main = "How many missing values are there?")
```

```{r}
# samples only (no QCs)
omicsdata_noQC <- omicsdata %>%
  dplyr::select(-contains("QC"))

#NAs in samples only?
NAbyRow_noQC <- rowSums(is.na(omicsdata_noQC[,-1]))

hist(NAbyRow_noQC,
     breaks = 48, # because there are 48 samples 
     xlab = "Number of missing values",
     ylab = "Number of metabolites",
     main = "How many missing values are there?")
```

Are there any missing values in QCs? There shouldn't be after data preprocessing/filtering
```{r}
omicsdata_QC <- omicsdata %>%
  dplyr::select(starts_with("P")) 

NAbyRow_QC <- colSums(is.na(omicsdata_QC))
# lets confirm that there are no missing values from my QCs
sum(NAbyRow_QC) # no
```


```{r}
# calculate how many NAs there are per feature in whole data set
contains_NAs <- df_combined %>%
  group_by(mz_rt) %>%
  count(is.na(peak_height)) %>%
  filter(`is.na(peak_height)` == TRUE)
head(contains_NAs)
```




## Remove NAs

Update May 3, 2023: I've been seeing outliers in unsupervised analyses. So to handle this, I think it is best to filter out metabolites that are only present in one person. So I will remove metabolites that are missing from at least 44 samples. Taking this out for now. 

```{r, eval=FALSE}
# remove features that have 44 or more NAs
omit_features <- contains_NAs %>%
  filter(n >= 44)
#preview
nrow(omit_features) # 109 features to remove

# how many features to remove?
nrow(omicsdata) - nrow(omit_features)

# now remove these features from the omics dataset
omicsdata <- omicsdata %>%
  anti_join(omit_features,
            by = "mz_rt")

 # how many features are there now?
nrow(omicsdata)
```


## Data imputation
```{r}
# impute any missing values by replacing them with 1/2 of the lowest peak height value of a feature (i.e. in a row).
imputed_omicsdata <- omicsdata

imputed_omicsdata[] <- lapply(imputed_omicsdata, 
                              function(x) ifelse(is.na(x),
                                                 min(x, na.rm = TRUE)/2, x))

dim(imputed_omicsdata)
```

Are there any NAs?
```{r}
imputed_omicsdata %>%
  is.na() %>%
  sum()

# imputations worked
```


# Create new imputed tidy datasets
```{r}
# create long df for imputed omics df
imputed_omicsdata_tidy <- imputed_omicsdata %>%
  pivot_longer(cols = 3:ncol(.),
               names_to = "sample_ID",
               values_to = "peak_height")

# combine meta and imputed omics dfs
imputed_fulldata <- full_join(imputed_omicsdata_tidy,
                         metadata,
                         by = c("sample_ID" = "sample_ID"))

# separate mz and rt
imputed_fulldata_sep <- imputed_fulldata %>%
  separate(col = mz_rt,
           into = c("mz", "rt"),
           sep = "_") 

# convert columns to correct type
imputed_fulldata_sep$mz <- as.numeric(imputed_fulldata_sep$mz)
imputed_fulldata_sep$rt <- as.numeric(imputed_fulldata_sep$rt)
imputed_fulldata_sep$Subject <- as.character(imputed_fulldata_sep$Subject)
imputed_fulldata_sep$Intervention <- as.character(imputed_fulldata_sep$Intervention)
```


# Notame feature reduction
vignette for reference
```{r}
#browseVignettes("notame")
```

## Plot features. RT vs mz before notame
```{r}
# rt vs mz plot
imputed_fulldata_sep %>%
  ggplot(aes(x = rt, y = mz)) +
  geom_point() +
  theme_minimal() +
  labs(x = "RT (min)",
       y = "mz")
```


## Data restructuring for notame
```{r}
# create features list from imputed data set to only include unique feature ID's (mz_rt), mz and RT
features <- imputed_fulldata_sep %>%
  cbind(imputed_fulldata$mz_rt) %>%
  rename("mz_rt" = "imputed_fulldata$mz_rt") %>%
  dplyr::select(c(mz_rt, mz, rt)) %>%
  distinct() # remove the duplicate rows

# create a second data frame which is just imputed_fulldata restructured to another wide format
data_notame <- data.frame(imputed_omicsdata %>%
                            dplyr::select(-row_ID) %>%
                            t())

data_notame <- data_notame %>%
  tibble::rownames_to_column() %>% # change samples from rownames to its own column
  row_to_names(row_number = 1) # change the feature IDs (mz_rt) from first row obs into column names


```

Check structures
```{r}
# check if mz and rt are numeric
str(features)
tibble(features)
```

```{r}
# check if results are numeric
tibble(data_notame)

# change to results to numeric
data_notame <- data_notame %>%
  mutate_at(-1, as.numeric)

tibble(data_notame)
```


## Find connections
```{r}
connection <- find_connections(data = data_notame,
                               features = features,
                               corr_thresh = 0.9,
                               rt_window = 1/60,
                               name_col = "mz_rt",
                               mz_col = "mz",
                               rt_col = "rt")

head(connection)
```

## Clustering
```{r}
clusters <- find_clusters(connections = connection, d_thresh = 0.8)
```

```{r}
# assign a cluster ID to all features. Clusters are named after feature with highest median peak height
features_clustered <- assign_cluster_id(data_notame, clusters, features, name_col = "mz_rt")


# visualize clusters
#visualize_clusters(data_notame, features, clusters, min_size = 3, rt_window = 2,name_col = "mz_rt", mz_col = "mz", rt_col = "rt", file_path = "~/path/to/project/")

# lets see how many features are removed when we only keep one feature per cluster
pulled <- pull_clusters(data_notame, features_clustered, name_col = "mz_rt")
cluster_data <- pulled$cdata

cluster_features <- pulled$cfeatures
# export clustered feature list
write_csv(cluster_features,
          "cluster_features-_hilic-pos.csv")

nrow(omicsdata) - nrow(cluster_features)
```

## Reduce dataset based on clustering
```{r}
# transpose the full dataset back to wide so that it is more similar to the notame dataset
imputed_fulldata_wide <- imputed_fulldata %>%
  dplyr::select(-"row_ID") %>%
  pivot_wider(names_from = mz_rt,
              values_from = peak_height)

# list of reduced features
clusternames <- cluster_features$mz_rt

# dplyr::select only the features are in the reduced list
imp_clust <- imputed_fulldata_wide[,c(names(imputed_fulldata_wide) %in% clusternames)]

# bind back sample names
imp_clust <- cbind(imputed_fulldata_wide[1], imp_clust)

tibble(imp_clust)

```

## Mz vs RT scatterplot 

```{r}
# plot new rt vs mz scatterplot post-clustering
(plot_mzvsrt_postcluster <- cluster_features %>%
  ggplot(aes(x = rt,
             y = mz)) +
  geom_point() +
  theme_minimal() +
  labs(x = "Retention time, min",
       y = "m/z, neutral",
       title = "mz across RT for all features after clustering"))


```


```{r}
# plot both scatterplots to compare with and without notame clustering
(scatterplots <- ggarrange(plot_mzvsrt, 
                           plot_mzvsrt_postcluster, 
                           nrow = 2))
```

# Bind meta data
```{r}
imp_metabind_clust <- right_join(metadata, 
                                 imp_clust,
                                 by = "sample_ID")
```

# Visualize untransformed data

## Data wrangling
```{r}
# change meta data columns to character so that I can change NAs from QCs to "QC"
imp_metabind_clust <- imp_metabind_clust %>%
  mutate_at(c("Subject",
              "Period",
              "Intervention",
              "pre_post",
              "sequence",
              "Intervention_week",
              "Sex",
              "Age",
              "BMI"),
            as.character) 

# replace NAs in metadata columns for QCs
imp_metabind_clust[is.na(imp_metabind_clust)] <- "QC"

# unite pre_post column with intervention column to create pre_intervention column
imp_metabind_clust <- imp_metabind_clust %>%
  unite(col = "pre_post_intervention",
        c("pre_post","Intervention"),
        sep = "_",
        remove = FALSE)

# long df
imp_metabind_clust_tidy <- imp_metabind_clust %>%
  pivot_longer(cols = 12:ncol(.),
               names_to = "mz_rt",
               values_to = "rel_abund")

# structure check
str(imp_metabind_clust_tidy)
```


## Boxplot
```{r}
imp_metabind_clust_tidy %>%
  ggplot(aes(x = sample_ID, y = rel_abund, color = Intervention)) +
  geom_boxplot(alpha = 0.6) +
  scale_color_manual(values = c("light grey", "tomato1", "gold")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "LC-MS (+) Feature Abundances by Sample",
       subtitle = "Unscaled data",
       y = "Relative abundance")
```
Will need to log transform in order to normalize and actually see the data

# Log2 transform
```{r}
imp_metabind_clust_tidy_log2 <- imp_metabind_clust_tidy %>%
  mutate(rel_abund_log2 = if_else(rel_abund > 0, log2(rel_abund), 0)) %>%
  replace(is.na(.), 0)
```

## Boxplot
```{r}
(bp_data_quality <- imp_metabind_clust_tidy_log2 %>%
  ggplot(aes(x = sample_ID, y = rel_abund_log2, fill = Intervention)) +
  geom_boxplot(alpha = 0.6) +
  scale_fill_manual(values = c("light grey", "tomato1", "gold")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90)) +
  labs(title = "LC-MS (+) Feature Abundances by Sample",
       subtitle = "Log2 transformed data",
       y = "Relative abundance"))
```

Much better! QCs look like there may be some drift though. Let's do drift correction with the Notame package!

# Notame drift correction

## Data wrangling

### Feature abund df 

```{r}
# filtered and imputed data after notame clustering, transposed
features_testforQCcorr <- t(imp_clust) %>%
  as.data.frame() %>%
  row_to_names(row_number = "find_header")

# log2 transform
log2_features_testforQCcorr <- features_testforQCcorr %>%
  mutate_all(as.numeric) %>%
  log2()

# write csv to manually edit
write.csv(log2_features_testforQCcorr,
          "notame dfs/feaures_test.csv",
          row.names = TRUE)
```

Import corrected df (edited so that mz_rt could rowname 1)
```{r}
features_forQCcorr <- read.csv("notame dfs/features_forQCcorr.csv",
                                header = FALSE,
                                row.names = 1)


features_forQCcorr <- features_forQCcorr %>%
  rownames_to_column(var = "mz_rt") %>%
  row_to_names(row_number = 1)%>%
  separate(col = mz_rt,
           into = c("mz", "rt"),
           sep = "_")

write.csv(features_forQCcorr,
          "notame dfs/features_forQCcorr_pt2.csv",
          row.names = TRUE)

```


### Pheno df

```{r}
# separate sampleID and injection order
pheno_data <- imp_clust[1] %>%
  separate(col = sample_ID,
           into = c("sample_ID", "injection_order"),
           sep = "_HILICPOS_")

# change pre-run QC injection number to correct number
pheno_data[48, "injection_order"] <- 9

# make inj order column num
pheno_data <- pheno_data %>%
  mutate_at("injection_order", as.numeric)

t_pheno_data <- as.data.frame(t(pheno_data))

write.csv(t_pheno_data,
          "notame dfs/pheno_df.csv",
          row.names = TRUE)
```

Combine pheno and feature dfs manually in excel to create metaboset df.

## Import Metaboset

```{r}
#make sure when converting csv to xlsx that you save as a new file, don't just change the name of the file
metaboset <- read_from_excel("notame dfs/metaboset.xlsx",
                             split_by = c("column", "Ion mode"))

```


```{r}
#construct Metaboset
modes <- construct_metabosets(exprs = metaboset$exprs,
                              pheno_data = metaboset$pheno_data,
                              feature_data = metaboset$feature_data, group_col = "Class")

#extract each mode into a single object
mode <- modes$HILIC_pos
```


## Boxplots before correction

```{r}

(qualityBPs_b4correction <- plot_sample_boxplots(mode, order_by = "Class", title = "Uncorrected feature abundance"))

```


## Boxplots after QC drift correction

drift corrected takes up to 2 minutes
```{r}
mode <- flag_detection(mode, qc_limit = 0.75, group_limit = 0.8)


corrected <- correct_drift(mode, log_transform = FALSE)
```


### Did drift correction work?

inspection also takes about 2 minutes to run; output is percent of the features that were drift corrected. The remaining "low-quality" percent represents features for which the DC did *not* improve the RSD and D-ratio of the original data.

```{r}
inspected <- inspect_dc(orig = mode, dc = corrected, check_quality = TRUE)
```

### Boxplots, corrected
```{r}

(qualityBPS_driftcorrection <- plot_sample_boxplots(corrected, order_by = "Class", title = "Corrected feature abundance"))


```


## Compare quality BPs
```{r, fig.height=10}
(qualityBPs_compared <- ggarrange(qualityBPs_b4correction, qualityBPS_driftcorrection,
                    ncol = 1, nrow = 2))
```


## Export new Metaboset to Excel spreadsheet
```{r eval = FALSE}
write_to_excel(corrected, "notame dfs/metaboset_corrected.xlsx")
```


## Import edited Metaboset

```{r}
metabdata_corrected <- read.csv(file = "notame dfs/metaboset_corrected_editedforR.csv",
                                check.names = FALSE)
```


## Wrangle new metab data

### Combine mz & rt back together

```{r}
metabdata_corrected_MZ_RT <- metabdata_corrected %>%
  mutate(mass = round(metabdata_corrected$mass, digits = 4), # Decrease number of decimals for m/z & rt
         rt = round(metabdata_corrected$rt, digits = 3),
         .before=1,
         .keep="unused") %>%
  unite(mz_rt, c(mass, rt), remove=TRUE) # Combine m/z & rt with _ in between

```

### Transpose new df

```{r}
metabdata_corrected_t <- as.data.frame(t(metabdata_corrected_MZ_RT)) %>%
  row_to_names(row_number = "find_header") %>% # make MZ_RT column names
  rownames_to_column(var = "subj_period") # change rownames to column 1
  
```

### Bind new data with metadata

I want the new drift corrected (DC) df to look just like "imp_metabind_clust_log2" df

```{r}
# go back to wide data
imp_metabind_clust_log2 <- imp_metabind_clust_tidy_log2 %>%
  dplyr::select(!rel_abund) %>%
  pivot_wider(names_from = mz_rt,
              values_from = rel_abund_log2)
```


```{r}
# combine subject and period columns from imp_metabind_clust_log2 in order to mimic DC df
subj_per_imp_metabind_clust_log2 <- imp_metabind_clust_log2 %>%
  unite(subj_period, c(Subject, Period), remove = FALSE)

# place new DC observations in
DC_imp_metabind_clust_log2 <- full_join(subj_per_imp_metabind_clust_log2[,c(1:12)], metabdata_corrected_t, by = "subj_period")

# take out old QC observations
DC_imp_metabind_clust_log2 <- DC_imp_metabind_clust_log2 %>%
  filter(subj_period != "QC_QC")

# replace NAs in columns for QCs
DC_imp_metabind_clust_log2[is.na(DC_imp_metabind_clust_log2)] <- "QC"
```


# PCAs

## With QCS

### Wrangle

Data after drift correction
```{r}
DC_imp_metabind_clust_log2 <- DC_imp_metabind_clust_log2 %>%
  dplyr::select(!"subj_period") %>%
  mutate_at(-c(1:11), as.numeric)
```


```{r}
PCA.DC_imp_metabind_clust_log2 <- PCA(DC_imp_metabind_clust_log2,  # wide data
                                   quali.sup = 1:11, # remove qualitative variables
                                   graph = FALSE, # don't graph
                                   scale.unit = FALSE) # don't scale, already transformed data

# PCA summary
kable(summary(PCA.DC_imp_metabind_clust_log2))
```

```{r}
# pull PC coordinates into df
PC_coord_QC_log2 <- as.data.frame(PCA.DC_imp_metabind_clust_log2$ind$coord)

# bind back metadata from cols 1-10
PC_coord_QC_log2 <- bind_cols(DC_imp_metabind_clust_log2[,1:11], PC_coord_QC_log2)

# grab some variance explained
importance_QC <- PCA.DC_imp_metabind_clust_log2$eig

# set variance explained with PC1, round to 2 digits
PC1_withQC <- round(importance_QC[1,2], 2)

# set variance explained with PC2, round to 2 digits
PC2_withQC <- round(importance_QC[2,2], 2)
```

### Plots
Using FactoExtra package
```{r}
# scree plot
fviz_eig(PCA.DC_imp_metabind_clust_log2)

# get eigenvalues
kable(get_eig(PCA.DC_imp_metabind_clust_log2))
```

```{r}
# scores plot
fviz_pca_ind(PCA.DC_imp_metabind_clust_log2)
```

### Manual scores plots
```{r}
# manual scores plot
(PCA_withQCs <- PC_coord_QC_log2 %>%
  ggplot(aes(x = Dim.1, y = Dim.2,
             fill = factor(Intervention, levels = c("Yellow", "Red", "QC")))) +
  geom_point(shape = 21, alpha = 0.8) +
  scale_fill_manual(values = c("gold", "tomato1", "light grey")) +
  scale_color_manual(values = "black") +  
  theme_minimal() +
  coord_fixed(PC2_withQC/PC1_withQC) +
  labs(x = glue::glue("PC1: {PC1_withQC}%"),
       y = glue::glue("PC2: {PC2_withQC}%"),
       fill = "Group",
       title = "Principal Components Analysis Scores Plot",
       subtitle = "Log2 transformed data"))
```

## Without QCs

### Wrangle 

```{r}
DC_imp_metabind_clust_log2_noQCs <- DC_imp_metabind_clust_log2 %>%
  filter(Intervention != "QC")

PCA.DC_imp_metabind_clust_log2_noQCs <- PCA(DC_imp_metabind_clust_log2_noQCs, # wide data
                               quali.sup=1:11, # remove qualitative variables
                               graph=FALSE, # don't graph
                               scale.unit=FALSE) # don't scale, we already did this

# look at summary
kable(summary(PCA.DC_imp_metabind_clust_log2_noQCs))
```

```{r}
# pull PC coordinates into df
PC_coord_noQCs_log2 <- as.data.frame(PCA.DC_imp_metabind_clust_log2_noQCs$ind$coord)

# bind back metadata from cols 1-10
PC_coord_noQCs_log2 <- bind_cols(DC_imp_metabind_clust_log2_noQCs[,1:11], PC_coord_noQCs_log2)

# grab some variance explained
importance_noQC <- PCA.DC_imp_metabind_clust_log2_noQCs$eig

# set variance explained with PC1, round to 2 digits
PC1_noQC <- round(importance_noQC[1,2], 2)

# set variance explained with PC2, round to 2 digits
PC2_noQC <- round(importance_noQC[2,2], 2)
```

### Plots
Using FactoExtra

```{r}
# scree plot
fviz_eig(PCA.DC_imp_metabind_clust_log2_noQCs)
```

```{r}
# scores plot
fviz_pca_ind(PCA.DC_imp_metabind_clust_log2_noQCs)
```


```{r}
# plot of contributions from features to PC1
(var_contrib_noQCs_PC1 <- fviz_contrib(PCA.DC_imp_metabind_clust_log2_noQCs,
             choice = "var",
             axes = 1,
             top = 25,
             title = "Var contribution to PC1: no QCs"))

# plot of contributions from features to PC2
(var_contrib_noQCs_PC2 <- fviz_contrib(PCA.DC_imp_metabind_clust_log2_noQCs,
             choice = "var",
             axes = 2,
             top = 25,
             title = "Var contribution to PC2: no QCs"))
```

### Manual scores plots

#### Yellow vs red
```{r}
(PCA_withoutQCs <- PC_coord_noQCs_log2 %>%
  ggplot(aes(x = Dim.1, 
             y = Dim.2,
             fill = Intervention)) +
    geom_point(shape = 21, alpha = 0.8) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha=0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha=0.5) +
    scale_fill_manual(values = c("gold", "tomato1")) +
    scale_color_manual(values = "black") +  
    theme_minimal() +
    coord_fixed(PC2_noQC/PC1_noQC) +
    labs(x = glue::glue("PC1: {PC1_noQC}%"),
         y = glue::glue("PC2: {PC2_noQC}%"),
         fill = "Intervention",
         title = "Principal Components Analysis Scores Plot",
         subtitle = "Log2 transformed data, without QCs"))
ggplotly(PCA_withoutQCs)
```

#### pre vs post
```{r}
(PCA_withoutQCs.pre_post <- PC_coord_noQCs_log2 %>%
  ggplot(aes(x = Dim.1, 
             y = Dim.2,
             fill = factor(pre_post_intervention, levels = c("pre_Yellow",
                                                             "post_Yellow",
                                                             "pre_Red",
                                                             "post_Red")),
             text = sample_ID)) +
    geom_point(shape = 21, alpha = 0.8) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha=0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha=0.5) +
    scale_fill_manual(values = c("gray", "yellow1", "pink1", "red2")) +
    scale_color_manual(values = "black") +  
    theme_minimal() +
    coord_fixed(PC2_noQC/PC1_noQC) +
    labs(x = glue::glue("PC1: {PC1_noQC}%"),
         y = glue::glue("PC2: {PC2_noQC}%"),
         fill = "pre_post",
         title = "Principal Components Analysis Scores Plot",
         subtitle = "Log2 transformed, without QCs"))
ggplotly(PCA_withoutQCs.pre_post,
         tooltip = "text") 
```

## Notes 
Looks like subject 6106 and 6112 are outliers


## Removal of outlier

### With QCs

#### Wrangle


```{r}
# go back to wide data
DC_imp_nooutliers_log2 <- DC_imp_metabind_clust_log2 %>%
  filter(Subject != 6106,
         Subject != 6112)

PCA.DC_imp_nooutliers_log2 <- PCA(DC_imp_nooutliers_log2,  # wide data
                                   quali.sup = 1:11, # remove qualitative variables
                                   graph = FALSE, # don't graph
                                   scale.unit = FALSE) # don't scale, already transformed data

# PCA summary
summary(PCA.DC_imp_nooutliers_log2)
```

```{r}
# pull PC coordinates into df
PC_nooutliers_QC_log2 <- as.data.frame(PCA.DC_imp_nooutliers_log2$ind$coord)

# bind back metadata from cols 1-11
PC_nooutliers_QC_log2 <- bind_cols(DC_imp_nooutliers_log2[,1:11], PC_nooutliers_QC_log2)

# grab some variance explained
importance_nooutliers_QC <- PCA.DC_imp_nooutliers_log2$eig

# set variance explained with PC1, round to 2 digits
PC1_nooutliers_withQC <- round(importance_nooutliers_QC[1,2], 2)

# set variance explained with PC2, round to 2 digits
PC2_nooutliers_withQC <- round(importance_nooutliers_QC[2,2], 2)
```

#### Plots
Using FactoExtra package
```{r}
# scree plot
fviz_eig(PCA.DC_imp_nooutliers_log2)
```

```{r}
# scores plot
fviz_pca_ind(PCA.DC_imp_nooutliers_log2)
```


#### Manual scores plots

 ##### Red vs yellow
```{r}
# manual scores plot
(PCA_nooutliers_withQCs <- PC_nooutliers_QC_log2 %>%
  ggplot(aes(x = Dim.1, y = Dim.2,
             fill = factor(Intervention, levels = c("Yellow", "Red", "QC")))) +
  geom_point(shape = 21, alpha = 0.8) +
  scale_fill_manual(values = c("gold", "tomato1", "light grey")) +
  scale_color_manual(values = "black") +  
  theme_minimal() +
  labs(x = glue::glue("PC1: {PC1_nooutliers_withQC}%"),
       y = glue::glue("PC2: {PC2_nooutliers_withQC}%"),
       fill = "Group",
       title = "Principal Components Analysis Scores Plot"))
```

##### Pre vs post
```{r}
(PCA_nooutliers_prepost_withQCs <- PC_nooutliers_QC_log2 %>%
  ggplot(aes(x = Dim.1, 
             y = Dim.2,
             fill = factor(pre_post_intervention, levels = c("pre_Yellow",
                                                             "post_Yellow",
                                                             "pre_Red",
                                                             "post_Red")),
             text = sample_ID)) +
    geom_point(shape = 21, alpha = 0.8) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha=0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha=0.5) +
    scale_fill_manual(values = c("gray", "yellow1", "pink1", "red2")) +
    scale_color_manual(values = "black") +  
    theme_minimal() +
    labs(x = glue::glue("PC1: {PC1_nooutliers_withQC}%"),
         y = glue::glue("PC2: {PC2_nooutliers_withQC}%"),
         fill = "pre_post",
         title = "Principal Components Analysis Scores Plot"))
ggplotly(PCA_nooutliers_prepost_withQCs,
         tooltip = "text") 
```


### Without QCs

#### Wrangle
```{r}
imp_nooutliers_noQCs_log2 <- DC_imp_nooutliers_log2 %>%
  filter(Intervention != "QC") 

PCA.imp_nooutliers_noQCs_log2 <- PCA(imp_nooutliers_noQCs_log2, # wide data
                               quali.sup=1:11, # remove qualitative variables
                               graph=FALSE, # don't graph
                               scale.unit=FALSE) # don't scale, we already did this

# look at summary
kable(summary(PCA.imp_nooutliers_noQCs_log2))
```

```{r}
# pull PC coordinates into df
PC_coord_nooutliers_noQC_log2 <- as.data.frame(PCA.imp_nooutliers_noQCs_log2$ind$coord)

# bind back metadata from cols 1-11
PC_coord_nooutliers_noQC_log2 <- bind_cols(imp_nooutliers_noQCs_log2[,1:11], PC_coord_nooutliers_noQC_log2)

# grab some variance explained
importance_nooutliers_noQC <- PCA.imp_nooutliers_noQCs_log2$eig

# set variance explained with PC1, round to 2 digits
PC1_nooutliers_noQC <- round(importance_nooutliers_noQC[1,2], 2)

# set variance explained with PC2, round to 2 digits
PC2_nooutliers_noQC <- round(importance_nooutliers_noQC[2,2], 2)
```


#### Plots
Using FactoExtra
```{r}
# scree plot
fviz_eig(PCA.imp_nooutliers_noQCs_log2)
```

```{r}
# scores plot
fviz_pca_ind(PCA.imp_nooutliers_noQCs_log2)
```


```{r}
# plot of contributions from features to PC1
(var_contrib_nooutliers_noQCs_PC1 <- fviz_contrib(PCA.imp_nooutliers_noQCs_log2,
             choice = "var",
             axes = 1,
             top = 20,
             title = "Var contribution to PC1: no outliers, no QCs"))

# plot of contributions from features to PC2
(var_contrib_nooutliers_noQCs_PC2 <- fviz_contrib(PCA.imp_nooutliers_noQCs_log2,
             choice = "var",
             axes = 2,
             top = 20,
             title = "Var contribution to PC2: no outliers, no QCs"))
```


#### Manual scores plots

##### Red vs yellow
```{r}
(PCA_nooutliers_withoutQCs <- PC_coord_nooutliers_noQC_log2 %>%
  ggplot(aes(x = Dim.1, 
             y = Dim.2,
             fill = Intervention)) +
    geom_point(shape = 21, alpha = 0.8) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha=0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha=0.5) +
    scale_fill_manual(values = c("tomato1", "gold")) +
    scale_color_manual(values = "black") +  
    theme_minimal() +
    coord_fixed(PC2_nooutliers_noQC/PC1_nooutliers_noQC) +
    labs(x = glue::glue("PC1: {PC1_nooutliers_noQC}%"),
         y = glue::glue("PC2: {PC2_nooutliers_noQC}%"),
         fill = "Intervention",
         title = "Principal Components Analysis Scores Plot"))
ggplotly(PCA_nooutliers_withoutQCs)
```


##### Pre vs post
```{r}
(PCA_nooutliers_noQCs.prepost <- PC_coord_nooutliers_noQC_log2 %>%
  ggplot(aes(x = Dim.1, 
             y = Dim.2,
             fill = factor(pre_post_intervention, levels = c("pre_Yellow",
                                                             "post_Yellow",
                                                             "pre_Red",
                                                             "post_Red")),
             text = sample_ID)) +
    geom_point(shape = 21, alpha = 0.8) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha=0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha=0.5) +
    scale_fill_manual(values = c("gray", "yellow1", "pink1", "red2")) +
    scale_color_manual(values = "black") +  
    theme_minimal() +
    coord_fixed(PC2_nooutliers_noQC/PC1_nooutliers_noQC) +
    labs(x = glue::glue("PC1: {PC1_nooutliers_noQC}%"),
         y = glue::glue("PC2: {PC2_nooutliers_noQC}%"),
         fill = "pre_post",
         title = "Principal Components Analysis Scores Plot",
         subtitle = "Log2 transformed data, no outliers"))
ggplotly(PCA_nooutliers_noQCs.prepost,
         tooltip = "text") 
```


##### M v F
```{r}
(PCA_nooutliers_noQCs.MvsF <- PC_coord_nooutliers_noQC_log2 %>%
  ggplot(aes(x = Dim.1, 
             y = Dim.2,
             fill = factor(Sex, levels = c("M","F")),
             text = sample_ID)) +
    geom_point(shape = 21, alpha = 0.8) +
    geom_hline(yintercept = 0, linetype = "dashed", alpha=0.5) +
    geom_vline(xintercept = 0, linetype = "dashed", alpha=0.5) +
    scale_fill_manual(values = c("green", "pink")) +
    scale_color_manual(values = "black") +  
    theme_minimal() +
    coord_fixed(PC2_nooutliers_noQC/PC1_nooutliers_noQC) +
    labs(x = glue::glue("PC1: {PC1_nooutliers_noQC}%"),
         y = glue::glue("PC2: {PC2_nooutliers_noQC}%"),
         fill = "pre_post",
         title = "Principal Components Analysis Scores Plot",
         subtitle = "Log2 transformed data, no 6106"))
ggplotly(PCA_nooutliers_noQCs.MvsF,
         tooltip = "text")
```



# PCAtools pckg
```{r,eval=FALSE}
  if (!requireNamespace('BiocManager', quietly = TRUE))
    install.packages('BiocManager')

  BiocManager::install('PCAtools')
```


```{r}
library(PCAtools)
```

## W/ Outliers

### Data wrangling
```{r}
# create rel abund df suitable for PCAtools package

DC_imp_clust_omicsdata_outliers_forPCAtools <- as.data.frame(t(DC_imp_metabind_clust_log2[,-c(2:11)])) # transpose df 

names(DC_imp_clust_omicsdata_outliers_forPCAtools) <- DC_imp_clust_omicsdata_outliers_forPCAtools[1,] # make sample IDs column names

DC_imp_clust_omicsdata_outliers_forPCAtools <- DC_imp_clust_omicsdata_outliers_forPCAtools[-1,] # remove sample ID row

# create metadata df suitable for PCAtools pckg

metadata_outliers_forPCAtools <- metadata %>%
  column_to_rownames(var = "sample_ID") # change sample ID column to rownames

# create a vector so that col names in abundance df matches metadata df
order_outliers_forPCAtools <- match(rownames(metadata_outliers_forPCAtools), colnames(DC_imp_clust_omicsdata_outliers_forPCAtools))

# reorder col names in abundance df so that it matches metadata
abundata_outliers_reordered_forPCAtools <- DC_imp_clust_omicsdata_outliers_forPCAtools[ ,order_outliers_forPCAtools] 

# change abundance df to numeric
abundata_outliers_reordered_forPCAtools <- abundata_outliers_reordered_forPCAtools %>%
  mutate_all(as.numeric)

# Log transform
log2_abundata_outliers_forPCAtools <- log2(abundata_outliers_reordered_forPCAtools)


# unite pre_post column with intervention column to create pre_intervention column
metadata_outliers_forPCAtools <- metadata_outliers_forPCAtools %>%
  unite(col = "pre_post_intervention",
        c("pre_post","Intervention"),
        sep = "_",
        remove = FALSE)
```


### PCA
```{r, fig.width=7, fig.height=7.5}
# pca
p_outliers <- PCAtools::pca(log2_abundata_outliers_forPCAtools, 
         metadata = metadata_outliers_forPCAtools, 
         scale = FALSE # using scaled data already (log2 transformed)
         
)

# plot

PCAtools::biplot(p_outliers,
                 showLoadings = TRUE, # show variables that contribute the most to PCs
                 lab = NULL,
                 title = )
```


### More PCAs

#### Pre vs post both

##### PC1vPC2


```{r, fig.width=8.5, fig.height=6.5}
  biplot(p_outliers,
          lab = paste0(metadata_outliers_forPCAtools$Subject),
          colby = 'pre_post_intervention',
          colkey = c("pre_Yellow" = "yellow",
                     "post_Yellow" = "yellow4",
                     "pre_Red" = "red",
                     "post_Red" = "red4"),
         # ellipse config
         ellipse = TRUE,
         ellipseType = 't',
         ellipseLevel = 0.95,
         ellipseFill = TRUE,
         ellipseAlpha = 0.2,
         ellipseLineSize = 1.0,
         xlim = c(-25,25), ylim = c(-10, 10),
         hline = 0, vline = 0,
         legendPosition = 'right',
         title = "PCA Scores Plot with 95% Confidence Interval",
         subtitle = "Log2 transformed data, HILIC (+), with outliers, no QCs")
```


## No outliers

### Data wrangling
```{r}
# create rel abund df suitable for PCAtools package

DC_imp_clust_omicsdata_forPCAtools <- as.data.frame(t(DC_imp_metabind_clust_log2[,-c(2:11)])) # transpose df 

names(DC_imp_clust_omicsdata_forPCAtools) <- DC_imp_clust_omicsdata_forPCAtools[1,] # make sample IDs column names

DC_imp_clust_omicsdata_forPCAtools <- DC_imp_clust_omicsdata_forPCAtools[-1,] # remove sample ID row

DC_imp_clust_omicsdata_forPCAtools <- DC_imp_clust_omicsdata_forPCAtools %>%
  dplyr::select(!contains("QC")) # remove QC observations


# create metadata df suitable for PCAtools pckg

metadata_forPCAtools <- metadata %>%
  column_to_rownames(var = "sample_ID") # change sample ID column to rownames

# create a vector so that col names in abundance df matches metadata df
order_forPCAtools <- match(rownames(metadata_forPCAtools), colnames(DC_imp_clust_omicsdata_forPCAtools))

# reorder col names in abundance df so that it matches metadata
abundata_reordered_forPCAtools <- DC_imp_clust_omicsdata_forPCAtools[ ,order_forPCAtools] 

# change abundance df to numeric
abundata_reordered_forPCAtools <- abundata_reordered_forPCAtools %>%
  mutate_all(as.numeric)

# Log transform
log2_abundata_forPCAtools <- log2(abundata_reordered_forPCAtools)

# remove outlier subj from both df
log2_abundata_forPCAtools <- log2_abundata_forPCAtools %>%
  dplyr::select(!contains("6106")) %>%
  dplyr::select(!contains("6112"))

metadata_forPCAtools <- metadata_forPCAtools %>%
  filter(Subject != 6106,
         Subject != 6112)

# unite pre_post column with intervention column to create pre_intervention column
metadata_forPCAtools <- metadata_forPCAtools %>%
  unite(col = "pre_post_intervention",
        c("pre_post","Intervention"),
        sep = "_",
        remove = FALSE)

```

### PCA
```{r, fig.width=7, fig.height=7.5}
# pca
p <- PCAtools::pca(log2_abundata_forPCAtools, 
         metadata = metadata_forPCAtools, 
         scale = FALSE # using scaled data already (log2 transformed)
         
)

# plot

PCAtools::biplot(p,
                 showLoadings = TRUE, # show variables that contribute the most to PCs
                 lab = NULL,
                 title = )
```

### Screeplot analysis

Horn's parallel analysis
```{r, warning=FALSE}
horn <- parallelPCA(log2_abundata_forPCAtools)

horn$n
```

Elbow method
```{r}
elbow <- findElbowPoint(p$variance)

elbow
```


```{r, fig.width=7, fig.height=7.5}

  screeplot(p,
    components = getComponents(p, 1:20),
    vline = c(horn$n, elbow)) +
  geom_label(aes(x = horn$n + 1, y = 50,
      label = 'Horn\'s', vjust = -1, size = 8)) +
    geom_label(aes(x = elbow + 1, y = 50,
      label = 'Elbow method', vjust = -3, size = 8))
```

How many PCs do we need to capture at least 80% variance?
```{r}
which(cumsum(p$variance) > 80)[1]
```

### More PCAs

#### Pre vs post both

##### PC1vPC2


```{r, fig.width=10, fig.height=10}
biplot(p,
       lab = paste0(metadata_forPCAtools$Subject),
       colby = 'pre_post_intervention',
       colkey = c("pre_Yellow" = "yellow",
                  "post_Yellow" = "yellow4",
                  "pre_Red" = "red",
                  "post_Red" = "red4"),
       hline = 0, vline = 0,
       # ellipse config
       ellipse = TRUE,
       ellipseType = 't', # assumes multivariate t-distribution
       ellipseLevel = 0.95,
       ellipseFill = TRUE,
       ellipseAlpha = 0.2,
       ellipseLineSize = 0,
       xlim = c(-7,5), ylim = c(-5,5),
       legendPosition = 'right',
       title = "PCA Scores Plot",
       subtitle = "Log2 transformed data, HILIC (+), outliers removed, no QCs \n95% confidence level ellipses")


```


```{r, fig.width=10, fig.height=8.5}
(PCA.colby.prevspost <- biplot(p,
                               lab = NULL,
                           colby = 'pre_post_intervention',
                           colkey = c("pre_Yellow" = "yellow",
                                      "post_Yellow" = "yellow4",
                                      "pre_Red" = "red",
                                      "post_Red" = "red4"),
                           hline = 0, vline = 0,
         legendPosition = 'right',
         title = "PCA Scores Plot",
         subtitle = "Log2 transformed data, HILIC (+), outliers removed, no QCs \n95% confidence level ellipses",
         showLoadings = TRUE))
```


##### Pairs plot
```{r, fig.width=10, fig.height=10, message=FALSE}
(PCA_pairsplot.colby.prevspost <-
  pairsplot(p,
    components = getComponents(p, c(1:10)),
    triangle = TRUE, trianglelabSize = 12,
    hline = 0, vline = 0,
    pointSize = 0.4,
    gridlines.major = FALSE, gridlines.minor = FALSE,
    colby = 'pre_post_intervention', 
    colkey = c("pre_Yellow" = "yellow",
               "post_Yellow" = "yellow4",
               "pre_Red" = "pink",
               "post_Red" = "red4"),
    title = 'Pairs plot', plotaxes = FALSE,
    margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm')))

```

### Sex

#### PC1vPC2
```{r, fig.width=8.5, fig.height=6.5}
(PCA.colby.Sex <- biplot(p,
                           lab = paste0(metadata_forPCAtools$Subject),
                          colby = 'Sex',
                          colkey = c("M" = "red",
                                     "F" = "purple"),
                          hline = 0, vline = 0,
                          legendPosition = 'right' +
                            geom_point(aes(text = metadata_forPCAtools$Subject))))

ggplotly(PCA.colby.Sex,
         tooltip = "text") 

```

#### Pairsplot
```{r, fig.width=10, fig.height=10, message=FALSE}
  pairsplot(p,
    components = getComponents(p, c(1:10)),
    triangle = TRUE, trianglelabSize = 12,
    hline = 0, vline = 0,
    pointSize = 0.4,
    gridlines.major = FALSE, gridlines.minor = FALSE,
    colby = 'Sex', 
    colkey = c("M" = "red",
               "F" = "purple"),
    title = 'Pairs plot', plotaxes = FALSE,
    margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm'))
```


### Overall pre v post

#### PC1vPC2
```{r, fig.width=8, fig.height=6.5, message=FALSE}
(PCA.colby.overall.prevspost <- biplot(p,
                                       lab = paste0(metadata_forPCAtools$Subject),
                                       colby = 'pre_post',
                                       colkey = c("pre" = "orange",
                                                  "post" = "green3"),
                                       hline = 0, vline = 0,
                                       legendPosition = 'right' +
                                         geom_point(aes(text = metadata_forPCAtools$Subject))))

ggplotly(PCA.colby.overall.prevspost,
         tooltip = "text") 

```

#### Pairsplot

```{r, fig.width=10, fig.height=10, message=FALSE}
  pairsplot(p,
    components = getComponents(p, c(1:10)),
    triangle = TRUE, trianglelabSize = 12,
    hline = 0, vline = 0,
    pointSize = 0.4,
    gridlines.major = FALSE, gridlines.minor = FALSE,
    colby = 'pre_post', 
    colkey = c("pre" = "orange",
               "post" = "green3"),
    title = 'Pairs plot', plotaxes = FALSE,
    margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm'))
```


### Period

#### PC1vPC2
```{r, fig.width=8, fig.height=6.5, message=FALSE}
(PCA.colby.period <- biplot(p,
                            lab = paste0(metadata_forPCAtools$Subject),
                            colby = 'Period',
                            hline = 0, vline = 0,
                            legendPosition = 'right' +
                              geom_point(aes(text = metadata_forPCAtools$Subject))))

ggplotly(PCA.colby.period,
         tooltip = "text") 

```

#### Pairsplot
```{r, fig.width=10, fig.height=10, message=FALSE}
  pairsplot(p,
    components = getComponents(p, c(1:10)),
    triangle = TRUE, trianglelabSize = 12,
    hline = 0, vline = 0,
    pointSize = 0.4,
    gridlines.major = FALSE, gridlines.minor = FALSE,
    colby = 'Period',
    title = 'Pairs plot', plotaxes = FALSE,
    margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm'))
```



### Sequence

#### PC1vPC2
```{r, fig.width=8, fig.height=6.5, message=FALSE}
(PCA.colby.sequence <- biplot(p,
                            lab = paste0(metadata_forPCAtools$Subject),
                            colby = 'sequence',
                            hline = 0, vline = 0,
                            legendPosition = 'right' +
                              geom_point(aes(text = metadata_forPCAtools$Subject))))

ggplotly(PCA.colby.sequence,
         tooltip = "text") 

```

#### Pairsplot
```{r, fig.width=10, fig.height=10, message=FALSE}
  pairsplot(p,
    components = getComponents(p, c(1:10)),
    triangle = TRUE, trianglelabSize = 12,
    hline = 0, vline = 0,
    pointSize = 0.4,
    gridlines.major = FALSE, gridlines.minor = FALSE,
    colby = 'sequence',
    title = 'Pairs plot', plotaxes = FALSE,
    margingaps = unit(c(-0.01, -0.01, -0.01, -0.01), 'cm'))
```

## Eigen corplots
This is a cool way to explore the correlations between the metadata and the PCs! I want to look at how the metavariables correlate with PCs that account for 80% variation in the dataset. 

Again: How many PCs do we need to capture at least 80% variance?
```{r}
which(cumsum(p$variance) > 80)[1]
```

```{r, fig.width=12, fig.height=7.5, message=FALSE}

  eigencorplot(p,
    components = getComponents(p, 1:15), # get components that account for 80% variance
    metavars = colnames(metadata_forPCAtools),
    col = c('darkblue', 'blue2', 'gray', 'red2', 'darkred'),
    cexCorval = 0.7,
    colCorval = 'white',
    fontCorval = 2,
    posLab = 'bottomleft',
    rotLabX = 45,
    posColKey = 'top',
    cexLabColKey = 1.5,
    scale = TRUE,
    main = 'PC1-14 metadata correlations',
    colFrame = 'white',
    plotRsquared = FALSE)


```


```{r, fig.width=15, fig.height=7.5, message=FALSE}
  eigencorplot(p,
    components = getComponents(p, 1:15),
    metavars = colnames(metadata_forPCAtools),
    col = c('white', 'cornsilk1', 'gold', 'forestgreen', 'darkgreen'),
    cexCorval = 1.2,
    fontCorval = 2,
    posLab = 'all',
    rotLabX = 45,
    scale = TRUE,
    main = bquote(Principal ~ component ~ Pearson ~ r^2 ~ metadata ~ correlates),
    plotRsquared = TRUE,
    corFUN = 'pearson',
    corUSE = 'pairwise.complete.obs',
    corMultipleTestCorrection = 'BH',
    signifSymbols = c('****', '***', '**', '*', ''),
    signifCutpoints = c(0, 0.0001, 0.001, 0.01, 0.05, 1))
```


I am most interested in PCs affected by pre_post_intervention, so I think it would be good to investigate the metabolites that contribute the most to these PCs.

## Loadings plot
```{r, fig.width=10, fig.height=10}
# loadings plot for PCs 8 and 9
  plotloadings(p,
    components = getComponents(p, c(8,9)),
    rangeRetain = 0.1, absolute = TRUE,
    col = c('black', 'pink', 'red4'),
    drawConnectors = TRUE, labSize = 3,
    title = "Loadings plot",
    subtitle = "PC 8 and PC 9",
    caption = "Pre_post_intervention is highly correlated with these PCs") + coord_flip()
```



# Multilevel PCA

```{r}
library(mixOmics)
```


```{r}

Data_forMPCA <- DC_imp_metabind_clust_log2_noQCs %>%
  mutate_at("Subject", as.factor)
 

summary(as.factor(Data_forMPCA$Subject))

# make a vector for meta variables
(metavar <- Data_forMPCA[,c(1:11)] %>%
    colnames())
```

## PCA w/ outliers
```{r}
mixOmicsPCA.result <- mixOmics::pca(Data_forMPCA[,!names(Data_forMPCA) %in% metavar],
                            scale = FALSE,
                            center = FALSE)

plotIndiv(mixOmicsPCA.result, 
          ind.names = Data_forMPCA$Subject, 
          group = Data_forMPCA$pre_post_intervention, 
          legend = TRUE, 
          legend.title = "Treatment", 
          title = 'Regular PCA, HILIC (+), Log2 transformed')

```


## Multilevel PCA
With all data

### pre_post_intervention
```{r}
multilevelPCA.result <- mixOmics::pca(Data_forMPCA[,-(c(1:11))], 
                            multilevel = Data_forMPCA$Subject,
                            scale = FALSE,
                            center = FALSE)

plotIndiv(multilevelPCA.result, 
          ind.names = Data_forMPCA$Subject, 
          group = Data_forMPCA$pre_post_intervention, 
          legend = TRUE, 
          legend.title = "Treatment", 
          title = 'Multilevel PCA, HILIC (+), Log2 transformed')

```

#### Loadings 
```{r, fig.width=12, fig.height=12}
plotLoadings(multilevelPCA.result, ndisplay = 75)
```


### pre_post
```{r}
multilevelPCA.result <- mixOmics::pca(Data_forMPCA[,-(c(1:11))], 
                            multilevel = Data_forMPCA$Subject,
                            scale = FALSE,
                            center = FALSE)

plotIndiv(multilevelPCA.result, 
          ind.names = Data_forMPCA$Subject, 
          group = Data_forMPCA$pre_post, 
          legend = TRUE, 
          legend.title = "Treatment", 
          title = 'Multilevel PCA, HILIC (+), Log2 transformed')

```

#### Loadings 
```{r, fig.width=12, fig.height=12}
plotLoadings(multilevelPCA.result, ndisplay = 75, comp = 2)

```


# Univariate analysis

## Wrangle data

use tidy data
```{r}
# tidy df 
DC_imp_metabind_clust_tidy_log2 <- DC_imp_metabind_clust_log2 %>%
  pivot_longer(cols = 12:ncol(.),
               names_to = "mz_rt",
               values_to = "rel_abund_log2")

# use tidy data 
head(DC_imp_metabind_clust_tidy_log2)
```

```{r}

# remove QCs
df_for_stats <- DC_imp_metabind_clust_tidy_log2 %>%
  filter(Intervention != "QC")

# check if QCs were removed
unique(df_for_stats$Intervention)
```

```{r}
# df without outliers
df_for_stats_noOutlier <- df_for_stats %>%
  filter(Subject != "6106",
         Subject != "6112")

# check if outlier was removed
unique(df_for_stats_noOutlier$Subject)
```


```{r}
# turn off sci notation outputs
options(scipen = 999)
```


## Parametric tests

### Paired t tests

Here, I am comparing pre- to post-intervention for both yellow and tomato soy (Red) juice interventions. I also compare post-yellow to post-red intervention. I am using the log transformed values of rel abundance since parametric tests assume normality.

#### Ctrl
```{r}
# run paired t-tests for control intervention
ctrl_t.test_paired <- df_for_stats %>%
  filter(Intervention == "Yellow") %>%
  dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
ctrl_t.test_paired_sig <- ctrl_t.test_paired %>%
  filter(p <= 0.05)
tibble(ctrl_t.test_paired_sig)

# how many are significant?
nrow(ctrl_t.test_paired_sig)
```



#### Ctrl no outlier
```{r}
# run paired t-tests for control intervention
ctrl_noOutlier_t.test_paired <- df_for_stats_noOutlier %>%
  filter(Intervention == "Yellow") %>%
  dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
ctrl_noOutlier_t.test_paired_sig <- ctrl_noOutlier_t.test_paired %>%
  filter(p <= 0.05)
tibble(ctrl_noOutlier_t.test_paired_sig)

# how many are significant?
nrow(ctrl_noOutlier_t.test_paired_sig)
```


#### Red
```{r}
# run paired t-tests for control intervention
red_t.test_paired <- df_for_stats %>%
  filter(Intervention == "Red") %>%
  dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
red_t.test_paired_sig <- red_t.test_paired %>%
  filter(p <= 0.05)
tibble(red_t.test_paired_sig)

# how many are significant?
nrow(red_t.test_paired_sig)
```


#### Red no outlier
```{r}
# run paired t-tests for control intervention
red_noOutlier_t.test_paired <- df_for_stats_noOutlier %>%
  filter(Intervention == "Red") %>%
  dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
red_noOutlier_t.test_paired_sig <- red_noOutlier_t.test_paired %>%
  filter(p <= 0.05)
tibble(red_noOutlier_t.test_paired_sig)

# how many are significant?
nrow(red_noOutlier_t.test_paired_sig)
```


#### Post-red vs post-yellow

```{r}
# run paired t-tests for post interventions
post_t.test_paired <- df_for_stats %>%
  filter(pre_post == "post") %>%
  dplyr::select(Subject, Intervention, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ Intervention, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
post_t.test_paired_sig <- post_t.test_paired %>%
  filter(p <= 0.05)
tibble(post_t.test_paired_sig)

# how many are significant?
nrow(post_t.test_paired_sig)
```

#### Post-red vs post-yellow no Outlier

```{r}
# run paired t-tests for post interventions
post_noOutlier_t.test_paired <- df_for_stats %>%
  filter(pre_post == "post",
         Subject != "6106") %>%
  dplyr::select(Subject, Intervention, mz_rt, rel_abund_log2) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ Intervention, 
         paired = TRUE, 
         p.adjust.method = "BH") %>% # Benjamini-Hochberg controlling to lower false positives
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
post_noOutlier_t.test_paired_sig <- post_noOutlier_t.test_paired %>%
  filter(p <= 0.05)
tibble(post_noOutlier_t.test_paired_sig)

# how many are significant?
nrow(post_noOutlier_t.test_paired_sig)
```

#### Outlier comparison
Are there any significant features shared between tests with and without outlier?

```{r}
post_sig_outlier_comp <- list(post_noOutlier_t.test_paired_sig,
                              post_t.test_paired_sig) %>%
  reduce(inner_join, by = "mz_rt")

tibble(post_sig_outlier_comp)
# how many sig features are shared between df vs df w/o outliers
nrow(post_sig_outlier_comp)

# return sig features present only in df with outlier, and not in df without outlier
tibble(anti_join(post_noOutlier_t.test_paired_sig,
          post_t.test_paired_sig,
          by = "mz_rt"))

# return sig features from df without outlier that are also present in df with outlier
kable(semi_join(post_noOutlier_t.test_paired_sig,
          post_t.test_paired_sig,
          by = "mz_rt"))
```

### Standard comparisons

Here, I want to only focus on the metabolites that I hypothesized to change. This way I can avoid multiple correction adjustments and see if I can capture any significant differences at different timepoints

#### Wrangle

```{r}
stds_df_for_stats_wide <- df_for_stats %>%
  dplyr::select(!rel_abund) %>%
  pivot_wider(names_from = mz_rt,
              values_from = rel_abund_log2) %>%
  dplyr::select(c(1:11),
                "118.0867_4.678", #valine
                "147.0765_6.582", #glutamine
                "162.1129_5.651", #l-carnitine
                "166.0861_4.404", #phenylalanine
                "182.0808_5.647", #tyrosine
                "147.1129_8.251", #lysine
                "156.0772_7.669", #histidine
                "205.0972_4.752", #tryptophan
                "175.119_8.106", #arginine
                "241.0311_8.284" #cystine
                )

# make tidy df
stds_df_forstats_tidy <- stds_df_for_stats_wide %>%
  pivot_longer(cols = 12:ncol(.),
               names_to = "mz_rt",
               values_to = "rel_abund_log2")
```


```{r}
# changing factor levels for pre_post_intervention
stds_df_forstats_tidy$pre_post_intervention <- factor(stds_df_forstats_tidy$pre_post_intervention,
                              levels = c("pre_Yellow", "post_Yellow", "pre_Red", "post_Red"))

levels(stds_df_forstats_tidy$pre_post_intervention)  
```


#### Boxplots
```{r, fig.width=12}
stds_df_forstats_tidy %>% 
  ggplot(aes(x = pre_post_intervention, y = rel_abund_log2, fill = Intervention)) +
  geom_boxplot(outlier.shape = NA) +
  scale_fill_manual(values = c("Yellow" = "gold",
                                           "Red" = "tomato1")) +
  geom_line(aes(group = Subject), colour = "purple", linewidth = 0.2) +
  facet_wrap(vars(mz_rt), scales = "free_y") + 
  theme_bw() 
```

#### Control t-test
```{r}
# run paired t-tests for before vs. aftet control intervention
stds_ctrl_t.test_paired <- stds_df_forstats_tidy %>%
  filter(Intervention == "Yellow") %>%
  dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  filter(Subject != c(6106, 6112)) %>% # remove outliers
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE) %>% 
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
stds_ctrl_t.test_paired_sig <- stds_ctrl_t.test_paired %>%
  filter(p <= 0.05)
tibble(stds_ctrl_t.test_paired_sig)

# how many are significant?
nrow(stds_ctrl_t.test_paired_sig)
```

#### Red t-tests
```{r}
# run paired t-tests for before vs. after red intervention
stds_red_t.test_paired <- stds_df_forstats_tidy %>%
  filter(Intervention == "Red") %>%
  dplyr::select(Subject, pre_post, mz_rt, rel_abund_log2) %>%
  filter(Subject != c(6106, 6112)) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post, 
         paired = TRUE) %>% 
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
stds_red_t.test_paired_sig <- stds_red_t.test_paired %>%
  filter(p <= 0.05)
tibble(stds_red_t.test_paired_sig)

# how many are significant?
nrow(stds_red_t.test_paired_sig)
```

#### Intervention t-tests

```{r}
# run paired t-tests for post-red vs. post-control intervention
stds_post_t.test_paired <- stds_df_forstats_tidy %>%
  filter(pre_post == "post") %>%
  dplyr::select(Subject, pre_post_intervention, mz_rt, rel_abund_log2) %>%
  filter(Subject != c(6106, 6112)) %>%
  group_by(mz_rt) %>%
  t_test(rel_abund_log2 ~ pre_post_intervention, 
         paired = TRUE) %>% 
  add_significance()
```

Statistically significant features
```{r}
# which features are significant?
stds_post_t.test_paired_sig <- stds_post_t.test_paired %>%
  filter(p <= 0.05)
tibble(stds_post_t.test_paired_sig)

# how many are significant?
nrow(stds_post_t.test_paired_sig)
```

### Volcano plots

#### Post-intervention comparisons 

##### Wrangle

```{r}
# make a column with regular abundances (not log transformed)
df_for_stats <- df_for_stats %>%
  mutate(rel_abund = 2^(rel_abund_log2))
  

# calculate mean rel abund by sample, and avg fold change (FC) diff by feature
red_v_yellow_volcano_data <- df_for_stats %>%
  filter(pre_post == "post") %>%
  group_by(Intervention, mz_rt) %>%
  summarize(mean_rel_abund = mean(rel_abund)) %>%
  pivot_wider(names_from = Intervention, values_from = mean_rel_abund) %>%
  mutate(FC_postRed_div_postYellow = Red/Yellow) 

# bind back pval
red_v_yellow_tobind <- post_t.test_paired %>%
  dplyr::select(p)

# calculate log2FC, and -log10p
red_v_yellow_volcano_data <- 
  bind_cols(red_v_yellow_volcano_data, red_v_yellow_tobind) %>%
  mutate(log2_FC_postRed_div_postYellow = if_else(FC_postRed_div_postYellow > 0,
                                                  log2(FC_postRed_div_postYellow),
                                                  -(log2(abs(FC_postRed_div_postYellow)))), 
         neglog10p = -log10(p))

# set FC for features present in post-red but absent in post-yellow to a constant. I will choose 8. At this point I don't have any absent features so the data shouldn't change. 
red_v_yellow_volcano_data <- red_v_yellow_volcano_data %>%
  mutate(log2_FC_postRed_div_postYellow = if_else(is.infinite(log2_FC_postRed_div_postYellow),
                                                  8, log2_FC_postRed_div_postYellow))

# create a df of features passing FC and pval cutoffs higher in post-Red
higher_postRed <- red_v_yellow_volcano_data %>%
  filter(p <= 0.05 & log2_FC_postRed_div_postYellow >= 1)

# create a df of features passing FC and pval cutoffs higher in post-control
higher_postYellow <- red_v_yellow_volcano_data %>%
  filter(p <= 0.05 & log2_FC_postRed_div_postYellow <= -1)  
```


##### Export sig features
```{r, eval=FALSE}
write_csv(higher_postRed,
          "intervention-comp-sig-RED-HILICPos-14Jun23.csv")

write_csv(higher_postYellow,
          "intervention-comp-sig-YELLOW-HILICPos-14Jun23.csv")
```


##### Plot
```{r}
(red_v_yellow_volcano <- red_v_yellow_volcano_data %>%
  ggplot(aes(x = log2_FC_postRed_div_postYellow, y = neglog10p, 
             text = glue("Mass_retention time: {mz_rt}
                         P-value: {p}
                         Fold change tomato/control: {round(FC_postRed_div_postYellow, 2)}"))) +
  geom_point(color = "grey") +
  geom_point(data = higher_postRed, 
             aes(x = log2_FC_postRed_div_postYellow, y = neglog10p),
             color = "tomato") +
  geom_point(data = higher_postYellow, 
             aes(x = log2_FC_postRed_div_postYellow, y = neglog10p),
             color = "yellow2") +
  geom_vline(xintercept = 1, linetype = "dashed", color = "grey") +
  geom_vline(xintercept = -1, linetype = "dashed", color = "grey") +
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "grey") +
  coord_cartesian(xlim = c(-5, 8)) +
  labs(title = "Volcano Plot of Features Different in People After Tomato-Soy and Control Juice Consumption",
       subtitle = "Red points are higher after tomato-soy juice consumption while yellow points are higher \nafter control tomato juice consumption",
       caption = "Vertical dashed lines represent a log fold change >1 or < -1, and horizontal dashed line represents an FDR corrected \np-value of 0.05.",
       x = "Log2 Fold Change (TomatoSoy/Control)",
       y = "-Log10(P-value)") +
  theme_bw() +
  theme(plot.title = element_text(size = 12, hjust = 0),
        plot.caption = element_text(hjust = 0.5)))

(red_v_yellow_volcano_ggplotly <- ggplotly(red_v_yellow_volcano, tooltip = "text"))
```

Save plots
```{r, eval=FALSE}
# save volcano plot
ggsave(plot = red_v_yellow_volcano,
       filename = "red_v_yellow_volcano.svg")

# save interactive volcano plot
saveWidget(widget = red_v_yellow_volcano_ggplotly,
           file = "interactive_redvyellow_volcano_plot.html")
```


##### Wrangle (no outlier)
```{r}
# calculate mean rel abund (not log) by sample, and avg fold change (FC) diff by feature
red_v_yel_volcano_data_noOutlier <- df_for_stats %>%
  filter(pre_post == "post",
         Subject != 6106,
         Subject != 6112) %>% # remove outlier subj
  group_by(Intervention, mz_rt) %>%
  summarize(mean_rel_abund = mean(rel_abund)) %>%
  pivot_wider(names_from = Intervention, values_from = mean_rel_abund) %>%
  mutate(FC_postRed_div_postYellow = Red/Yellow) 

# bind back pval
red_v_yel_tobind_noOutlier <- post_noOutlier_t.test_paired %>%
  dplyr::select(p)

# calculate log2FC, and -log10p
red_v_yel_volcano_data_noOutlier <- 
  bind_cols(red_v_yel_volcano_data_noOutlier, red_v_yel_tobind_noOutlier) %>%
  mutate(log2_FC_postRed_div_postYellow = if_else(FC_postRed_div_postYellow > 0,
                                                  log2(FC_postRed_div_postYellow),
                                                  -(log2(abs(FC_postRed_div_postYellow)))), 
         neglog10p = -log10(p))

# set FC for features present in post-red but absent in post-yellow to a constant. I will choose 8. At this point I don't have any absent features so the data shouldn't change. 
red_v_yel_volcano_data_noOutlier <- red_v_yel_volcano_data_noOutlier %>%
  mutate(log2_FC_postRed_div_postYellow = if_else(is.infinite(log2_FC_postRed_div_postYellow),
                                                  8, log2_FC_postRed_div_postYellow))

# create a df of features passing FC and pval cutoffs higher in post-Red
higher_postRed_noOutlier <- red_v_yel_volcano_data_noOutlier %>%
  filter(p <= 0.05 & log2_FC_postRed_div_postYellow >= 0.6)

# create a df of features passing FC and pval cutoffs higher in post-control
higher_postYellow_noOutlier <- red_v_yel_volcano_data_noOutlier %>%
  filter(p <= 0.05 & log2_FC_postRed_div_postYellow <= -0.6)  
```

##### Export sig features
```{r, eval=FALSE}
write_csv(higher_postRed_noOutlier,
          "intervention-comp-sig-RED-nooutliers-HILICPos-newlog2fc-06-11Sept23.csv")

write_csv(higher_postYellow_noOutlier,
          "intervention-comp-sig-YELLOW-nooutliers-HILICPos-newlog2fc-06-11Sept23.csv")
```

Create feature lists with significant features along with their clusters
```{r}
red_sigfeatures_intervention_comp <- left_join(higher_postRed_noOutlier, cluster_features,
                                               by = "mz_rt")

write_csv(red_sigfeatures_intervention_comp,
          "postRed-sigfeatures-interventioncomp-noOutliers-hilicpos-log2fc-06-11Sept23.csv")


yellow_sigfeatures_intervention_comp <- left_join(higher_postYellow_noOutlier, cluster_features,
                                               by = "mz_rt")

write_csv(yellow_sigfeatures_intervention_comp,
          "postYellow-sigfeatures-interventioncomp-noOutliers-hilicpos-log2fc-06-11Sept23.csv")
```


##### Plot
```{r}
(red_v_yellow_volcano_noOutlier <- red_v_yel_volcano_data_noOutlier %>%
  ggplot(aes(x = log2_FC_postRed_div_postYellow, y = neglog10p, 
             text = glue("Mass_retention time: {mz_rt}
                         P-value: {p}
                         Fold change tomato/control: {round(FC_postRed_div_postYellow, 2)}"))) +
  geom_point(color = "grey") +
  geom_point(data = higher_postRed_noOutlier, 
             aes(x = log2_FC_postRed_div_postYellow, y = neglog10p),
             color = "tomato") +
  geom_point(data = higher_postYellow_noOutlier, 
             aes(x = log2_FC_postRed_div_postYellow, y = neglog10p),
             color = "yellow2") +
  geom_vline(xintercept = 1, linetype = "dashed", color = "grey") +
  geom_vline(xintercept = -1, linetype = "dashed", color = "grey") +
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "grey") +
  coord_cartesian(xlim = c(-5, 8)) +
  labs(title = "Volcano Plot of Features Different in People After Tomato-Soy and Control Juice Consumption",
       subtitle = "Red points are higher after tomato-soy juice consumption while yellow points are higher \nafter control tomato juice consumption. Subject 6106 removed",
       caption = "Vertical dashed lines represent a log fold change >1 or < -1, and horizontal dashed line represents an FDR corrected \np-value of 0.05.",
       x = "Log2 Fold Change (TomatoSoy/Control)",
       y = "-Log10(P-value)") +
  theme_bw() +
  theme(plot.title = element_text(size = 12, hjust = 0),
        plot.caption = element_text(hjust = 0.5)))

(red_v_yellow_volcano_ggplotly_noOutlier <- ggplotly(red_v_yellow_volcano_noOutlier, tooltip = "text"))
```

Save plots
```{r, eval=FALSE}
# save volcano plot
ggsave(plot = red_v_yellow_volcano_noOutlier,
       filename = "red_v_yellow_volcano_noOutlier.svg")

# save interactive volcano plot
saveWidget(widget = red_v_yellow_volcano_ggplotly_noOutlier,
           file = "interactive_redvyellow_volcano_plot_noOutlier.html")
```


#### Red

##### Wrangle
```{r}
# calculate mean rel abund (not log) by sample, and avg fold change (FC) diff by feature
red_volcano_data <- df_for_stats %>%
  filter(Intervention == "Red") %>%
  group_by(pre_post, mz_rt) %>%
  summarize(mean_rel_abund = mean(rel_abund)) %>%
  pivot_wider(names_from = pre_post, values_from = mean_rel_abund) %>%
  mutate(FC_post_div_pre = post/pre) 

# bind back pval
red_tobind <- red_t.test_paired %>%
  dplyr::select(p)

# calculate log2FC, and -log10p
red_volcano_data <- 
  bind_cols(red_volcano_data, red_tobind) %>%
  mutate(log2_FC_post_div_pre = if_else(FC_post_div_pre > 0,
                                        log2(FC_post_div_pre),
                                        -(log2(abs(FC_post_div_pre)))), 
         neglog10p = -log10(p))

# set FC for features present in post-red but absent in post-yellow to a constant. Only use if there are 0s in data
#red_volcano_data <- red_volcano_data %>%
  #mutate(log2_FC_post_div_pre = if_else(is.infinite(log2_FC_post_div_pre),
                                                  #8, log2_FC_post_div_pre))

# create a df of features passing FC and pval cutoffs higher in post-intervention compared to pre
red_higher_post <- red_volcano_data %>%
  filter(p <= 0.05 & log2_FC_post_div_pre >= 1)

```

##### Export sig features 

Save file of features that pass FC and pvalue cutoffs
```{r, eval=FALSE}
write_csv(red_higher_post,
          "pre-post-sig-RED-HILICPos-14Jun23.csv")
```



##### Plot
```{r}
(red_volcano <- red_volcano_data %>%
  ggplot(aes(x = log2_FC_post_div_pre, y = neglog10p, 
             text = glue("Mass_retention time: {mz_rt}
                         P-value: {p}
                         Fold change post/pre: {round(FC_post_div_pre, 2)}"))) +
  geom_point(color = "grey") +
  geom_point(data = red_higher_post, 
             aes(x = log2_FC_post_div_pre, y = neglog10p),
             color = "tomato") +
  geom_vline(xintercept = 1, linetype = "dashed", color = "grey") +
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "grey") +
  coord_cartesian(xlim = c(-5, 8)) +
  labs(title = "Volcano Plot of Features Different in People After Tomato-Soy Juice Consumption",
       subtitle = "Red points are higher after tomato-soy juice consumption when compared to prior to consumption",
       caption = "Vertical dashed line represents a log fold change >1, and horizontal dashed line represents an FDR corrected \np-value of 0.05.",
       x = "Log2 Fold Change (Post/Pre)",
       y = "-Log10(P-value)") +
  theme_bw() +
  theme(plot.title = element_text(size = 12, hjust = 0),
        plot.caption = element_text(hjust = 0.5)))

(red_volcano_ggplotly <- ggplotly(red_volcano, tooltip = "text"))
```

Save plots
```{r, eval=FALSE}
# save volcano plot
ggsave(plot = red_volcano,
       filename = "red_volcano.svg")

# save interactive volcano plot
saveWidget(widget = red_volcano_ggplotly,
           file = "interactive_red_volcano_plot.html")
```



##### Wrangle (no outlier)
```{r}
# calculate mean rel abund (not log) by sample, and avg fold change (FC) diff by feature
red_volcano_data_noOutlier <- df_for_stats %>%
  filter(Intervention == "Red",
         Subject != 6106,
         Subject != 6112) %>%
  group_by(pre_post, mz_rt) %>%
  summarize(mean_rel_abund = mean(rel_abund)) %>%
  pivot_wider(names_from = pre_post, values_from = mean_rel_abund) %>%
  mutate(FC_post_div_pre = post/pre) 

# bind back pval
red_tobind_noOutlier <- red_noOutlier_t.test_paired %>%
  dplyr::select(p)

# calculate log2FC, and -log10p
red_volcano_data_noOutlier <- 
  bind_cols(red_volcano_data_noOutlier, red_tobind_noOutlier) %>%
  mutate(log2_FC_post_div_pre = if_else(FC_post_div_pre > 0,
                                        log2(FC_post_div_pre),
                                        -(log2(abs(FC_post_div_pre)))), 
         neglog10p = -log10(p))

# set FC for features present in post-red but absent in post-yellow to a constant. Only use if there are 0s in data
#red_volcano_data_noOutlier <- red_volcano_data_noOutlier %>%
  #mutate(log2_FC_post_div_pre = if_else(is.infinite(log2_FC_post_div_pre),
                                                  #8, log2_FC_post_div_pre))

# create a df of features passing FC and pval cutoffs higher in post-intervention compared to pre
red_higher_post_noOutlier <- red_volcano_data_noOutlier %>%
  filter(p <= 0.05 & log2_FC_post_div_pre >= 1)

```

##### Export sig features
```{r, eval=FALSE}
write_csv(red_higher_post_noOutlier,
          "pre-post-sig-RED-nooutliers-HILICPos-14Jun23.csv")
```


Create feature lists with significant features along with their clusters
```{r}
red_sigfeatures_pre_vs_post_comp <- left_join(red_higher_post_noOutlier, cluster_features,
                                               by = "mz_rt")

write_csv(red_sigfeatures_pre_vs_post_comp,
          "Red-sigfeatures-PrevsPost-noOutliers.csv")

```


##### Plot
```{r}
(red_volcano_noOutlier <- red_volcano_data_noOutlier %>%
  ggplot(aes(x = log2_FC_post_div_pre, y = neglog10p, 
             text = glue("Mass_retention time: {mz_rt}
                         P-value: {p}
                         Fold change post/pre: {round(FC_post_div_pre, 2)}"))) +
  geom_point(color = "grey") +
  geom_point(data = red_higher_post_noOutlier, 
             aes(x = log2_FC_post_div_pre, y = neglog10p),
             color = "tomato") +
  geom_vline(xintercept = 1, linetype = "dashed", color = "grey") +
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "grey") +
  coord_cartesian(xlim = c(-5, 8)) +
  labs(title = "Volcano Plot of Features Different in People After Tomato-Soy Juice Consumption",
       subtitle = "Red points are higher after tomato-soy juice consumption when compared to prior to consumption",
       caption = "Vertical dashed line represents a log fold change >1, and horizontal dashed line represents an FDR corrected \np-value of 0.05.",
       x = "Log2 Fold Change (Post/Pre)",
       y = "-Log10(P-value)") +
  theme_bw() +
  theme(plot.title = element_text(size = 12, hjust = 0),
        plot.caption = element_text(hjust = 0.5)))

(red_volcano_ggplotly_noOutlier <- ggplotly(red_volcano_noOutlier, tooltip = "text"))
```

Save plots
```{r, eval=FALSE}
# save volcano plot
ggsave(plot = red_volcano_noOutlier,
       filename = "red_volcano_noOutlier.svg")

# save interactive volcano plot
saveWidget(widget = red_volcano_ggplotly_noOutlier,
           file = "interactive_red_volcano_plot_noOutlier.html")
```



#### Yellow

##### Wrangle
```{r}
# calculate mean rel abund (not log) by sample, and avg fold change (FC) diff by feature
yel_volcano_data <- df_for_stats %>%
  filter(Intervention == "Yellow") %>%
  group_by(pre_post, mz_rt) %>%
  summarize(mean_rel_abund = mean(rel_abund)) %>%
  pivot_wider(names_from = pre_post, values_from = mean_rel_abund) %>%
  mutate(FC_post_div_pre = post/pre) 

# bind back pval
yel_tobind <- ctrl_t.test_paired %>%
  dplyr::select(p)

# calculate log2FC, and -log10p
yel_volcano_data <- 
  bind_cols(yel_volcano_data, yel_tobind) %>%
  mutate(log2_FC_post_div_pre = if_else(FC_post_div_pre > 0,
                                        log2(FC_post_div_pre),
                                        -(log2(abs(FC_post_div_pre)))), 
         neglog10p = -log10(p))

# set FC for features present in post-red but absent in post-yellow to a constant. Only use if there are 0s in data
#yel_volcano_data <- yel_volcano_data %>%
  #mutate(log2_FC_post_div_pre = if_else(is.infinite(log2_FC_post_div_pre),
                                                  #8, log2_FC_post_div_pre))

# create a df of features passing FC and pval cutoffs higher in post-intervention compared to pre
yellow_higher_post <- yel_volcano_data %>%
  filter(p <= 0.05 & log2_FC_post_div_pre >= 1)

```

##### Export sig features
```{r, eval=FALSE}
write_csv(yellow_higher_post,
          "pre-post-sig-YELLOW-HILICPos-14Jun23.csv")
```


##### Plot
```{r}
(yellow_volcano <- yel_volcano_data %>%
  ggplot(aes(x = log2_FC_post_div_pre, y = neglog10p, 
             text = glue("Mass_retention time: {mz_rt}
                         P-value: {p}
                         Fold change post/pre: {round(FC_post_div_pre, 2)}"))) +
  geom_point(color = "grey") +
  geom_point(data = yellow_higher_post, 
             aes(x = log2_FC_post_div_pre, y = neglog10p),
             color = "yellow2") +
  geom_vline(xintercept = 1, linetype = "dashed", color = "grey") +
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "grey") +
  coord_cartesian(xlim = c(-5, 8)) +
  labs(title = "Volcano Plot of Features Different in People After Control, Yellow Tomato Juice Consumption",
       subtitle = "Yellow points are higher after control juice consumption when compared to prior to consumption",
       caption = "Vertical dashed line represents a log fold change >1, and horizontal dashed line represents an FDR corrected \np-value of 0.05.",
       x = "Log2 Fold Change (Post/Pre)",
       y = "-Log10(P-value)") +
  theme_bw() +
  theme(plot.title = element_text(size = 12, hjust = 0),
        plot.caption = element_text(hjust = 0.5)))

(yellow_volcanoo_ggplotly <- ggplotly(yellow_volcano, tooltip = "text"))
```

Save plots
```{r, eval=FALSE}
# save volcano plot
ggsave(plot = yellow_volcano,
       filename = "yellow_volcano.svg")

# save interactive volcano plot
saveWidget(widget = red_volcano_ggplotly,
           file = "interactive_red_volcano_plot.html")
```



##### Wrangle (no outlier)
```{r}
# calculate mean rel abund (not log) by sample, and avg fold change (FC) diff by feature
yel_volcano_data_noOutlier <- df_for_stats %>%
  filter(Intervention == "Yellow",
         Subject != 6106,
         Subject != 6106) %>%
  group_by(pre_post, mz_rt) %>%
  summarize(mean_rel_abund = mean(rel_abund)) %>%
  pivot_wider(names_from = pre_post, values_from = mean_rel_abund) %>%
  mutate(FC_post_div_pre = post/pre) 

# bind back pval
yel_tobind_noOutlier <- ctrl_noOutlier_t.test_paired %>%
  dplyr::select(p)

# calculate log2FC, and -log10p
yel_volcano_data_noOutlier <- 
  bind_cols(yel_volcano_data_noOutlier, yel_tobind_noOutlier) %>%
  mutate(log2_FC_post_div_pre = if_else(FC_post_div_pre > 0,
                                        log2(FC_post_div_pre),
                                        -(log2(abs(FC_post_div_pre)))), 
         neglog10p = -log10(p))

# set FC for features present in post-red but absent in post-yellow to a constant. Only use if there are 0s in data
#yel_volcano_data_noOutlier <- yel_volcano_data_noOutlier %>%
  #mutate(log2_FC_post_div_pre = if_else(is.infinite(log2_FC_post_div_pre),
                                                  #8, log2_FC_post_div_pre))

# create a df of features passing FC and pval cutoffs higher in post-intervention compared to pre
yel_higher_post_noOutlier <- yel_volcano_data_noOutlier %>%
  filter(p <= 0.05 & log2_FC_post_div_pre >= 1)

```

##### Export sig features
```{r, eval=FALSE}
write_csv(yel_higher_post_noOutlier,
          "pre-post-sig-YELLOW-nooutliers-HILICPos-14Jun23.csv")
```


Create feature lists with significant features along with their clusters
```{r}
yellow_sigfeatures_pre_vs_post_comp <- left_join(yellow_higher_post, cluster_features,
                                               by = "mz_rt")

write_csv(yellow_sigfeatures_pre_vs_post_comp,
          "Yellow-sigfeatures-PrevsPost-noOutliers.csv")

```

##### Plot
```{r}
(yel_volcano_noOutlier <- yel_volcano_data_noOutlier %>%
  ggplot(aes(x = log2_FC_post_div_pre, y = neglog10p, 
             text = glue("Mass_retention time: {mz_rt}
                         P-value: {p}
                         Fold change post/pre: {round(FC_post_div_pre, 2)}"))) +
  geom_point(color = "grey") +
  geom_point(data = yel_higher_post_noOutlier, 
             aes(x = log2_FC_post_div_pre, y = neglog10p),
             color = "yellow2") +
  geom_vline(xintercept = 1, linetype = "dashed", color = "grey") +
  geom_hline(yintercept = 1.3, linetype = "dashed", color = "grey") +
  coord_cartesian(xlim = c(-5, 8)) +
  labs(title = "Volcano Plot of Features Different in People After Control, Yellow Tomato Juice Consumption",
       subtitle = "Yellow points are higher after control juice consumption when compared to prior to consumption.\nSubject 6106 removed",
       caption = "Vertical dashed line represents a log fold change >1, and horizontal dashed line represents an FDR corrected \np-value of 0.05.",
       x = "Log2 Fold Change (Post/Pre)",
       y = "-Log10(P-value)") +
  theme_bw() +
  theme(plot.title = element_text(size = 12, hjust = 0),
        plot.caption = element_text(hjust = 0.5)))

(yel_volcano_ggplotly_noOutlier <- ggplotly(yel_volcano_noOutlier, tooltip = "text"))
```

Save plots
```{r, eval=FALSE}
# save volcano plot
ggsave(plot = yel_volcano_noOutlier,
       filename = "yel_volcano_noOutlier.svg")

# save interactive volcano plot
saveWidget(widget = yel_volcano_ggplotly_noOutlier,
           file = "interactive_yel_volcano_plot_noOutlier.html")
```


## Joined lists
Here, I want to venn significant features before I begin to look more into them. I am interested in the following effects: tomato effect, lycopene and/or soy isoflavones effect.

1. Tomato effect: join a list that only keeps features that are both significant in pre vs. post-red and pre vs. post-yellow.

```{r}
# keep only features present in both pre vs post red and pre vs post yellow
tomato_effect <- inner_join(red_sigfeatures_pre_vs_post_comp,
                            yellow_sigfeatures_pre_vs_post_comp,
                            by = "mz_rt")
```

Export venned list
```{r}
write_csv(tomato_effect,
          "Feature lists/sig-features-tomato-effect.csv")
```

2. lycopene and/or soy isoflavones effect: join a list that only keeps features that are both significant between post-Red and post-Yellow timepoints, and significant between pre- and post-Red. These features are NOT significant between pre-Yellow and post-Yellow.

```{r}
# combine sig features from post-red vs post-yellow
higher_postintervention_noOutlier <- full_join(red_sigfeatures_intervention_comp,
                                               yellow_sigfeatures_intervention_comp)
dim(higher_postintervention_noOutlier)

# select only sig features that are present when comparing pre-Red to post-Red
lyc_soy_effect <- inner_join(higher_postintervention_noOutlier,
                             red_sigfeatures_pre_vs_post_comp,
                             by = "mz_rt") 
dim(lyc_soy_effect)
# remove features that are significant pre-Yellow vs post-Yellow comparison
lyc_soy_effect <- anti_join(lyc_soy_effect,
                            yellow_sigfeatures_pre_vs_post_comp,
                            by = "mz_rt")
dim(lyc_soy_effect) # how many features were removed?
```

Export venned list
```{r}
write_csv(lyc_soy_effect,
          "Feature lists/sig-features-lyc-soy-effect.csv")
```


# Immuno correlations

Here, I am going to look at correlations between the changes in each outcome from pre to post-red interventions. I can do this for post-intervention comparisons also.

## Wrangle (no outliers)

IL-5 was significantly decreased after tomato-soy intervention (only when comparing pre to post in Red). x25_cd19_cd3_b_cells and x26_cd27_ig_d_naive_b_cells were significantly increased from pre to post-Red, so let's see how these significant immuno outcomes correlate with metabolites found to be significant at p > 0.05 (and FC >= 2).

Import other outcomes (carotenoids and immunology data)
```{r}
# load data
carot_immunology_meta <- read_excel("CompiledData_Results_Meta.xlsx",
                         sheet = "metadata_corrected_withsequence")

# clean up variable names 
carot_immunology_meta <- clean_names(carot_immunology_meta)
```


```{r}
# convert variables that should be factors to factors
carot_immunology_meta <- carot_immunology_meta %>%
  filter(intervention != "Baseline") %>%
  mutate(across(.cols = c("patient_id", "period", 
                          "intervention", "intervention_week", 
                          "pre_post", "sex", "sequence"),
                .fns = as.factor))


# some stuff came in as characters but should be numeric
carot_immunology_meta <- carot_immunology_meta %>%
  mutate(across(.cols = c("il_2", "il_10", "il_13", "il_4"),
                .fns = as.numeric))



# changing factor levels for pre_post
carot_immunology_meta$pre_post <- factor(carot_immunology_meta$pre_post,
                              levels = c("pre", "post"))

levels(carot_immunology_meta$pre_post)        

# Calculate total_cis_lyc, total_lyc, and total_carotenoids
carot_immunology_meta <- carot_immunology_meta %>%
  mutate(total_cis_lyc = other_cis_lyc + x5_cis_lyc,
         total_lyc = all_trans_lyc + total_cis_lyc,
         total_carotenoids = lutein + zeaxanthin + b_cryptoxanthin + 
                             a_carotene + b_carotene + total_lyc)
```


```{r}
# go back to wide for stats df
df_for_stats_wide_noOutlier <- df_for_stats_noOutlier %>%
  dplyr::select(!rel_abund) %>%
  pivot_wider(names_from = mz_rt,
              values_from = rel_abund_log2)

# take outliers out of carot_immuno df 
carot_immunology_meta_noOutlier <- carot_immunology_meta %>%
  filter(patient_id != 6106) %>%
  filter(patient_id != 6112)

# add immuno outcome columns to dataset
forcorr_metabslog2_immuno_noOutlier <- df_for_stats_wide_noOutlier %>%
  mutate(il_5 = carot_immunology_meta_noOutlier$il_5) %>%
  mutate(CD19pos_Bcells = carot_immunology_meta_noOutlier$x25_cd19_cd3_b_cells) %>%
  mutate(IgDpos_naiveBcells = carot_immunology_meta_noOutlier$x26_cd27_ig_d_naive_b_cells)
```


Subset df's into pre and post 
```{r}
# pre
forcorr_pre_metabslog2_immuno_noOutlier <- forcorr_metabslog2_immuno_noOutlier %>%
  dplyr::select(Subject, Intervention, pre_post, 12:ncol(.)) %>%
  filter(pre_post == "pre")

# post 
forcorr_post_metabslog2_immuno_noOutlier <- forcorr_metabslog2_immuno_noOutlier %>%
  dplyr::select(Subject, Intervention, pre_post, 12:ncol(.)) %>%
  filter(pre_post == "post")
```

Create df with differences calculated for each outcome
```{r}
# difference for calculated for each outcome
forcorr_diff_red_metabslog2_immuno_noOutlier <- forcorr_post_metabslog2_immuno_noOutlier[,4:1087] - forcorr_pre_metabslog2_immuno_noOutlier[,4:1087]

```

## Corr table
These are correlations based on significant metabolites with p value < 0.05 AND FC > 2

```{r}
library(corrr) # correlations

# add subject and intervention back to df. Select only significant metabolites (pval > 0.05 and FC >=2)
forcorr_diff_red_metabslog2_immuno_noOutlier <- forcorr_diff_red_metabslog2_immuno_noOutlier %>%
  mutate(Subject = forcorr_post_metabslog2_immuno_noOutlier$Subject,
         Intervention = forcorr_post_metabslog2_immuno_noOutlier$Intervention) %>%
  filter(Intervention == "Red") %>%
  dplyr::select(Subject, Intervention, il_5, CD19pos_Bcells, IgDpos_naiveBcells, all_of(higher_postRed_noOutlier$mz_rt))

# correlation table
red_corr_results_metabs_immuno_diff_noOutlier <- forcorr_diff_red_metabslog2_immuno_noOutlier %>% 
  correlate() 

kable(red_corr_results_metabs_immuno_diff_noOutlier, format = "markdown", digits = 3)

# metabolites strongly correlated with immuno outcomes. R^2 >= to 0.5
red_sigcorr_metabsP05_FC2_immunodata <- red_corr_results_metabs_immuno_diff_noOutlier %>%
  dplyr::select(term, il_5, CD19pos_Bcells, IgDpos_naiveBcells) %>%
  filter(abs(red_corr_results_metabs_immuno_diff_noOutlier$il_5) >= 0.5 | abs(red_corr_results_metabs_immuno_diff_noOutlier$CD19pos_Bcells) >= 0.5 | abs(red_corr_results_metabs_immuno_diff_noOutlier$IgDpos_naiveBcells) >= 0.5)

kable(red_sigcorr_metabsP05_FC2_immunodata, digits = 3)

```


```{r, fig.height=12, fig.width=12}

library(ggcorrplot)

red_corr_noOutlier <- round(cor(forcorr_diff_red_metabslog2_immuno_noOutlier[,-c(1:2)]), 2)


red_corr_noOutlier[,c(1:3)] %>%
  ggcorrplot(lab = TRUE, outline.color = "white", ggtheme = ggplot2::theme_gray,
  colors = c("#6D9EC1", "white", "#E46726")) +
  theme(axis.text.x = element_text(angle = 45, size = 12),
        axis.text.y = element_text(size = 12)) +
  coord_flip()


```

```{r, fig.width=20, fig.height=18}
#
red_p.mat <- cor_pmat(forcorr_diff_red_metabslog2_immuno_noOutlier[,-c(1:2)])

red_corr_noOutlier[] %>%
  ggcorrplot(lab = TRUE, outline.color = "white", hc.order = TRUE, type = "lower", p.mat = red_p.mat, insig = "blank") +
  theme(axis.text.x = element_text(angle = 45, size = 12),
        axis.text.y = element_text(size = 12))

```

### Corr scatterplots

```{r, fig.width=12, fig.height=12}
forcorr_diff_red_metabslog2_immuno_noOutlier_tidy <- forcorr_diff_red_metabslog2_immuno_noOutlier %>%
  pivot_longer(cols = 6:ncol(.),
               names_to = "mz_rt",
               values_to = "rel_abund_log2")

forcorr_diff_red_metabslog2_immuno_noOutlier_tidy %>%
  ggplot(aes(x = 	il_5, y = rel_abund_log2, color = mz_rt)) +
  geom_smooth(method=lm, show.legend = FALSE) +
  geom_point(show.legend = FALSE) +
  theme_bw() +
  facet_wrap(vars(mz_rt), scales = "free")
```



## Corr table 2
These are correlations based on significant metabolites with p value < 0.05 only.

```{r}
# difference for calculated for each outcome
forcorr2_diff_red_metabslog2_immuno_noOutlier <- forcorr_post_metabslog2_immuno_noOutlier[,4:1087] - forcorr_pre_metabslog2_immuno_noOutlier[,4:1087]

# add subject and intervention back to df. Select only significant metabolites (pval < 0.05)
forcorr2_diff_red_metabslog2_immuno_noOutlier <- forcorr2_diff_red_metabslog2_immuno_noOutlier %>%
  mutate(Subject = forcorr_post_metabslog2_immuno_noOutlier$Subject,
         Intervention = forcorr_post_metabslog2_immuno_noOutlier$Intervention) %>%
  filter(Intervention == "Red") %>%
  dplyr::select(Subject, Intervention, il_5, CD19pos_Bcells, IgDpos_naiveBcells, all_of(red_noOutlier_t.test_paired_sig$mz_rt))

# correlation table
red2_corr_results_metabs_immuno_diff_noOutlier <- forcorr2_diff_red_metabslog2_immuno_noOutlier %>% 
  correlate() 

kable(red2_corr_results_metabs_immuno_diff_noOutlier, format = "markdown", digits = 3)

# metabolites strongly correlated with immuno outcomes. R^2 >= to 0.5
red2_sigcorr_metabsP05_immunodata <- red2_corr_results_metabs_immuno_diff_noOutlier %>%
  dplyr::select(term, il_5, CD19pos_Bcells, IgDpos_naiveBcells) %>%
  filter(abs(red2_corr_results_metabs_immuno_diff_noOutlier$il_5) >= 0.5 | abs(red2_corr_results_metabs_immuno_diff_noOutlier$CD19pos_Bcells) >= 0.5 | abs(red2_corr_results_metabs_immuno_diff_noOutlier$IgDpos_naiveBcells) >= 0.5)

kable(red2_sigcorr_metabsP05_immunodata, digits = 3)

```


```{r, fig.width=15, fig.height=5}
red2_corr_noOutlier <- round(cor(forcorr2_diff_red_metabslog2_immuno_noOutlier[,-c(1:2)]), 2)


red2_corr_noOutlier[,c(1:3)] %>%
  ggcorrplot(lab = FALSE, outline.color = "white", ggtheme = ggplot2::theme_gray(base_size = 8),
  colors = c("#6D9EC1", "white", "#E46726")) +
  theme(axis.text.x = element_text(angle = 90)) + 
  geom_tile(size = 2) + 
  coord_fixed(ratio = 3)
```

```{r, fig.width=20, fig.height=18}
#
red2_p.mat <- cor_pmat(forcorr2_diff_red_metabslog2_immuno_noOutlier[,-c(1:2)])

red2_corr_noOutlier %>%
  ggcorrplot(lab = FALSE, outline.color = "white", hc.order = TRUE, type = "lower", p.mat = red2_p.mat, insig = "blank") +
  theme(axis.text.x = element_text(angle = 45, size = 12),
        axis.text.y = element_text(size = 12))

```


## Just IL-5
```{r}
# difference calc
forcorr_diff_red_metabslog2_IL5_noOutlier <- forcorr_post_metabslog2_immuno_noOutlier[,4:1087] - forcorr_pre_metabslog2_immuno_noOutlier[,4:1087]

# add subject and intervention back to df. Select only significant metabolites (pval > 0.05 and FC >=2)
forcorr_diff_red_metabslog2_IL5_noOutlier <- forcorr_diff_red_metabslog2_IL5_noOutlier %>%
  mutate(Subject = forcorr_post_metabslog2_immuno_noOutlier$Subject,
         Intervention = forcorr_post_metabslog2_immuno_noOutlier$Intervention) %>%
  filter(Intervention == "Red") %>%
  dplyr::select(Subject, Intervention, il_5, all_of(red_higher_post_noOutlier$mz_rt))

# correlation table
red_corr_results_metabs_IL5_diff_noOutlier <- forcorr_diff_red_metabslog2_IL5_noOutlier %>% 
  correlate() %>%
  rearrange() %>%
  shave()

kable(red_corr_results_metabs_IL5_diff_noOutlier, format = "markdown", digits = 3)

# metabolites strongly correlated with immuno outcomes. R^2 >= to 0.5
red_sigcorr_metabsP05_FC2_IL5data <- red_corr_results_metabs_IL5_diff_noOutlier %>%
  dplyr::select(term, il_5) %>%
  filter(abs(red_corr_results_metabs_IL5_diff_noOutlier$il_5) >= 0.5)

kable(red_sigcorr_metabsP05_FC2_IL5data, digits = 3)

```



```{r, fig.height=10, fig.width=10}

fashion(red_corr_results_metabs_IL5_diff_noOutlier)

corrr::rplot(red_corr_results_metabs_IL5_diff_noOutlier[],
             print_cor = TRUE,
             shape = 16) +
  theme_bw(base_size = 11) +
  theme(axis.text.x = element_text(angle = 0)) +
  coord_fixed(ratio = 1)



```


```{r, fig.width=16, fig.height=15, fig.asp=}
red_corr_justIL5_noOutlier <- round(cor(forcorr_diff_red_metabslog2_IL5_noOutlier[,-c(1:2)]), 2)

red_corr_justIL5_noOutlier[] %>%
  ggcorrplot(lab = TRUE, 
             outline.color = "white", 
             hc.order = FALSE, 
             type = "lower", 
             ggtheme = ggthemes::theme_clean(base_size = 18, base_family = "sans"),
             colors = c("#6D9EC1", "white", "#E46726")) +
  theme(axis.text.x = element_text(angle = 90, size = 12))

```
